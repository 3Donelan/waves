<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Wave Physics Simulation - Interactive Wave Interference</title>
<style>
:root {
    --bg-primary: #1a1a1a;
    --bg-secondary: #2a2a2a;
    --bg-button: #333333;
    --color-primary: #00ff88;
    --color-secondary: #0088ff;
    --color-danger: #ff4444;
    --color-warning: #ff9500;
    --color-accent: #8a2be2;
    --text-primary: white;
    --border-primary: #444444;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    overflow: hidden;
    background: #000;
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    position: fixed;
}

/* SIMULATION CANVAS */
.simulation__canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: #000;
    cursor: url("data:image/svg+xml,%3csvg width='20' height='20' xmlns='http://www.w3.org/2000/svg'%3e%3cline x1='10' y1='0' x2='10' y2='20' stroke='%2300ff88' stroke-width='2'/%3e%3cline x1='0' y1='10' x2='20' y2='10' stroke='%2300ff88' stroke-width='2'/%3e%3c/svg%3e") 10 10, crosshair;
    touch-action: none;
    display: block;
}

/* LONG PRESS INDICATOR */
.long-press-indicator {
    position: fixed;
    width: 60px;
    height: 60px;
    border: 2px solid #00ff88;
    border-radius: 50%;
    pointer-events: none;
    opacity: 0;
    transform: translate(-50%, -50%);
    z-index: 1000;
}

.long-press-indicator.is-active {
    opacity: 1;
    animation: longPressGrow 0.5s ease-out forwards;
}

.long-press-indicator.is-complete {
    animation: fadeOut 0.3s ease-out forwards;
}

/* LONG PRESS ANIMATIONS */
@keyframes longPressGrow {
    from { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(0.5); 
    }
    to { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1.2); 
        border-color: var(--color-primary); 
        box-shadow: 0 0 20px rgba(0, 255, 136, 0.6); 
    }
}

@keyframes fadeOut {
    from { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1.2); 
    }
    to { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(1.5); 
    }
}

/* DISPLAY CONTROLS */
.display-controls {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 900;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.display-control {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: var(--bg-primary);
    border: 1px solid var(--border-primary);
    border-radius: 20px;
    color: var(--text-primary);
    font-size: 14px;
    cursor: pointer;
    min-width: 60px;
}

.display-control:focus {
    outline: 2px solid var(--color-primary);
}

.control-icon {
    flex: 1;
    text-align: center;
    font-weight: bold;
}

.control-action {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 8px 12px;
    background: var(--bg-primary);
    border: 1px solid var(--border-primary);
    border-radius: 20px;
    color: var(--text-primary);
    font-size: 16px;
    cursor: pointer;
    min-width: 60px;
    font-weight: bold;
}

.control-action:focus {
    outline: 2px solid var(--color-primary);
}

.mini-toggle {
    width: 28px;
    height: 16px;
    background: var(--bg-button);
    border-radius: 8px;
    position: relative;
    border: 1px solid var(--border-primary);
}

.mini-toggle.is-active {
    background: var(--color-primary);
}

.mini-toggle__circle {
    position: absolute;
    top: 1px;
    left: 1px;
    width: 12px;
    height: 12px;
    background: white;
    border-radius: 50%;
}

.mini-toggle.is-active .mini-toggle__circle {
    transform: translateX(12px);
}

/* DELETION ZONES */
.deletion-zone {
    position: fixed;
    pointer-events: none;
    z-index: 500;
    opacity: 0;
}

.deletion-zone.is-active { opacity: 1; }

.deletion-zone--top, 
.deletion-zone--bottom {
    left: 0; 
    width: 100vw; 
    height: 4px;
    background: var(--color-danger);
}

.deletion-zone--top { top: 0; }
.deletion-zone--bottom { bottom: 0; }

.deletion-zone--left, 
.deletion-zone--right {
    top: 0; 
    height: 100vh; 
    width: 4px;
    background: var(--color-danger);
}

.deletion-zone--left { left: 0; }
.deletion-zone--right { right: 0; }

/* FLOATING ACTION BUTTONS */
.fab {
    position: fixed;
    z-index: 900;
    background: var(--bg-primary);
    border: 1px solid var(--border-primary);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: var(--text-primary);
    font-weight: 600;
}

.fab:focus {
    outline: 2px solid var(--color-primary);
}

.fab--small {
    width: 40px;
    height: 40px;
    font-size: 14px;
}

.fab--large {
    width: 56px;
    height: 56px;
    font-size: 24px;
    font-weight: 300;
}

.fab--help {
    top: 20px;
    left: 20px;
    z-index: 1000;
}

.fab--add {
    bottom: 70px;
    right: 20px;
    background: linear-gradient(135deg, var(--color-primary), #00cc6a);
    color: white;
    border: none;
    box-shadow: 0 4px 20px rgba(0, 255, 136, 0.4);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.fab--add:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 25px rgba(0, 255, 136, 0.5);
}

.fab--add:active {
    transform: translateY(0);
}

/* CONTROL PANEL */
.control-panel {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 45vh;
    background: var(--bg-primary);
    border-top: 1px solid var(--border-primary);
    border-radius: 16px 16px 0 0;
    z-index: 999;
    transform: translateY(calc(100% - 40px));
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.control-panel.is-expanded {
    transform: translateY(0);
}

.control-panel__handle {
    width: 40px;
    height: 4px;
    background: var(--color-primary);
    border-radius: 2px;
    margin: 16px auto 0;
    cursor: pointer;
    position: relative;
}

.control-panel__handle::before {
    content: '';
    position: absolute;
    top: -20px;
    left: -20px;
    right: -20px;
    bottom: -20px;
    /* Creates 44px touch target around the visual handle */
}

.control-panel__header {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px 24px 0;
    border-bottom: 1px solid var(--border-primary);
    color: var(--text-primary);
}

.control-panel__title {
    font-size: 18px;
    font-weight: 600;
    color: var(--color-primary);
    text-align: center;
    margin-bottom: 16px;
}

.control-panel__navigation {
    width: 100%;
    height: 16px;
    background: #333;
    border-radius: 8px;
    margin-bottom: 20px;
    position: relative;
    overflow: hidden;
    display: flex;
}

.nav-segment {
    flex: 1;
    height: 100%;
    cursor: pointer;
    position: relative;
}

.nav-segment:not(:last-child)::after {
    content: '';
    position: absolute;
    right: 0;
    top: 2px;
    bottom: 2px;
    width: 0.5px;
    background: #555;
}

.nav-segment.is-active {
    background: var(--color-primary);
}

.control-panel__content {
    flex: 1;
    overflow: hidden;
    position: relative;
}

.panels-container {
    display: flex;
    height: 100%;
    overflow-x: auto;
    overflow-y: hidden;
    scroll-snap-type: x mandatory;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.panels-container::-webkit-scrollbar {
    display: none;
}

/* PANELS */
.panel {
    min-width: 100%;
    width: 100%;
    height: 100%;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    padding: 20px 24px 24px;
    scroll-snap-align: start;
    scroll-snap-stop: always;
}

.panel__section {
    margin-bottom: 32px;
}

.panel__section-title {
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 16px;
    color: var(--text-primary);
}

/* CONTROL GROUPS */
.control-group {
    margin-bottom: 20px;
}

.control-group__label {
    display: block;
    font-size: 12px;
    margin-bottom: 8px;
    color: var(--text-primary);
}

.control-group--row {
    display: flex;
    gap: 20px;
    align-items: center;
}

.control-group--toggle {
    display: flex;
    flex-direction: column;
    gap: 8px;
    flex: 1;
}

/* BUTTONS */
.button {
    padding: 12px 16px;
    background: var(--bg-button);
    border: 1px solid var(--border-primary);
    border-radius: 8px;
    color: var(--text-primary);
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
}

.button:focus {
    outline: 2px solid var(--color-primary);
}

.button--primary {
    background: var(--color-primary);
    color: black;
    border-color: var(--color-primary);
}

.button--danger {
    background: var(--color-danger);
    border-color: var(--color-danger);
}

.button--secondary {
    background: var(--color-secondary);
    border-color: var(--color-secondary);
}

.button--pattern {
    background: var(--color-accent);
    border-color: var(--color-accent);
}

.button-group {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
}

.button-group .button {
    flex: 1;
    min-width: 100px;
}

/* TOGGLE SWITCHES */
.toggle {
    position: relative;
    width: 50px;
    height: 24px;
    background: var(--bg-button);
    border-radius: 12px;
    cursor: pointer;
    border: 1px solid var(--border-primary);
}

.toggle.is-active {
    background: var(--color-primary);
}

.toggle__circle {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 18px;
    height: 18px;
    background: white;
    border-radius: 50%;
}

.toggle.is-active .toggle__circle {
    transform: translateX(26px);
}

/* SLIDER CONTROLS */
.slider-control {
    position: relative;
    margin: 12px 0;
}

.slider-control__input {
    width: 100%;
    height: 6px;
    background: var(--bg-button);
    border-radius: 3px;
    outline: none;
    appearance: none;
    -webkit-appearance: none;
}

.slider-control__input::-webkit-slider-thumb {
    appearance: none;
    -webkit-appearance: none;
    width: 20px;
    height: 20px;
    background: var(--text-primary);
    border-radius: 50%;
    cursor: pointer;
}

.slider-control__input::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: var(--text-primary);
    border-radius: 50%;
    cursor: pointer;
    border: none;
}

.slider-control__value {
    position: absolute;
    right: 0;
    top: -28px;
    font-size: 11px;
    background: var(--bg-button);
    padding: 4px 8px;
    border-radius: 4px;
    min-width: 40px;
    text-align: center;
    border: 1px solid var(--border-primary);
    color: var(--text-primary);
    cursor: pointer;
}

.slider-control__value:focus {
    outline: 2px solid var(--color-primary);
}

/* SELECT CONTROLS */
.select-control {
    width: 100%;
    padding: 12px;
    background: var(--bg-button);
    border: 1px solid var(--border-primary);
    border-radius: 8px;
    color: var(--text-primary);
    font-size: 14px;
    cursor: pointer;
}

.select-control:focus {
    outline: 2px solid var(--color-primary);
}

/* INFO TEXT */
.info-text {
    font-size: 11px;
    opacity: 0.6;
    margin-top: 8px;
    color: var(--text-primary);
}

.stats-text {
    font-size: 10px;
    opacity: 0.5;
    margin-top: 8px;
    font-family: monospace;
    color: var(--text-primary);
}

/* POINT SECTION */
.point-section {
    background: var(--bg-secondary);
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 16px;
}

.point-section__header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
}

.point-section__id {
    font-size: 12px;
    opacity: 0.7;
    font-family: monospace;
    color: var(--text-primary);
}

.empty-state {
    text-align: center;
    opacity: 0.5;
    font-size: 13px;
    padding: 40px 20px;
    color: var(--text-primary);
}

.color-preview {
    width: 100%;
    height: 24px;
    border-radius: 6px;
    border: 1px solid var(--border-primary);
    margin: 8px 0;
}

/* MODALS */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.8);
    z-index: 2000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    margin: 0;
    border: none;
    color: var(--text-primary);
}

.modal__container {
    background: var(--bg-primary);
    border: 1px solid var(--border-primary);
    border-radius: 16px;
    max-width: 500px;
    width: 100%;
    color: var(--text-primary);
    overflow: hidden;
    max-height: 90vh;
    overflow-y: auto;
}

.modal__header {
    padding: 30px 30px 20px;
    text-align: center;
    border-bottom: 1px solid var(--border-primary);
}

.modal__title {
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 8px;
}

.modal__subtitle {
    font-size: 14px;
    opacity: 0.7;
    margin: 0;
}

.modal__content {
    padding: 25px 30px;
}

.modal__footer {
    padding: 20px 30px 30px;
    text-align: center;
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
}

/* INSTRUCTION LISTS */
.instruction-list {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.instruction-item {
    font-size: 14px;
    line-height: 1.5;
    padding: 12px 16px;
    background: var(--bg-secondary);
    border-radius: 8px;
    border-left: 3px solid #666;
}

.instruction-item strong {
    color: var(--color-primary);
    font-weight: 600;
}

.instruction-item--warning {
    border-left: 3px solid var(--color-warning);
}

.instruction-item--warning strong {
    color: var(--color-warning);
}

/* MODAL BUTTONS */
.modal-button {
    background: var(--color-primary);
    border: none;
    border-radius: 12px;
    color: black;
    font-size: 16px;
    font-weight: 600;
    padding: 16px 32px;
    cursor: pointer;
    margin: 0 5px;
}

.modal-button:focus {
    outline: 2px solid white;
}

.modal-button--secondary {
    background: var(--color-secondary);
    color: white;
}

/* KEYBOARD SHORTCUTS */
.keyboard-shortcuts {
    display: grid;
    gap: 8px;
    margin: 15px 0;
}

.shortcut-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    background: var(--bg-secondary);
    border-radius: 6px;
    font-size: 12px;
}

.shortcut-key {
    background: var(--bg-button);
    padding: 4px 8px;
    border-radius: 4px;
    font-family: monospace;
    font-size: 11px;
}

/* ABOUT SECTION */
.about-section {
    text-align: center;
    margin: 20px 0;
    padding: 15px;
    background: var(--bg-secondary);
    border-radius: 8px;
}

.about-section p {
    margin: 8px 0;
    font-size: 13px;
    line-height: 1.4;
}

.license-text {
    font-size: 11px;
    opacity: 0.6;
    margin-top: 15px;
    font-family: monospace;
}

/* FULLSCREEN MODE */
.fullscreen-mode .fab {
    opacity: 0;
    pointer-events: none;
}

.fullscreen-mode .control-panel {
    opacity: 0;
    pointer-events: none;
}

.fullscreen-mode .display-controls {
    opacity: 0;
    pointer-events: none;
}

/* RESPONSIVE DESIGN */
@media (min-width: 768px) {
    .fab--small {
        width: 48px;
        height: 48px;
        font-size: 16px;
    }
    
    .fab--help {
        top: 30px;
        left: 30px;
    }
    
    .fab--sync {
        bottom: 150px;
        right: 30px;
    }
    
    .fab--clear {
        bottom: 210px;
        right: 30px;
    }

    .fab--add {
        bottom: 60px;
        right: 30px;
        width: 64px;
        height: 64px;
    }
    
    .control-panel {
        height: 40vh;
        transform: translateY(calc(100% - 50px));
    }

    .control-panel__header {
        padding: 24px 32px 20px;
    }

    .panel {
        padding: 24px 32px 32px;
    }
}
</style>
</head>
<body>

<main class="wave-simulation" role="main">
    <!-- Simulation Canvas -->
    <canvas class="simulation__canvas" data-canvas="main"></canvas>

    <!-- Long Press Indicator -->
    <div class="long-press-indicator" data-indicator="long-press"></div>

    <!-- Deletion Zones -->
    <div class="deletion-zone deletion-zone--top" data-deletion="top"></div>
    <div class="deletion-zone deletion-zone--bottom" data-deletion="bottom"></div>
    <div class="deletion-zone deletion-zone--left" data-deletion="left"></div>
    <div class="deletion-zone deletion-zone--right" data-deletion="right"></div>

    <!-- Floating Action Buttons -->
    <button class="fab fab--small fab--help" data-action="help" aria-label="Help and Instructions">?</button>
    <button class="fab fab--large fab--add" data-action="add" aria-label="Add Random Point">+</button>

    <!-- Top-right Control Palette -->
    <div class="display-controls">
        <button class="display-control" data-toggle="show-points" aria-label="Toggle Point Visibility">
            <span class="control-icon">●</span>
            <div class="mini-toggle">
                <div class="mini-toggle__circle"></div>
            </div>
        </button>
        <button class="display-control" data-toggle="show-grid" aria-label="Toggle Grid Visibility">
            <span class="control-icon">#</span>
            <div class="mini-toggle">
                <div class="mini-toggle__circle"></div>
            </div>
        </button>
        <button class="control-action" data-action="sync" aria-label="Synchronize Wave Points">↻</button>
        <button class="control-action" data-action="clear" aria-label="Clear All Points">×</button>
    </div>

    <!-- Control Panel -->
    <section class="control-panel" data-panel="main">
        <div class="control-panel__handle" data-handle="control-panel"></div>
        
        <header class="control-panel__header">
            <h1 class="control-panel__title" data-title="panel">
                <span data-panel-title="text">Medium Properties</span>
            </h1>
            
            <nav class="control-panel__navigation" data-navigation="panels">
                <div class="nav-segment is-active" data-panel-nav="0"></div>
                <div class="nav-segment" data-panel-nav="1"></div>
                <div class="nav-segment" data-panel-nav="2"></div>
            </nav>
        </header>
        
        <div class="control-panel__content">
            <div class="panels-container" data-panels="container">
                
                <!-- Panel 1: Medium Properties -->
                <section class="panel" data-panel-id="0">
                    <div class="panel__section">
                        <div class="control-group">
                            <label class="control-group__label">Color Mode</label>
                            <div class="toggle" data-toggle="color-mode">
                                <div class="toggle__circle"></div>
                            </div>
                            <div class="info-text">Enable for colorful wave patterns</div>
                        </div>
                        
                        <div class="control-group" data-color-controls="minima" style="display: none;">
                            <label class="control-group__label">Minima Color (Hue)</label>
                            <div class="slider-control">
                                <input type="range" class="slider-control__input" data-slider="hue1" min="0" max="360" step="1" value="185">
                                <input type="number" class="slider-control__value" data-input="hue1" min="0" max="360" value="185">
                            </div>
                        </div>
                        
                        <div class="control-group" data-color-controls="maxima" style="display: none;">
                            <label class="control-group__label">Maxima Color (Hue)</label>
                            <div class="slider-control">
                                <input type="range" class="slider-control__input" data-slider="hue2" min="0" max="360" step="1" value="285">
                                <input type="number" class="slider-control__value" data-input="hue2" min="0" max="360" value="285">
                            </div>
                        </div>
                        
                        <div class="control-group" data-color-controls="preview" style="display: none;">
                            <label class="control-group__label">Color Preview</label>
                            <div class="color-preview" data-preview="gradient" style="background: linear-gradient(to right, hsl(185, 70%, 50%), hsl(285, 70%, 50%));"></div>
                        </div>
                    </div>
                    
                    <div class="panel__section">
                        <div class="control-group">
                            <label class="control-group__label">Animation Speed</label>
                            <div class="slider-control">
                                <input type="range" class="slider-control__input" data-slider="time-multiplier" min="0.0" max="30.0" step="0.1" value="10.0">
                                <input type="number" class="slider-control__value" data-input="time-multiplier" min="0.0" max="30.0" step="0.1" value="10.0">
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-group__label">Damping</label>
                            <div class="slider-control">
                                <input type="range" class="slider-control__input" data-slider="damping" min="0.0" max="0.03" step="0.002" value="0.008">
                                <input type="number" class="slider-control__value" data-input="damping" min="0.0" max="0.03" step="0.002" value="0.008">
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-group__label">Resolution</label>
                            <div class="slider-control">
                                <input type="range" class="slider-control__input" data-slider="performance" min="0" max="5" step="1" value="2">
                                <input type="number" class="slider-control__value" data-input="performance" min="0" max="5" value="2">
                            </div>
                            <div class="info-text">Higher values = faster rendering</div>
                        </div>
                    </div>
                </section>
                
                <!-- Panel 2: Pattern Generator -->
                <section class="panel" data-panel-id="1">
                    <div class="panel__section">
                        <div class="button-group">
                            <button class="button button--pattern" data-action="generate-pattern">Add Pattern</button>
                        </div>
                        <div class="info-text">Adds to existing points (max 36 total)</div>
                    </div>
                    
                    <div class="panel__section">
                        <div class="control-group">
                            <label class="control-group__label">Pattern Type</label>
                            <select data-select="pattern-type" class="select-control">
                                <option value="grid">Grid</option>
                                <option value="radial">Radial</option>
                                <option value="spiral">Spiral</option>
                                <option value="sunflower">Sunflower</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-group__label">Number of Points</label>
                            <div class="slider-control">
                                <input type="range" class="slider-control__input" data-slider="pattern-count" min="3" max="36" step="1" value="16">
                                <input type="number" class="slider-control__value" data-input="pattern-count" min="3" max="36" value="16">
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-group__label">Pattern Scale</label>
                            <div class="slider-control">
                                <input type="range" class="slider-control__input" data-slider="pattern-scale" min="0.3" max="2.0" step="0.1" value="1.0">
                                <input type="number" class="slider-control__value" data-input="pattern-scale" min="0.3" max="2.0" step="0.1" value="1.0">
                            </div>
                        </div>
                    </div>
                </section>
                
                <!-- Panel 3: Edit Points -->
                <section class="panel" data-panel-id="2">
                    <div class="panel__section">
                        <div class="control-group" data-edit-mode="container" style="display: none;">
                            <label class="control-group__label">
                                <input type="checkbox" data-checkbox="single-edit-mode" style="margin-right: 8px;">
                                Edit Selected Point Only
                            </label>
                        </div>
                        
                        <div class="point-section" data-selected-point="info" style="display: none;">
                            <div class="point-section__header">
                                <span class="point-section__id" data-selected-point="id">Point #1</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="panel__section">
                        <div class="control-group">
                            <label class="control-group__label">Amplitude</label>
                            <div class="slider-control">
                                <input type="range" class="slider-control__input" data-slider="point-amplitude" min="10" max="100" step="5" value="60">
                                <input type="number" class="slider-control__value" data-input="point-amplitude" min="10" max="100" value="60">
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-group__label">Wavelength</label>
                            <div class="slider-control">
                                <input type="range" class="slider-control__input" data-slider="point-wavelength" min="20" max="400" step="10" value="100">
                                <input type="number" class="slider-control__value" data-input="point-wavelength" min="20" max="400" value="100">
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-group__label">Phase Velocity</label>
                            <div class="slider-control">
                                <input type="range" class="slider-control__input" data-slider="point-speed" min="0.1" max="1.0" step="0.1" value="1.0">
                                <input type="number" class="slider-control__value" data-input="point-speed" min="0.1" max="1.0" step="0.1" value="1.0">
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-group__label">Point Phase Offset</label>
                            <div class="slider-control">
                                <input type="range" class="slider-control__input" data-slider="point-phase-offset" min="-2" max="2" step="0.1" value="0">
                                <input type="number" class="slider-control__value" data-input="point-phase-offset" min="-2" max="2" step="0.1" value="0">
                            </div>
                            <div class="info-text">Creates time delays between points</div>
                        </div>
                    </div>
                </section>
                
            </div>
        </div>
    </section>
</main>

<!-- Modals -->
<dialog class="modal" data-modal="welcome">
    <div class="modal__container">
        <header class="modal__header">
            <h2 class="modal__title">Wave Physics Simulation</h2>
            <p class="modal__subtitle">Interactive wave interference patterns</p>
        </header>
        <div class="modal__content">
            <div class="instruction-list">
                <div class="instruction-item">
                    <strong>Create waves:</strong> Press and hold on empty space to add wave sources
                </div>
                <div class="instruction-item">
                    <strong>Generate patterns:</strong> Use Pattern Generator for mathematical layouts
                </div>
                <div class="instruction-item">
                    <strong>Manipulate:</strong> Select, move, clone, and customize wave points
                </div>
                <div class="instruction-item">
                    <strong>Controls:</strong> Access tools via bottom sheet - swipe between panels
                </div>
            </div>
        </div>
        <footer class="modal__footer">
            <button class="modal-button" data-modal-action="start">Get Started</button>
        </footer>
    </div>
</dialog>

<dialog class="modal" data-modal="health-warning" style="display: none;">
    <div class="modal__container">
        <header class="modal__header">
            <h2 class="modal__title">Health & Safety Warning</h2>
            <p class="modal__subtitle">Important information before you begin</p>
        </header>
        <div class="modal__content">
            <div class="instruction-list">
                <div class="instruction-item instruction-item--warning">
                    <strong>Photosensitive Epilepsy:</strong> This simulation contains flashing patterns and rapid visual changes that may trigger seizures in individuals with photosensitive epilepsy
                </div>
                <div class="instruction-item instruction-item--warning">
                    <strong>Motion Sensitivity:</strong> The dynamic wave patterns may cause discomfort for those sensitive to motion or visual effects
                </div>
                <div class="instruction-item">
                    <strong>Safe Usage:</strong> If you experience any discomfort, dizziness, or unusual symptoms, please stop using the simulation immediately
                </div>
            </div>
        </div>
        <footer class="modal__footer">
            <button class="modal-button modal-button--secondary" data-modal-action="back">Go Back</button>
            <button class="modal-button" data-modal-action="continue">I Understand, Continue</button>
        </footer>
    </div>
</dialog>

<dialog class="modal" data-modal="help" style="display: none;">
    <div class="modal__container">
        <header class="modal__header">
            <h2 class="modal__title">Help & Instructions</h2>
            <p class="modal__subtitle">Complete guide to wave simulation</p>
        </header>
        <div class="modal__content">
            <h3 class="panel__section-title">Basic Controls</h3>
            <div class="instruction-list">
                <div class="instruction-item">
                    <strong>Add Point:</strong> Press and hold on empty space until indicator completes
                </div>
                <div class="instruction-item">
                    <strong>Select Point:</strong> Tap on wave point to select it
                </div>
                <div class="instruction-item">
                    <strong>Move Point:</strong> Drag selected point to new position
                </div>
                <div class="instruction-item">
                    <strong>Delete Point:</strong> Drag point to screen edge and hold
                </div>
                <div class="instruction-item">
                    <strong>Clone Point:</strong> Double-tap on existing point
                </div>
            </div>
            
            <h3 class="panel__section-title">Bottom Sheet Navigation</h3>
            <div class="instruction-list">
                <div class="instruction-item">
                    <strong>Expand:</strong> Tap handle or swipe up from bottom
                </div>
                <div class="instruction-item">
                    <strong>Navigate:</strong> Swipe left/right or tap navigation segments
                </div>
                <div class="instruction-item">
                    <strong>Panels:</strong> Display Options → Medium Properties → Pattern Generator → Edit Points
                </div>
            </div>
            
            <h3 class="panel__section-title">Keyboard Shortcuts</h3>
            <div class="keyboard-shortcuts">
                <div class="shortcut-item">
                    <span>Delete selected point</span>
                    <span class="shortcut-key">Del / Backspace</span>
                </div>
                <div class="shortcut-item">
                    <span>Clone selected point</span>
                    <span class="shortcut-key">C</span>
                </div>
                <div class="shortcut-item">
                    <span>Collapse bottom sheet</span>
                    <span class="shortcut-key">Esc</span>
                </div>
            </div>
            
            <div class="about-section">
                <p><strong>Wave Physics Simulation</strong></p>
                <p>Proper integration - Real physics with modern UI</p>
            </div>
        </div>
        <footer class="modal__footer">
            <button class="modal-button" data-modal-action="close">Close</button>
        </footer>
    </div>
</dialog>

<script>
'use strict';

// ====================================================================
// CONFIGURATION
// ====================================================================
const CONFIG = {
    maxPoints: 36,
    pointVisualRadius: 12,
    pointHitRadius: 25,
    pointBorderWidth: 2,
    longPressDuration: 500,
    frameInterval: 20,
    minPointDistance: 40,
    
    defaults: {
        amplitude: 60,
        wavelength: 100,
        speed: 1.0,
        performanceLevel: 2,
        damping: 0.008,
        showPoints: false
    },
    
    ranges: {
        amplitude: { min: 10, max: 100, mid: 55 },
        wavelength: { min: 20, max: 400, mid: 210 },
        speed: { min: 0.1, max: 1.0, mid: 0.55 },
        hue1: { min: 0, max: 360, mid: 180 },
        hue2: { min: 0, max: 360, mid: 180 },
        phaseOffset: { min: -2, max: 2, mid: 0 },
        damping: { min: 0.0, max: 0.03, mid: 0.015 },
        performance: { min: 0, max: 5, mid: 3 },
        patternCount: { min: 3, max: 36, mid: 20 },
        patternScale: { min: 0.3, max: 2.0, mid: 1.15 },
        timeMultiplier: { min: 0.0, max: 30.0, mid: 10.0 }
    },
    
    performanceLevels: [
        { skip: 1, label: 'Quality' },
        { skip: 2, label: 'Balanced' },
        { skip: 4, label: 'Fast' },
        { skip: 8, label: 'Faster' },
        { skip: 16, label: 'Very Fast' },
        { skip: 32, label: 'Ultra Fast' }
    ],
    
    panelNames: [
        'Medium Properties', 
        'Pattern Generator',
        'Edit Points'
    ]
};

// ====================================================================
// UTILITY FUNCTIONS
// ====================================================================
const Utils = {
    clamp: (val, min, max) => Math.max(min, Math.min(max, val)),
    distance: (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2),
    formatValue: (val, decimals = 3) => Number(val).toFixed(decimals),
    generateId: () => `point_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    
    haptic: () => {
        if ('vibrate' in navigator) navigator.vibrate(10);
    },
    
    snapToGrid: (x, y, gridSpacing) => {
        return {
            x: Math.round(x / gridSpacing) * gridSpacing,
            y: Math.round(y / gridSpacing) * gridSpacing
        };
    },
    
    formatInputValue: (value, fieldType) => {
        switch (fieldType) {
            case 'amplitude':
            case 'wavelength':
            case 'patternCount':
            case 'performance':
            case 'hue1':
            case 'hue2':
                return Math.round(value).toString();
            case 'damping':
                return Utils.formatValue(value, 3);
            case 'timeMultiplier':
                return Utils.formatValue(value, 1);
            case 'speed':
            case 'patternScale':
            case 'phaseOffset':
                return Utils.formatValue(value, 1);
            default:
                return value.toString();
        }
    },
    
    validateNumericInput: (value, fieldType) => {
        const range = CONFIG.ranges[fieldType];
        if (!range) return value;
        
        const numValue = parseFloat(value);
        
        if (isNaN(numValue) || value === '' || value === null || value === undefined) {
            return range.mid;
        }
        
        if (numValue < range.min) return range.min;
        if (numValue > range.max) return range.max;
        
        return numValue;
    }
};

// ====================================================================
// PATTERN GENERATOR CLASS
// ====================================================================
class PatternGenerator {
    static generate(type, count, bounds, scale = 1.0) {
        const cx = bounds.width / 2;
        const cy = bounds.height / 2;
        const maxRadius = (Math.min(bounds.width, bounds.height) / 2 - 50) * scale;
        
        switch (type) {
            case 'grid': return this.generateGrid(count, cx, cy, maxRadius);
            case 'radial': return this.generateRadial(count, cx, cy, maxRadius);
            case 'spiral': return this.generateSpiral(count, cx, cy, maxRadius);
            case 'sunflower': return this.generateSunflower(count, cx, cy, maxRadius);
            default: return [];
        }
    }
    
    static generateGrid(count, cx, cy, maxRadius) {
        const points = [];
        const gridSize = Math.ceil(Math.sqrt(count));
        const spacing = (maxRadius * 2) / (gridSize + 1);
        const startX = cx - (gridSize - 1) * spacing / 2;
        const startY = cy - (gridSize - 1) * spacing / 2;
        
        for (let i = 0; i < gridSize * gridSize && points.length < count; i++) {
            const row = Math.floor(i / gridSize);
            const col = i % gridSize;
            points.push({
                x: startX + col * spacing,
                y: startY + row * spacing
            });
        }
        return points;
    }
    
    static generateRadial(count, cx, cy, maxRadius) {
        const points = [];
        const rings = Math.min(4, Math.ceil(count / 8));
        const pointsPerRing = Math.ceil(count / rings);
        
        for (let ring = 0; ring < rings; ring++) {
            const radius = ((ring + 1) / rings) * maxRadius;
            const ringCount = Math.min(pointsPerRing, count - points.length);
            
            for (let i = 0; i < ringCount; i++) {
                const angle = (i / ringCount) * 2 * Math.PI - Math.PI / 2;
                points.push({
                    x: cx + radius * Math.cos(angle),
                    y: cy + radius * Math.sin(angle)
                });
            }
        }
        return points;
    }
    
    static generateSpiral(count, cx, cy, maxRadius) {
        const points = [];
        const maxAngle = 4 * Math.PI;
        
        for (let i = 0; i < count; i++) {
            const t = (i / count) * maxAngle;
            const radius = (t / maxAngle) * maxRadius;
            points.push({
                x: cx + radius * Math.cos(t),
                y: cy + radius * Math.sin(t)
            });
        }
        return points;
    }
    
    static generateSunflower(count, cx, cy, maxRadius) {
        const points = [];
        const golden = Math.PI * (3 - Math.sqrt(5));
        
        for (let i = 0; i < count; i++) {
            const theta = i * golden;
            const radius = Math.sqrt(i / count) * maxRadius;
            points.push({
                x: cx + radius * Math.cos(theta),
                y: cy + radius * Math.sin(theta)
            });
        }
        return points;
    }
    
    static findRandomPosition(existingPoints, bounds) {
        const margin = 30;
        const minDist = CONFIG.minPointDistance;
        const maxAttempts = 50;
        
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            const x = margin + Math.random() * (bounds.width - 2 * margin);
            const y = margin + Math.random() * (bounds.height - 2 * margin);
            
            const tooClose = existingPoints.some(point => 
                Utils.distance(x, y, point.x, point.y) < minDist
            );
            
            if (!tooClose) return { x, y };
        }
        
        return {
            x: margin + Math.random() * (bounds.width - 2 * margin),
            y: margin + Math.random() * (bounds.height - 2 * margin)
        };
    }
}

// ====================================================================
// WAVE POINT CLASS
// ====================================================================
class WavePoint {
    constructor(x, y, properties = {}) {
        this.id = Utils.generateId();
        this.x = x;
        this.y = y;
        this.startTime = 0;
        this.selected = false;
        this.amplitude = properties.amplitude || CONFIG.defaults.amplitude;
        this.wavelength = properties.wavelength || CONFIG.defaults.wavelength;
        this.speed = properties.speed || CONFIG.defaults.speed;
        this.phaseOffset = properties.phaseOffset || 0;
        this.creationIndex = properties.creationIndex || 0;
        
        this.inDeletionZone = false;
        this.deletionTimer = null;
    }
    
    getProperties() {
        return {
            amplitude: this.amplitude,
            wavelength: this.wavelength,
            speed: this.speed,
            phaseOffset: this.phaseOffset
        };
    }
    
    distanceTo(x, y) {
        return Utils.distance(this.x, this.y, x, y);
    }
    
    isHit(x, y) {
        return this.distanceTo(x, y) <= CONFIG.pointHitRadius;
    }
    
    getDisplayName() {
        return `Point ${this.id.split('_')[1].slice(-3)}`;
    }
    
    get frequency() {
        return (2 * Math.PI) / this.wavelength;
    }
}

// ====================================================================
// WAVE ENGINE CLASS
// ====================================================================
class WaveEngine {
    constructor() {
        this.points = new Map();
        this.time = 0;
        this.pointPhaseOffset = 0;
        this.mediumDamping = CONFIG.defaults.damping;
        this.creationCounter = 0;
        this.hue1 = 185;
        this.hue2 = 285;
        this.useColor = false;
        this.timeMultiplier = 10.0;
        this.useRealisticDecay = false;
    }
    
    addPoint(x, y, properties = {}) {
        if (this.points.size >= CONFIG.maxPoints) {
            Utils.haptic();
            return null;
        }
        
        const point = new WavePoint(x, y, { 
            ...properties, 
            creationIndex: this.creationCounter++,
            phaseOffset: this.pointPhaseOffset * (this.creationCounter - 1)
        });
        point.startTime = this.time;
        this.points.set(point.id, point);
        return point;
    }
    
    removePoint(id) {
        return this.points.delete(id);
    }
    
    getPoint(id) {
        return this.points.get(id);
    }
    
    getAllPoints() {
        return Array.from(this.points.values());
    }
    
    findPointAt(x, y) {
        for (const point of this.points.values()) {
            if (point.isHit(x, y)) return point;
        }
        return null;
    }
    
    clearAll() {
        this.points.clear();
        this.time = 0;
        this.creationCounter = 0;
    }
    
    syncPoints() {
        this.time = 0;
        this.pointPhaseOffset = 0;
        
        for (const point of this.points.values()) {
            point.startTime = 0;
            point.phaseOffset = 0;
        }
    }
    
    applyPointPhaseOffsets() {
        const points = this.getAllPoints().sort((a, b) => a.creationIndex - b.creationIndex);
        points.forEach((point, index) => {
            point.phaseOffset = this.pointPhaseOffset * index;
        });
    }
    
    calculatePixel(x, y) {
        let totalWave = 0;
        
        for (const point of this.points.values()) {
            const age = this.time - point.startTime;
            if (age < 0) continue;
            
            const dist = point.distanceTo(x, y);
            const k = (2 * Math.PI) / point.wavelength;
            const phase = k * dist - (point.speed * k) * age + point.phaseOffset;
            
            let waveValue = point.amplitude * Math.sin(phase);
            
            if (this.useRealisticDecay) {
                const geometricDecay = 1 / Math.sqrt(dist + 1);
                waveValue *= geometricDecay;
            } else {
                const exponentialDecay = Math.exp(-dist * this.mediumDamping);
                waveValue *= exponentialDecay;
            }
            
            totalWave += waveValue;
        }
        
        return this.waveToColor(totalWave);
    }
    
    waveToColor(waveValue) {
        if (!this.useColor) {
            const normalized = waveValue / 100;
            return Utils.clamp(128 + normalized * 127, 0, 255);
        }
        
        const normalizedValue = Utils.clamp((waveValue / 100 + 1) / 2, 0, 1);
        const interpolatedHue = this.lerpHue(this.hue1, this.hue2, normalizedValue);
        return this.hslToRgb(interpolatedHue, 70, 50);
    }
    
    lerpHue(hue1, hue2, t) {
        let diff = Math.abs(hue1 - hue2);
        if (diff > 180) {
            if (hue2 > hue1) hue1 += 360;
            else hue2 += 360;
        }
        return Math.round((hue1 + (hue2 - hue1) * t) % 360);
    }
    
    hslToRgb(h, s, l) {
        h /= 360;
        s /= 100;
        l /= 100;
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h * 6) % 2 - 1));
        const m = l - c / 2;
        
        let r, g, b;
        if (h < 1/6) [r, g, b] = [c, x, 0];
        else if (h < 2/6) [r, g, b] = [x, c, 0];
        else if (h < 3/6) [r, g, b] = [0, c, x];
        else if (h < 4/6) [r, g, b] = [0, x, c];
        else if (h < 5/6) [r, g, b] = [x, 0, c];
        else [r, g, b] = [c, 0, x];
        
        return {
            r: Math.round((r + m) * 255),
            g: Math.round((g + m) * 255),
            b: Math.round((b + m) * 255)
        };
    }
    
    updateTime(deltaTime) {
        this.time += deltaTime * this.timeMultiplier;
    }
    
    setTimeMultiplier(multiplier) {
        this.timeMultiplier = multiplier;
    }
    
    setColorMode(enabled) {
        this.useColor = enabled;
    }
    
    setHues(hue1, hue2) {
        this.hue1 = hue1;
        this.hue2 = hue2;
    }
    
    setPointPhaseOffset(offset) {
        this.pointPhaseOffset = offset;
        this.applyPointPhaseOffsets();
    }
    
    setDamping(damping) {
        this.mediumDamping = damping;
    }
    
    setRealisticDecay(enabled) {
        this.useRealisticDecay = enabled;
    }
}

// ====================================================================
// RENDERER CLASS
// ====================================================================
class Renderer {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.imageData = null;
        this.skipFactor = CONFIG.performanceLevels[CONFIG.defaults.performanceLevel].skip;
        this.lastRenderTime = 0;
        this.resize();
    }
    
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
    }
    
    setPerformanceLevel(level) {
        this.skipFactor = CONFIG.performanceLevels[level].skip;
    }
    
    render(engine, showPoints, showGrid, selectedPoint) {
        const startTime = performance.now();
        
        this.clearCanvas();
        
        if (engine.points.size > 0) {
            this.renderWaveField(engine);
        }
        
        this.ctx.putImageData(this.imageData, 0, 0);
        
        if (showGrid) {
            this.renderGrid(engine);
        }
        
        this.renderPoints(engine.getAllPoints(), showPoints, selectedPoint);
        
        this.lastRenderTime = performance.now() - startTime;
    }
    
    clearCanvas() {
        const data = this.imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            data[i] = data[i + 1] = data[i + 2] = 0;
            data[i + 3] = 255;
        }
    }
    
    renderWaveField(engine) {
        const { width, height } = this.canvas;
        const skip = this.skipFactor;
        
        for (let y = 0; y < height; y += skip) {
            for (let x = 0; x < width; x += skip) {
                const color = engine.calculatePixel(x, y);
                this.fillBlock(x, y, color, skip);
            }
        }
    }
    
    fillBlock(startX, startY, color, size) {
        const data = this.imageData.data;
        const { width, height } = this.canvas;
        
        for (let dy = 0; dy < size && startY + dy < height; dy++) {
            for (let dx = 0; dx < size && startX + dx < width; dx++) {
                const index = ((startY + dy) * width + (startX + dx)) * 4;
                
                if (typeof color === 'object') {
                    data[index] = color.r;
                    data[index + 1] = color.g;
                    data[index + 2] = color.b;
                } else {
                    data[index] = data[index + 1] = data[index + 2] = color;
                }
            }
        }
    }
    
    renderGrid(engine) {
        const { width, height } = this.canvas;
        const gridSpacing = this.skipFactor * 10;
        
        const baseOpacity = 0.2 + (0.3 * (1 - engine.points.size / CONFIG.maxPoints));
        this.ctx.strokeStyle = `rgba(255, 255, 255, ${baseOpacity})`;
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        
        for (let x = gridSpacing; x < width; x += gridSpacing) {
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, height);
        }
        
        for (let y = gridSpacing; y < height; y += gridSpacing) {
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(width, y);
        }
        
        this.ctx.stroke();
    }
    
    renderPoints(allPoints, showPoints, selectedPoint) {
        if (showPoints) {
            allPoints.forEach(point => this.drawPoint(point));
        } else if (selectedPoint) {
            this.drawPoint(selectedPoint);
        }
    }
    
    drawPoint(point) {
        const visualRadius = CONFIG.pointVisualRadius;
        const hitRadius = CONFIG.pointHitRadius;
        const borderWidth = CONFIG.pointBorderWidth;
        
        if (point.selected) {
            this.ctx.strokeStyle = '#00ff88';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(point.x, point.y, hitRadius, 0, 2 * Math.PI);
            this.ctx.stroke();
        }
        
        // Draw edit mode indicator (second green circle)
        if (point.selected && window.app && window.app.interactionManager && 
            window.app.interactionManager.isEditMode && 
            window.app.interactionManager.editModePoint === point) {
            this.ctx.strokeStyle = '#00ff88';
            this.ctx.lineWidth = 3;
            this.ctx.beginPath();
            this.ctx.arc(point.x, point.y, hitRadius + 10, 0, 2 * Math.PI);
            this.ctx.stroke();
        }
        
        let deletionProgress = 0;
        let finalRadius = visualRadius;
        let pointColor = 'white';
        
        if (point.inDeletionZone && point.deletionTimer) {
            const elapsed = performance.now() - point.deletionTimer;
            deletionProgress = Math.min(elapsed / 500, 1);
            
            const redIntensity = Math.floor(255 * deletionProgress);
            const whiteIntensity = Math.floor(255 * (1 - deletionProgress));
            pointColor = `rgb(255, ${whiteIntensity}, ${whiteIntensity})`;
            finalRadius = visualRadius + (deletionProgress * 4);
        } else if (point.inDeletionZone) {
            pointColor = '#ff4444';
        }
        
        this.ctx.fillStyle = '#333333';
        this.ctx.beginPath();
        this.ctx.arc(point.x, point.y, finalRadius + borderWidth, 0, 2 * Math.PI);
        this.ctx.fill();
        
        this.ctx.fillStyle = pointColor;
        this.ctx.beginPath();
        this.ctx.arc(point.x, point.y, finalRadius, 0, 2 * Math.PI);
        this.ctx.fill();
    }
    
    getPerformanceInfo() {
        const config = CONFIG.performanceLevels.find(level => level.skip === this.skipFactor);
        const width = Math.floor(window.innerWidth / this.skipFactor);
        const height = Math.floor(window.innerHeight / this.skipFactor);
        const speedup = this.skipFactor === 1 ? '' : ` (${this.skipFactor ** 2}x faster)`;
        
        return {
            label: config.label,
            resolution: `${width}×${height}${speedup}`,
            renderTime: this.lastRenderTime.toFixed(1)
        };
    }
}

// ====================================================================
// ANIMATION MANAGER
// ====================================================================
class AnimationManager {
    constructor(renderer, engine) {
        this.renderer = renderer;
        this.engine = engine;
        this.isAnimating = false;
        this.animationId = null;
        this.lastFrameTime = 0;
        this.frameInterval = CONFIG.frameInterval;
        this.showPoints = CONFIG.defaults.showPoints;
        this.showGrid = false;
        this.selectedPoint = null;
        this.fps = 60;
        this.frameCount = 0;
        
        this.fpsInterval = setInterval(() => {
            this.fps = this.frameCount;
            this.frameCount = 0;
        }, 1000);
    }
    
    start() {
        if (this.isAnimating) return;
        
        this.isAnimating = true;
        this.lastFrameTime = performance.now();
        this.animate();
    }
    
    stop() {
        this.isAnimating = false;
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
    }
    
    animate() {
        const currentTime = performance.now();
        
        if (this.isAnimating && (currentTime - this.lastFrameTime) >= this.frameInterval) {
            this.engine.updateTime(0.2);
            this.renderer.render(this.engine, this.showPoints, this.showGrid, this.selectedPoint);
            this.lastFrameTime = currentTime;
            this.frameCount++;
        }
        
        if (this.isAnimating) {
            this.animationId = requestAnimationFrame(() => this.animate());
        }
    }
    
    setShowPoints(show) {
        this.showPoints = show;
        this.renderer.render(this.engine, this.showPoints, this.showGrid, this.selectedPoint);
    }
    
    setShowGrid(show) {
        this.showGrid = show;
        this.renderer.render(this.engine, this.showPoints, this.showGrid, this.selectedPoint);
    }
    
    setSelectedPoint(point) {
        this.selectedPoint = point;
        this.renderer.render(this.engine, this.showPoints, this.showGrid, this.selectedPoint);
    }
    
    forceRender() {
        this.renderer.render(this.engine, this.showPoints, this.showGrid, this.selectedPoint);
    }
}

// ====================================================================
// INPUT CONTROLLER
// ====================================================================
class InputController {
    constructor() {
        this.handlers = new Map();
    }
    
    registerSliderPair(sliderSelector, inputSelector, handler) {
        const slider = document.querySelector(sliderSelector);
        const input = document.querySelector(inputSelector);
        
        if (!slider || !input) return;
        
        const fieldType = this.getFieldType(sliderSelector);
        
        slider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            input.value = this.formatDisplayValue(value, fieldType);
            handler(value);
        });
        
        input.addEventListener('input', (e) => {
            const rawValue = e.target.value;
            const numValue = parseFloat(rawValue);
            
            if (!isNaN(numValue)) {
                const validValue = Utils.validateNumericInput(numValue, fieldType);
                slider.value = validValue;
                handler(validValue);
            }
        });
        
        input.addEventListener('blur', (e) => {
            const rawValue = e.target.value;
            const validValue = Utils.validateNumericInput(rawValue, fieldType);
            slider.value = validValue;
            input.value = this.formatDisplayValue(validValue, fieldType);
            handler(validValue);
        });
    }
    
    getFieldType(selector) {
        const fieldMap = {
            '[data-slider="point-amplitude"]': 'amplitude',
            '[data-slider="point-wavelength"]': 'wavelength',
            '[data-slider="point-speed"]': 'speed',
            '[data-slider="hue1"]': 'hue1',
            '[data-slider="hue2"]': 'hue2',
            '[data-slider="point-phase-offset"]': 'phaseOffset',
            '[data-slider="damping"]': 'damping',
            '[data-slider="performance"]': 'performance',
            '[data-slider="pattern-count"]': 'patternCount',
            '[data-slider="pattern-scale"]': 'patternScale',
            '[data-slider="time-multiplier"]': 'timeMultiplier'
        };
        
        return fieldMap[selector] || selector;
    }
    
    formatDisplayValue(value, fieldType) {
        return Utils.formatInputValue(value, fieldType);
    }
    
    updatePair(sliderSelector, inputSelector, value) {
        const slider = document.querySelector(sliderSelector);
        const input = document.querySelector(inputSelector);
        const fieldType = this.getFieldType(sliderSelector);
        
        if (slider) slider.value = value;
        if (input) input.value = this.formatDisplayValue(value, fieldType);
    }
}

// ====================================================================
// BOTTOM SHEET CONTROLLER
// ====================================================================
class BottomSheetController {
    constructor() {
        this.currentPanel = 0;
        this.totalPanels = CONFIG.panelNames.length;
        this.isExpanded = false;
        
        this.isDraggingHandle = false;
        this.dragStartY = 0;
        this.initialTransform = 0;
        
        // Enhanced drag responsiveness
        this.dragStartTime = 0;
        this.lastDragY = 0;
        this.dragVelocity = 0;
        this.velocityThreshold = 0.5; // pixels per ms for velocity-based snapping
        this.positionThreshold = 0.15; // 15% instead of 30% for easier snapping
        
        // Enhanced touch handling
        this.tapStartPos = { x: 0, y: 0 };
        this.totalMovement = 0;
        this.tapThreshold = 8; // pixels - less than this counts as tap
        this.minDragDistance = 3; // pixels - minimum for drag to register
        
        this.elements = {
            bottomSheet: document.querySelector('[data-panel="main"]'),
            sheetHandle: document.querySelector('[data-handle="control-panel"]'),
            panelTitle: document.querySelector('[data-panel-title="text"]'),
            panelsContainer: document.querySelector('[data-panels="container"]'),
            panelNavigation: document.querySelector('[data-navigation="panels"]'),
            navSegments: document.querySelectorAll('[data-panel-nav]')
        };
        
        this.setupEventListeners();
        this.updateUI();
    }
    
    setupEventListeners() {
        if (this.elements.sheetHandle) {
            this.setupHandleDrag();
        }
        
        if (this.elements.panelsContainer) {
            this.setupScrollNavigation();
        }
        
        if (this.elements.navSegments) {
            this.setupSegmentNavigation();
        }
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.isExpanded) {
                this.collapse();
            } else if (this.isExpanded) {
                if (e.key === 'ArrowLeft') {
                    this.scrollToPreviousPanel();
                } else if (e.key === 'ArrowRight') {
                    this.scrollToNextPanel();
                }
            }
        });
    }
    
    setupSegmentNavigation() {
        this.elements.navSegments.forEach((segment, index) => {
            segment.addEventListener('click', () => {
                this.scrollToPanel(index);
            });
        });
    }
    
    setupScrollNavigation() {
        const container = this.elements.panelsContainer;
        let isScrolling = false;
        let scrollTimeout;
        
        container.addEventListener('scroll', () => {
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
            }
            
            isScrolling = true;
            
            scrollTimeout = setTimeout(() => {
                isScrolling = false;
                this.detectCurrentPanel();
            }, 150);
            
            this.detectCurrentPanel();
        }, { passive: true });
    }
    
    detectCurrentPanel() {
        const container = this.elements.panelsContainer;
        const containerWidth = container.offsetWidth;
        const scrollLeft = container.scrollLeft;
        
        const newPanel = Math.round(scrollLeft / containerWidth);
        const clampedPanel = Math.max(0, Math.min(this.totalPanels - 1, newPanel));
        
        if (clampedPanel !== this.currentPanel) {
            this.currentPanel = clampedPanel;
            this.updateUI();
        }
    }
    
    scrollToPanel(index) {
        if (index >= 0 && index < this.totalPanels) {
            const container = this.elements.panelsContainer;
            const containerWidth = container.offsetWidth;
            const scrollLeft = index * containerWidth;
            
            container.scrollLeft = scrollLeft;
            
            this.currentPanel = index;
            this.updateUI();
        }
    }
    
    scrollToPreviousPanel() {
        if (this.currentPanel > 0) {
            this.scrollToPanel(this.currentPanel - 1);
        }
    }
    
    scrollToNextPanel() {
        if (this.currentPanel < this.totalPanels - 1) {
            this.scrollToPanel(this.currentPanel + 1);
        }
    }
    
    setupHandleDrag() {
        const handle = this.elements.sheetHandle;
        const sheet = this.elements.bottomSheet;
        
        handle.addEventListener('touchstart', (e) => {
            this.startDrag(e.touches[0].clientY);
            this.tapStartPos.x = e.touches[0].clientX;
            this.tapStartPos.y = e.touches[0].clientY;
            this.totalMovement = 0;
            e.preventDefault();
        }, { passive: false });
        
        document.addEventListener('touchmove', (e) => {
            if (this.isDraggingHandle) {
                const currentY = e.touches[0].clientY;
                const currentX = e.touches[0].clientX;
                
                // Calculate total movement for tap detection
                const movementX = currentX - this.tapStartPos.x;
                const movementY = currentY - this.tapStartPos.y;
                this.totalMovement = Math.sqrt(movementX * movementX + movementY * movementY);
                
                // Only start visual dragging after minimum movement threshold
                if (this.totalMovement >= this.minDragDistance) {
                    this.updateDrag(currentY);
                    e.preventDefault();
                }
            }
        }, { passive: false });
        
        document.addEventListener('touchend', () => {
            if (this.isDraggingHandle) {
                // Determine if this was a tap or drag
                if (this.totalMovement < this.tapThreshold) {
                    // This was a tap - toggle state
                    this.isDraggingHandle = false;
                    sheet.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                    sheet.style.transform = '';
                    
                    if (this.isExpanded) {
                        this.collapse();
                    } else {
                        this.expand();
                    }
                } else {
                    // This was a drag - use normal end logic
                    this.endDrag();
                }
            }
        });
        
        handle.addEventListener('mousedown', (e) => {
            this.startDrag(e.clientY);
            this.tapStartPos.x = e.clientX;
            this.tapStartPos.y = e.clientY;
            this.totalMovement = 0;
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (this.isDraggingHandle) {
                const movementX = e.clientX - this.tapStartPos.x;
                const movementY = e.clientY - this.tapStartPos.y;
                this.totalMovement = Math.sqrt(movementX * movementX + movementY * movementY);
                
                if (this.totalMovement >= this.minDragDistance) {
                    this.updateDrag(e.clientY);
                    e.preventDefault();
                }
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (this.isDraggingHandle) {
                if (this.totalMovement < this.tapThreshold) {
                    // Mouse click - toggle state
                    this.isDraggingHandle = false;
                    sheet.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                    sheet.style.transform = '';
                    
                    if (this.isExpanded) {
                        this.collapse();
                    } else {
                        this.expand();
                    }
                } else {
                    this.endDrag();
                }
            }
        });
    }
    
    startDrag(clientY) {
        this.isDraggingHandle = true;
        this.dragStartY = clientY;
        
        const sheet = this.elements.bottomSheet;
        const style = window.getComputedStyle(sheet);
        const transform = style.transform;
        
        if (transform !== 'none') {
            const matrix = new DOMMatrix(transform);
            this.initialTransform = matrix.m42;
        } else {
            this.initialTransform = 0;
        }
        
        Utils.haptic();
    }
    
    updateDrag(clientY) {
        if (!this.isDraggingHandle) return;
        
        const deltaY = clientY - this.dragStartY;
        const sheet = this.elements.bottomSheet;
        
        let newTransform = this.initialTransform + deltaY;
        
        const sheetHeight = sheet.offsetHeight;
        const maxCollapsed = sheetHeight - 40;
        const maxExpanded = 0;
        
        newTransform = Math.max(maxExpanded, Math.min(maxCollapsed, newTransform));
        
        sheet.style.transform = `translateY(${newTransform}px)`;
    }
    
    endDrag() {
        if (!this.isDraggingHandle) return;
        
        this.isDraggingHandle = false;
        const sheet = this.elements.bottomSheet;
        
        const style = window.getComputedStyle(sheet);
        const transform = style.transform;
        let currentY = 0;
        
        if (transform !== 'none') {
            const matrix = new DOMMatrix(transform);
            currentY = matrix.m42;
        }
        
        const sheetHeight = sheet.offsetHeight;
        const threshold = sheetHeight * 0.3;
        
        if (currentY > threshold) {
            this.collapse();
        } else {
            this.expand();
        }
    }
    
    expand() {
        this.isExpanded = true;
        if (this.elements.bottomSheet) {
            this.elements.bottomSheet.classList.add('is-expanded');
            this.elements.bottomSheet.style.transform = '';
        }
        Utils.haptic();
    }
    
    collapse() {
        this.isExpanded = false;
        if (this.elements.bottomSheet) {
            this.elements.bottomSheet.classList.remove('is-expanded');
            this.elements.bottomSheet.style.transform = '';
        }
        Utils.haptic();
    }
    
    updateUI() {
        if (this.elements.panelTitle) {
            this.elements.panelTitle.textContent = CONFIG.panelNames[this.currentPanel];
        }
        
        this.elements.navSegments.forEach((segment, index) => {
            segment.classList.toggle('is-active', index === this.currentPanel);
        });
    }
    
    goToPanel(index) {
        this.scrollToPanel(index);
    }
}

// ====================================================================
// INTERACTION MANAGER
// ====================================================================
class InteractionManager {
    constructor(canvas, uiController) {
        this.canvas = canvas;
        this.ui = uiController;
        
        this.isDragging = false;
        this.dragPoint = null;
        this.startPos = { x: 0, y: 0 };
        this.longPressTimer = null;
        this.isLongPressing = false;
        this.inDeletionZone = false;
        this.deletionTimer = null;
        this.deletionDuration = 500;
        
        this.lastTapTime = 0;
        this.lastTapPos = { x: 0, y: 0 };
        this.doubleTapWindow = 300;
        this.doubleTapTolerance = 10;
        
        this.indicator = document.querySelector('[data-indicator="long-press"]');
        this.deletionZones = {
            top: document.querySelector('[data-deletion="top"]'),
            bottom: document.querySelector('[data-deletion="bottom"]'),
            left: document.querySelector('[data-deletion="left"]'),
            right: document.querySelector('[data-deletion="right"]')
        };
        
        // Zoom gesture state
        this.isZooming = false;
        this.lastPinchDistance = 0;
        this.zoomSensitivity = 0.5;
        
        // Wavelength edit mode state
        this.isEditMode = false;
        this.editModePoint = null;
        this.slowDoubleTapWindow = 800; // Longer window for edit mode activation
        
        this.setupEvents();
    }
    
    setupEvents() {
        const options = { passive: false };
        this.canvas.addEventListener('touchstart', e => this.handleStart(e, e.touches[0]), options);
        this.canvas.addEventListener('touchmove', e => this.handleMove(e, e.touches[0]), options);
        this.canvas.addEventListener('touchend', e => this.handleEnd(e), options);
        this.canvas.addEventListener('mousedown', e => this.handleStart(e, e), options);
        this.canvas.addEventListener('mousemove', e => this.handleMove(e, e), options);
        this.canvas.addEventListener('mouseup', e => this.handleEnd(e), options);
        this.canvas.addEventListener('contextmenu', e => e.preventDefault());
        
        // Zoom gesture events
        this.canvas.addEventListener('wheel', e => this.handleWheel(e), options);
        this.canvas.addEventListener('touchstart', e => this.handleTouchStart(e), options);
        this.canvas.addEventListener('touchmove', e => this.handleTouchMove(e), options);
        this.canvas.addEventListener('touchend', e => this.handleTouchEnd(e), options);
    }
    
    getCoordinates(pointer) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        
        return {
            x: Math.floor((pointer.clientX - rect.left) * scaleX),
            y: Math.floor((pointer.clientY - rect.top) * scaleY)
        };
    }
    
    handleStart(event, pointer) {
        event.preventDefault();
        const coords = this.getCoordinates(pointer);
        this.startPos = coords;
        
        const hitPoint = this.ui.engine.findPointAt(coords.x, coords.y);
        const currentTime = performance.now();
        
        if (this.isDoubleTap(coords, currentTime)) {
            if (hitPoint) {
                this.handleDoubleTap(hitPoint, coords);
            } else {
                this.handleEmptyCanvasDoubleTap(coords);
            }
            return;
        }
        
        // Check for slow double-tap (edit mode activation)
        if (hitPoint && this.lastTapTime > 0) {
            const timeDiff = currentTime - this.lastTapTime;
            const distance = Utils.distance(coords.x, coords.y, this.lastTapPos.x, this.lastTapPos.y);
            
            if (timeDiff > this.doubleTapWindow && 
                timeDiff < this.slowDoubleTapWindow && 
                distance < this.doubleTapTolerance &&
                hitPoint.id === this.ui.selectedPointId) {
                
                this.enterEditMode(hitPoint);
                this.lastTapTime = 0;
                this.lastTapPos = { x: 0, y: 0 };
                return;
            }
        }
        
        this.lastTapTime = currentTime;
        this.lastTapPos = { x: coords.x, y: coords.y };
        
        if (hitPoint) {
            this.ui.selectPoint(hitPoint.id);
            this.isDragging = true;
            this.dragPoint = hitPoint;
            this.canvas.style.cursor = 'grabbing';
        } else {
            this.startLongPress(coords.x, coords.y);
            this.exitEditMode(); // Exit edit mode when tapping empty canvas
            
            if (this.ui.bottomSheet.isExpanded) {
                this.ui.bottomSheet.collapse();
                this.ui.deselectAll();
            } else {
                this.ui.deselectAll();
            }
        }
    }
    
    handleMove(event, pointer) {
        const coords = this.getCoordinates(pointer);
        const dist = Utils.distance(coords.x, coords.y, this.startPos.x, this.startPos.y);
        
        if (dist > 10) {
            this.cancelLongPress();
        }
        
        if (this.isDragging && this.dragPoint) {
            event.preventDefault();
            if (dist > 5) {
                let finalX = coords.x;
                let finalY = coords.y;
                
                if (this.ui.animationManager.showGrid) {
                    const gridSpacing = this.ui.renderer.skipFactor * 10;
                    const snapped = Utils.snapToGrid(coords.x, coords.y, gridSpacing);
                    finalX = snapped.x;
                    finalY = snapped.y;
                }
                
                const deletionMargin = 50;
                const inDeletionZone = (
                    finalX < deletionMargin || 
                    finalX > this.canvas.width - deletionMargin ||
                    finalY < deletionMargin || 
                    finalY > this.canvas.height - deletionMargin
                );
                
                if (inDeletionZone !== this.inDeletionZone) {
                    this.inDeletionZone = inDeletionZone;
                    this.updateDeletionZoneVisuals(inDeletionZone);
                    
                    if (inDeletionZone && !this.deletionTimer) {
                        this.startDeletionTimer();
                    }
                    
                    if (!inDeletionZone && this.deletionTimer) {
                        this.cancelDeletionTimer();
                    }
                }
                
                this.dragPoint.inDeletionZone = inDeletionZone;
                
                this.dragPoint.x = finalX;
                this.dragPoint.y = finalY;
                this.ui.animationManager.forceRender();
            }
        }
    }
    
    handleEnd(event) {
        if (this.isDragging) {
            event.preventDefault();
            
            this.cancelDeletionTimer();
            
            if (this.dragPoint) {
                this.dragPoint.inDeletionZone = false;
            }
            
            this.isDragging = false;
            this.dragPoint = null;
            this.canvas.style.cursor = '';
            
            this.updateDeletionZoneVisuals(false);
            this.inDeletionZone = false;
        }
        this.cancelLongPress();
    }
    
    startLongPress(x, y) {
        this.isLongPressing = true;
        
        if (this.indicator) {
            this.indicator.style.left = `${x}px`;
            this.indicator.style.top = `${y}px`;
            this.indicator.classList.add('is-active');
            this.indicator.classList.remove('is-complete');
        }
        
        this.longPressTimer = setTimeout(() => {
            if (this.isLongPressing) {
                this.completeLongPress(x, y);
            }
        }, CONFIG.longPressDuration);
    }
    
    completeLongPress(x, y) {
        Utils.haptic();
        
        if (this.indicator) {
            this.indicator.classList.remove('is-active');
            this.indicator.classList.add('is-complete');
            
            // Hide the indicator after a brief moment
            setTimeout(() => {
                if (this.indicator) {
                    this.indicator.classList.remove('is-complete');
                }
            }, 200);
        }
        
        let finalX = x, finalY = y;
        if (this.ui.animationManager.showGrid) {
            const gridSpacing = this.ui.renderer.skipFactor * 10;
            const snapped = Utils.snapToGrid(x, y, gridSpacing);
            finalX = snapped.x;
            finalY = snapped.y;
        }
        
        this.ui.addPoint(finalX, finalY);
        this.cancelLongPress();
    }
    
    cancelLongPress() {
        if (this.longPressTimer) {
            clearTimeout(this.longPressTimer);
            this.longPressTimer = null;
        }
        this.isLongPressing = false;
        
        if (this.indicator) {
            this.indicator.classList.remove('is-active', 'is-complete');
        }
    }
    
    updateDeletionZoneVisuals(active) {
        Object.values(this.deletionZones).forEach(zone => {
            if (zone) {
                zone.classList.toggle('is-active', active);
            }
        });
    }
    
    startDeletionTimer() {
        if (this.deletionTimer) return;
        
        this.deletionTimer = setTimeout(() => {
            if (this.dragPoint && this.isDragging) {
                Utils.haptic();
                this.ui.removePoint(this.dragPoint.id);
                
                this.isDragging = false;
                this.dragPoint = null;
                this.canvas.style.cursor = '';
                this.updateDeletionZoneVisuals(false);
                this.inDeletionZone = false;
            }
            this.deletionTimer = null;
        }, this.deletionDuration);
        
        if (this.dragPoint) {
            this.dragPoint.deletionTimer = performance.now();
        }
    }
    
    cancelDeletionTimer() {
        if (this.deletionTimer) {
            clearTimeout(this.deletionTimer);
            this.deletionTimer = null;
        }
        
        if (this.dragPoint) {
            this.dragPoint.deletionTimer = null;
        }
    }
    
    isDoubleTap(coords, currentTime) {
        const timeDiff = currentTime - this.lastTapTime;
        const distance = Utils.distance(coords.x, coords.y, this.lastTapPos.x, this.lastTapPos.y);
        
        return timeDiff < this.doubleTapWindow && distance < this.doubleTapTolerance;
    }
    
    handleDoubleTap(point, coords) {
        Utils.haptic();
        
        this.ui.selectPoint(point.id);
        this.ui.clonePoint();
        
        this.lastTapTime = 0;
        this.lastTapPos = { x: 0, y: 0 };
    }
    
    // Zoom gesture handlers
    handleWheel(event) {
        // Only handle Ctrl + scroll wheel for wavelength adjustment in edit mode
        if (!event.ctrlKey || !this.isEditMode || !this.editModePoint) return;
        
        event.preventDefault();
        
        // Scroll down = increase wavelength, scroll up = decrease wavelength
        const delta = event.deltaY > 0 ? 1 : -1;
        const change = delta * 5; // 5 units per scroll step
        
        this.adjustWavelength(this.editModePoint, change);
    }
    
    handleTouchStart(event) {
        if (event.touches.length === 2 && this.isEditMode && this.editModePoint) {
            this.isZooming = true;
            this.lastPinchDistance = this.getTouchDistance(event.touches[0], event.touches[1]);
        }
    }
    
    handleTouchMove(event) {
        if (!this.isZooming || event.touches.length !== 2 || !this.isEditMode || !this.editModePoint) return;
        
        event.preventDefault();
        
        const currentDistance = this.getTouchDistance(event.touches[0], event.touches[1]);
        const deltaDistance = currentDistance - this.lastPinchDistance;
        
        // Pinch out = increase wavelength, pinch in = decrease wavelength
        const change = deltaDistance * this.zoomSensitivity;
        
        this.adjustWavelength(this.editModePoint, change);
        this.lastPinchDistance = currentDistance;
    }
    
    handleTouchEnd(event) {
        if (event.touches.length < 2) {
            this.isZooming = false;
            this.lastPinchDistance = 0;
            
            // Exit edit mode when all touches are lifted
            if (event.touches.length === 0 && this.isEditMode) {
                this.exitEditMode();
            }
        }
    }
    
    enterEditMode(point) {
        this.isEditMode = true;
        this.editModePoint = point;
        Utils.haptic();
        this.ui.animationManager.forceRender();
        
        // Listen for Ctrl key release
        document.addEventListener('keyup', this.handleKeyUp);
    }
    
    exitEditMode() {
        if (!this.isEditMode) return;
        
        this.isEditMode = false;
        this.editModePoint = null;
        this.isZooming = false;
        this.lastPinchDistance = 0;
        this.ui.animationManager.forceRender();
        
        // Remove Ctrl key listener
        document.removeEventListener('keyup', this.handleKeyUp);
    }
    
    handleKeyUp = (event) => {
        if (event.key === 'Control' && this.isEditMode) {
            this.exitEditMode();
        }
    }
    
    getTouchDistance(touch1, touch2) {
        const dx = touch2.clientX - touch1.clientX;
        const dy = touch2.clientY - touch1.clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    adjustWavelength(point, change) {
        const newWavelength = Utils.clamp(
            point.wavelength + change,
            CONFIG.ranges.wavelength.min,
            CONFIG.ranges.wavelength.max
        );
        
        point.wavelength = newWavelength;
        
        // Update UI controls to reflect the change
        this.ui.inputController.updatePair(
            '[data-slider="point-wavelength"]',
            '[data-input="point-wavelength"]',
            newWavelength
        );
        
        // Force immediate re-render to show wavelength change
        this.ui.animationManager.forceRender();
    }
    
    handleEmptyCanvasDoubleTap(coords) {
        Utils.haptic();
        
        this.ui.toggleFullscreen();
        
        this.lastTapTime = 0;
        this.lastTapPos = { x: 0, y: 0 };
    }
}

// ====================================================================
// UI CONTROLLER
// ====================================================================
class UIController {
    constructor(engine, animationManager, renderer) {
        this.engine = engine;
        this.animationManager = animationManager;
        this.renderer = renderer;
        this.selectedPointId = null;
        this.singleEditMode = false;
        this.isFullscreen = false;
        this.bottomSheet = new BottomSheetController();
        this.inputController = new InputController();
        this.interactionManager = null; // Will be set by WaveSimulation
        
        this.setupEventListeners();
        this.setupInputControls();
        this.initializeToggles();
        this.updatePerformanceInfo();
        this.updatePointsUI();
    }
    
    setupEventListeners() {
        // Modal management
        const welcomeStartBtn = document.querySelector('[data-modal-action="start"]');
        const healthBackBtn = document.querySelector('[data-modal-action="back"]');
        const healthContinueBtn = document.querySelector('[data-modal-action="continue"]');
        const helpBtn = document.querySelector('[data-action="help"]');
        const helpCloseBtn = document.querySelector('[data-modal-action="close"]');
        const addBtn = document.querySelector('[data-action="add"]');
        
        if (welcomeStartBtn) welcomeStartBtn.addEventListener('click', () => this.showHealthWarning());
        if (healthBackBtn) healthBackBtn.addEventListener('click', () => this.showWelcome());
        if (healthContinueBtn) healthContinueBtn.addEventListener('click', () => this.startApp());
        if (helpBtn) helpBtn.addEventListener('click', () => this.showHelp());
        if (helpCloseBtn) helpCloseBtn.addEventListener('click', () => this.hideHelp());
        if (addBtn) addBtn.addEventListener('click', () => this.contextualAdd());
        
        // Control buttons
        const clearBtn = document.querySelector('[data-action="clear"]');
        const syncBtn = document.querySelector('[data-action="sync"]');
        const showPointsToggle = document.querySelector('[data-toggle="show-points"]');
        const showGridToggle = document.querySelector('[data-toggle="show-grid"]');
        const generatePatternBtn = document.querySelector('[data-action="generate-pattern"]');
        const colorToggle = document.querySelector('[data-toggle="color-mode"]');
        const singleEditMode = document.querySelector('[data-checkbox="single-edit-mode"]');
        
        if (clearBtn) clearBtn.addEventListener('click', () => this.contextualClear());
        if (syncBtn) syncBtn.addEventListener('click', () => this.syncPoints());
        if (showPointsToggle) showPointsToggle.addEventListener('click', () => this.toggleShowPoints());
        if (showGridToggle) showGridToggle.addEventListener('click', () => this.toggleShowGrid());
        if (generatePatternBtn) generatePatternBtn.addEventListener('click', () => this.generatePattern());
        if (colorToggle) colorToggle.addEventListener('click', () => this.toggleColorMode());
        if (singleEditMode) singleEditMode.addEventListener('change', (e) => this.setSingleEditMode(e.target.checked));
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => this.handleKeyboard(e));
        
        // Window events
        window.addEventListener('resize', () => {
            this.renderer.resize();
            this.updatePerformanceInfo();
        });
    }
    
    // Context-sensitive button actions
    contextualClear() {
        if (this.selectedPointId) {
            this.deletePoint();
        } else {
            this.clearAll();
        }
    }
    
    contextualAdd() {
        if (this.selectedPointId) {
            this.clonePoint();
        } else {
            this.createRandomPoint();
        }
    }
    
    setupInputControls() {
        // Point property sliders
        this.inputController.registerSliderPair('[data-slider="point-amplitude"]', '[data-input="point-amplitude"]', 
            (v) => this.updatePointProperty('amplitude', parseInt(v)));
        this.inputController.registerSliderPair('[data-slider="point-wavelength"]', '[data-input="point-wavelength"]', 
            (v) => this.updatePointProperty('wavelength', parseInt(v)));
        this.inputController.registerSliderPair('[data-slider="point-speed"]', '[data-input="point-speed"]', 
            (v) => this.updatePointProperty('speed', parseFloat(v)));
        
        // Color sliders
        this.inputController.registerSliderPair('[data-slider="hue1"]', '[data-input="hue1"]', (v) => {
            this.engine.hue1 = parseInt(v);
            this.updateColorPreview();
            this.animationManager.forceRender();
        });
        this.inputController.registerSliderPair('[data-slider="hue2"]', '[data-input="hue2"]', (v) => {
            this.engine.hue2 = parseInt(v);
            this.updateColorPreview();
            this.animationManager.forceRender();
        });
        
        // Medium controls
        this.inputController.registerSliderPair('[data-slider="time-multiplier"]', '[data-input="time-multiplier"]', (v) => {
            this.engine.setTimeMultiplier(parseFloat(v));
        });
        this.inputController.registerSliderPair('[data-slider="point-phase-offset"]', '[data-input="point-phase-offset"]', (v) => {
            this.engine.setPointPhaseOffset(parseFloat(v) * Math.PI);
        });
        this.inputController.registerSliderPair('[data-slider="damping"]', '[data-input="damping"]', (v) => {
            this.engine.setDamping(parseFloat(v));
        });
        this.inputController.registerSliderPair('[data-slider="performance"]', '[data-input="performance"]', (v) => {
            this.setPerformanceLevel(parseInt(v));
        });
        
        // Pattern generator sliders
        this.inputController.registerSliderPair('[data-slider="pattern-count"]', '[data-input="pattern-count"]', () => {});
        this.inputController.registerSliderPair('[data-slider="pattern-scale"]', '[data-input="pattern-scale"]', () => {});
        
        this.initializeInputDisplays();
    }
    
    // Modal methods
    showWelcome() {
        const welcomeModal = document.querySelector('[data-modal="welcome"]');
        const healthWarningModal = document.querySelector('[data-modal="health-warning"]');
        if (welcomeModal) welcomeModal.style.display = 'flex';
        if (healthWarningModal) healthWarningModal.style.display = 'none';
    }
    
    showHealthWarning() {
        const welcomeModal = document.querySelector('[data-modal="welcome"]');
        const healthWarningModal = document.querySelector('[data-modal="health-warning"]');
        if (welcomeModal) welcomeModal.style.display = 'none';
        if (healthWarningModal) healthWarningModal.style.display = 'flex';
    }
    
    startApp() {
        const healthWarningModal = document.querySelector('[data-modal="health-warning"]');
        if (healthWarningModal) healthWarningModal.style.display = 'none';
        this.createStarterPoint();
    }
    
    showHelp() {
        const helpModal = document.querySelector('[data-modal="help"]');
        if (helpModal) helpModal.style.display = 'flex';
    }
    
    hideHelp() {
        const helpModal = document.querySelector('[data-modal="help"]');
        if (helpModal) helpModal.style.display = 'none';
    }
    
    // Point management
    selectPoint(id) {
        if (this.selectedPointId) {
            const prevPoint = this.engine.getPoint(this.selectedPointId);
            if (prevPoint) prevPoint.selected = false;
        }
        
        // Exit edit mode when selecting a different point
        if (this.selectedPointId !== id) {
            this.interactionManager.exitEditMode();
        }
        
        this.selectedPointId = id;
        const point = this.engine.getPoint(id);
        if (point) {
            point.selected = true;
        }
        
        this.singleEditMode = true;
        const singleEditModeEl = document.querySelector('[data-checkbox="single-edit-mode"]');
        if (singleEditModeEl) singleEditModeEl.checked = true;
        
        this.updatePointPropertiesUI();
        this.updatePointsUI();
        this.animationManager.setSelectedPoint(point);
    }
    
    deselectAll() {
        if (this.selectedPointId) {
            const point = this.engine.getPoint(this.selectedPointId);
            if (point) point.selected = false;
        }
        
        // Exit edit mode when deselecting
        this.interactionManager.exitEditMode();
        
        this.selectedPointId = null;
        this.singleEditMode = false;
        const singleEditModeEl = document.querySelector('[data-checkbox="single-edit-mode"]');
        if (singleEditModeEl) singleEditModeEl.checked = false;
        this.updatePointPropertiesUI();
        this.updatePointsUI();
        this.animationManager.setSelectedPoint(null);
    }
    
    getSelectedPoint() {
        return this.selectedPointId ? this.engine.getPoint(this.selectedPointId) : null;
    }
    
    // Action methods
    clearAll() {
        this.engine.clearAll();
        this.selectedPointId = null;
        this.singleEditMode = false;
        const singleEditModeEl = document.querySelector('[data-checkbox="single-edit-mode"]');
        if (singleEditModeEl) singleEditModeEl.checked = false;
        this.animationManager.stop();
        this.animationManager.setShowPoints(false);
        this.animationManager.setShowGrid(false);
        this.animationManager.setSelectedPoint(null);
        this.updatePointsUI();
        this.updatePointPropertiesUI();
        this.updateDisplayToggle('[data-toggle="show-points"]', false);
        this.updateDisplayToggle('[data-toggle="show-grid"]', false);
        this.animationManager.forceRender();
    }
    
    createStarterPoint() {
        const cx = Math.floor(window.innerWidth / 2);
        const cy = Math.floor(window.innerHeight / 2);
        const point = this.engine.addPoint(cx, cy);
        if (point) {
            this.selectPoint(point.id);
            this.animationManager.start();
            this.updatePointsUI();
        }
    }
    
    createRandomPoint() {
        const bounds = { width: window.innerWidth, height: window.innerHeight };
        const pos = PatternGenerator.findRandomPosition(this.engine.getAllPoints(), bounds);
        const point = this.addPoint(pos.x, pos.y);
    }
    
    addPoint(x, y, properties = {}) {
        const point = this.engine.addPoint(x, y, properties);
        if (point) {
            this.selectPoint(point.id);
            if (!this.animationManager.isAnimating) {
                this.animationManager.start();
            }
        }
        
        this.updatePointsUI();
        Utils.haptic();
        return point;
    }
    
    clonePoint() {
        const selectedPoint = this.getSelectedPoint();
        if (!selectedPoint) return;
        
        const bounds = { width: window.innerWidth, height: window.innerHeight };
        const pos = PatternGenerator.findRandomPosition(this.engine.getAllPoints(), bounds);
        
        let finalX = pos.x, finalY = pos.y;
        if (this.animationManager.showGrid) {
            const gridSpacing = this.renderer.skipFactor * 10;
            const snapped = Utils.snapToGrid(pos.x, pos.y, gridSpacing);
            finalX = snapped.x;
            finalY = snapped.y;
        }
        
        const clone = this.engine.addPoint(finalX, finalY, {
            ...selectedPoint.getProperties(),
            creationIndex: this.engine.creationCounter++,
            phaseOffset: this.engine.pointPhaseOffset * (this.engine.creationCounter - 1)
        });
        
        if (clone) {
            clone.startTime = this.engine.time;
            this.selectPoint(clone.id);
            
            if (!this.animationManager.isAnimating) {
                this.animationManager.start();
            }
        }
        
        this.updatePointsUI();
        Utils.haptic();
    }
    
    deletePoint() {
        const selectedPoint = this.getSelectedPoint();
        if (selectedPoint) {
            this.removePoint(selectedPoint.id);
        }
    }
    
    removePoint(id) {
        if (this.selectedPointId === id) {
            this.selectedPointId = null;
        }
        this.engine.removePoint(id);
        this.updatePointsUI();
        this.updatePointPropertiesUI();
        this.animationManager.setSelectedPoint(null);
        
        if (this.engine.points.size === 0) {
            this.animationManager.stop();
        }
    }
    
    updatePointProperty(property, value) {
        if (this.singleEditMode) {
            const selectedPoint = this.getSelectedPoint();
            if (selectedPoint) {
                selectedPoint[property] = value;
                this.updatePointsUI();
            }
        } else {
            for (const point of this.engine.getAllPoints()) {
                point[property] = value;
            }
            this.updatePointsUI();
        }
    }
    
    syncPoints() {
        if (this.engine.points.size === 0) return;
        
        this.engine.syncPoints();
        this.inputController.updatePair('[data-slider="point-phase-offset"]', '[data-input="point-phase-offset"]', 0);
        
        if (!this.animationManager.isAnimating) {
            this.animationManager.start();
        }
        
        this.animationManager.forceRender();
    }
    
    toggleShowPoints() {
        const newState = !this.animationManager.showPoints;
        this.animationManager.setShowPoints(newState);
        this.updateDisplayToggle('[data-toggle="show-points"]', newState);
    }
    
    toggleShowGrid() {
        const newState = !this.animationManager.showGrid;
        this.animationManager.setShowGrid(newState);
        this.updateDisplayToggle('[data-toggle="show-grid"]', newState);
    }
    
    toggleColorMode() {
        const newState = !this.engine.useColor;
        this.engine.setColorMode(newState);
        this.updateButton('[data-toggle="color-mode"]', newState);
        this.updateColorControls();
        this.animationManager.forceRender();
    }
    
    updateColorPreview() {
        const preview = document.querySelector('[data-preview="gradient"]');
        if (preview) {
            preview.style.background = `linear-gradient(to right, hsl(${this.engine.hue1}, 70%, 50%), hsl(${this.engine.hue2}, 70%, 50%))`;
        }
    }
    
    setPerformanceLevel(level) {
        this.renderer.setPerformanceLevel(level);
        this.updatePerformanceInfo();
    }
    
    handleKeyboard(e) {
        if (e.key === 'Escape' && this.bottomSheet.isExpanded) {
            this.bottomSheet.collapse();
        }
        
        const selectedPoint = this.getSelectedPoint();
        if (selectedPoint) {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                e.preventDefault();
                this.deletePoint();
            } else if (e.key === 'c' || e.key === 'C') {
                e.preventDefault();
                this.clonePoint();
            }
        }
    }
    
    // UI update methods
    updateButton(selector, isActive, activeText = null, inactiveText = null) {
        const element = document.querySelector(selector);
        if (!element) return;
        
        element.classList.toggle('is-active', isActive);
        if (activeText && inactiveText) {
            element.textContent = isActive ? activeText : inactiveText;
        }
    }
    
    updateDisplayToggle(selector, isActive) {
        const element = document.querySelector(selector);
        if (!element) return;
        
        const miniToggle = element.querySelector('.mini-toggle');
        if (miniToggle) {
            miniToggle.classList.toggle('is-active', isActive);
        }
    }
    
    updateColorControls() {
        const controls = ['[data-color-controls="minima"]', '[data-color-controls="maxima"]', '[data-color-controls="preview"]'];
        controls.forEach(selector => {
            const element = document.querySelector(selector);
            if (element) element.style.display = this.engine.useColor ? 'block' : 'none';
        });
        
        if (this.engine.useColor) {
            this.updateColorPreview();
        }
    }
    
    updatePointsUI() {
        // Points count and performance stats no longer displayed
        // All point information now managed through other UI elements
    }
    
    updatePointPropertiesUI() {
        const selectedPoint = this.getSelectedPoint();
        const allPoints = this.engine.getAllPoints();
        
        const editModeContainer = document.querySelector('[data-edit-mode="container"]');
        const selectedPointInfo = document.querySelector('[data-selected-point="info"]');
        const selectedPointId = document.querySelector('[data-selected-point="id"]');
        
        if (selectedPoint) {
            if (editModeContainer) editModeContainer.style.display = 'block';
            if (selectedPointInfo) selectedPointInfo.style.display = 'block';
            if (selectedPointId) selectedPointId.textContent = selectedPoint.getDisplayName();
        } else {
            if (editModeContainer) editModeContainer.style.display = 'none';
            if (selectedPointInfo) selectedPointInfo.style.display = 'none';
        }
        
        if (allPoints.length === 0) {
            this.inputController.updatePair('[data-slider="point-amplitude"]', '[data-input="point-amplitude"]', CONFIG.defaults.amplitude);
            this.inputController.updatePair('[data-slider="point-wavelength"]', '[data-input="point-wavelength"]', CONFIG.defaults.wavelength);
            this.inputController.updatePair('[data-slider="point-speed"]', '[data-input="point-speed"]', CONFIG.defaults.speed);
        } else if (this.singleEditMode && selectedPoint) {
            this.inputController.updatePair('[data-slider="point-amplitude"]', '[data-input="point-amplitude"]', selectedPoint.amplitude);
            this.inputController.updatePair('[data-slider="point-wavelength"]', '[data-input="point-wavelength"]', selectedPoint.wavelength);
            this.inputController.updatePair('[data-slider="point-speed"]', '[data-input="point-speed"]', selectedPoint.speed);
        } else {
            const avgAmplitude = Math.round(allPoints.reduce((sum, p) => sum + p.amplitude, 0) / allPoints.length);
            const avgWavelength = Math.round(allPoints.reduce((sum, p) => sum + p.wavelength, 0) / allPoints.length);
            const avgSpeed = allPoints.reduce((sum, p) => sum + p.speed, 0) / allPoints.length;
            
            this.inputController.updatePair('[data-slider="point-amplitude"]', '[data-input="point-amplitude"]', avgAmplitude);
            this.inputController.updatePair('[data-slider="point-wavelength"]', '[data-input="point-wavelength"]', avgWavelength);
            this.inputController.updatePair('[data-slider="point-speed"]', '[data-input="point-speed"]', avgSpeed);
        }
    }
    
    updatePerformanceInfo() {
        // Performance info no longer displayed in UI
    }
    
    setSingleEditMode(enabled) {
        this.singleEditMode = enabled;
        this.updatePointPropertiesUI();
    }
    
    // Fullscreen Mode Methods
    toggleFullscreen() {
        this.isFullscreen = !this.isFullscreen;
        document.body.classList.toggle('fullscreen-mode', this.isFullscreen);
        
        if (this.isFullscreen) {
            this.bottomSheet.collapse();
        }
        
        Utils.haptic();
        console.log(this.isFullscreen ? 'Entered fullscreen mode' : 'Exited fullscreen mode');
    }
    
    enterFullscreen() {
        if (!this.isFullscreen) {
            this.toggleFullscreen();
        }
    }
    
    exitFullscreen() {
        if (this.isFullscreen) {
            this.toggleFullscreen();
        }
    }
    
    initializeToggles() {
        this.updateButton('[data-toggle="color-mode"]', false);
        this.updateColorControls();
        this.updateDisplayToggle('[data-toggle="show-points"]', false);
        this.updateDisplayToggle('[data-toggle="show-grid"]', false);
    }
    
    initializeInputDisplays() {
        const sliderPairs = [
            ['[data-slider="point-amplitude"]', '[data-input="point-amplitude"]'],
            ['[data-slider="point-wavelength"]', '[data-input="point-wavelength"]'],
            ['[data-slider="point-speed"]', '[data-input="point-speed"]'],
            ['[data-slider="hue1"]', '[data-input="hue1"]'],
            ['[data-slider="hue2"]', '[data-input="hue2"]'],
            ['[data-slider="time-multiplier"]', '[data-input="time-multiplier"]'],
            ['[data-slider="point-phase-offset"]', '[data-input="point-phase-offset"]'],
            ['[data-slider="damping"]', '[data-input="damping"]'],
            ['[data-slider="performance"]', '[data-input="performance"]'],
            ['[data-slider="pattern-count"]', '[data-input="pattern-count"]'],
            ['[data-slider="pattern-scale"]', '[data-input="pattern-scale"]']
        ];
        
        sliderPairs.forEach(([sliderSelector, inputSelector]) => {
            const slider = document.querySelector(sliderSelector);
            const input = document.querySelector(inputSelector);
            if (slider && input) {
                const fieldType = this.inputController.getFieldType(sliderSelector);
                const value = parseFloat(slider.value);
                input.value = Utils.formatInputValue(value, fieldType);
            }
        });
        
        this.updatePointPropertiesUI();
    }
    
    generatePattern() {
        const type = document.querySelector('[data-select="pattern-type"]').value;
        const count = parseInt(document.querySelector('[data-slider="pattern-count"]').value);
        const scale = parseFloat(document.querySelector('[data-slider="pattern-scale"]').value);
        
        const currentCount = this.engine.points.size;
        const availableSlots = CONFIG.maxPoints - currentCount;
        
        if (availableSlots <= 0) {
            Utils.haptic();
            return;
        }
        
        const actualCount = Math.min(count, availableSlots);
        const bounds = { width: window.innerWidth, height: window.innerHeight };
        const positions = PatternGenerator.generate(type, actualCount, bounds, scale);
        
        let firstNewPoint = null;
        positions.forEach((pos, index) => {
            let finalX = pos.x, finalY = pos.y;
            if (this.animationManager.showGrid) {
                const gridSpacing = this.renderer.skipFactor * 10;
                const snapped = Utils.snapToGrid(pos.x, pos.y, gridSpacing);
                finalX = snapped.x;
                finalY = snapped.y;
            }
            
            const point = this.engine.addPoint(finalX, finalY, {
                creationIndex: this.engine.creationCounter++,
                phaseOffset: this.engine.pointPhaseOffset * (this.engine.creationCounter - 1)
            });
            if (point) {
                point.startTime = this.engine.time - (index * 0.1);
                if (!firstNewPoint) firstNewPoint = point;
            }
        });
        
        if (firstNewPoint) {
            this.selectPoint(firstNewPoint.id);
            this.animationManager.setShowPoints(true);
            this.updateButton('[data-toggle="show-points"]', true);
            if (!this.animationManager.isAnimating) {
                this.animationManager.start();
            }
        }
        
        this.updatePointsUI();
        Utils.haptic();
    }
}

// ====================================================================
// MAIN WAVE SIMULATION CLASS
// ====================================================================
class WaveSimulation {
    constructor() {
        this.canvas = document.querySelector('[data-canvas="main"]');
        
        this.engine = new WaveEngine();
        this.renderer = new Renderer(this.canvas);
        this.animationManager = new AnimationManager(this.renderer, this.engine);
        this.uiController = new UIController(this.engine, this.animationManager, this.renderer);
        this.interactionManager = new InteractionManager(this.canvas, this.uiController);
        
        // Set up cross-references
        this.uiController.interactionManager = this.interactionManager;
        
        window.app = this;
        
        console.log('Wave simulation initialized - Minimal version');
        console.log('- Removed all visual polish and animations');
        console.log('- Preserved complete wave physics functionality');
        console.log('- Clean, fast, accessible interface');
        console.log('- Wavelength edit mode: slow double-tap to enter, zoom gestures to adjust');
    }
}

// ====================================================================
// INITIALIZATION
// ====================================================================
document.addEventListener('DOMContentLoaded', () => {
    try {
        new WaveSimulation();
    } catch (error) {
        console.error('Failed to initialize wave simulation:', error);
        document.body.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; height: 100vh; color: white; text-align: center; font-family: monospace;">
                <div>
                    <h2>Wave Simulation Error</h2>
                    <p>Failed to initialize minimal wave interface</p>
                    <p style="font-size: 12px; opacity: 0.7;">Check console for details</p>
                </div>
            </div>
        `;
    }
});
</script>
</body>
</html>
