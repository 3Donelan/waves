<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Wave Simulation - Point Editor</title>
<style>
:root {
    --bg-primary: rgba(20, 20, 20, 0.95);
    --bg-secondary: rgba(255, 255, 255, 0.05);
    --bg-button: rgba(255, 255, 255, 0.1);
    --bg-button-hover: rgba(255, 255, 255, 0.2);
    --bg-button-active: rgba(255, 255, 255, 0.3);
    --color-primary: #00ff88;
    --color-secondary: #0088ff;
    --color-danger: #ff4444;
    --color-warning: #ff9500;
    --text-primary: white;
    --border-primary: rgba(255, 255, 255, 0.1);
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    overflow: hidden;
    background: #000;
}

#canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: #000;
    cursor: crosshair;
    touch-action: none;
}

.visual-indicator {
    position: fixed;
    pointer-events: none;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    opacity: 0;
    z-index: 1000;
}

.long-press-indicator {
    width: 60px;
    height: 60px;
    border: 2px solid rgba(0, 255, 136, 0.6);
}

.long-press-indicator.active {
    animation: longPressGrow 0.5s ease-out forwards;
}

.long-press-indicator.complete {
    animation: fadeOut 0.3s ease-out forwards;
}

.clone-flash {
    width: 80px;
    height: 80px;
    border: 3px solid var(--color-secondary);
    animation: pulseOut 0.5s ease-out;
}

.multi-select-indicator {
    width: 40px;
    height: 40px;
    border: 2px solid var(--color-secondary);
    animation: multiSelectPulse 0.3s ease-out;
}

@keyframes longPressGrow {
    from { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
    to { opacity: 1; transform: translate(-50%, -50%) scale(1.2); border-color: var(--color-primary); box-shadow: 0 0 20px rgba(0, 255, 136, 0.6); }
}

@keyframes fadeOut {
    from { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
    to { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
}

@keyframes pulseOut {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    50% { opacity: 1; }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(2); }
}

@keyframes multiSelectPulse {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
    50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
}

.help-button {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 1000;
    width: 50px;
    height: 50px;
    background: var(--bg-button);
    backdrop-filter: blur(10px);
    border: 1px solid var(--border-primary);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: 0.3s ease;
    color: var(--text-primary);
    font-size: 20px;
    font-weight: 600;
}

.help-button:hover { background: var(--bg-button-hover); }

.menu-toggle {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1000;
    width: 50px;
    height: 50px;
    background: var(--bg-button);
    backdrop-filter: blur(10px);
    border: 1px solid var(--border-primary);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: 0.3s ease;
}

.menu-toggle:hover { background: var(--bg-button-hover); }

.menu-icon {
    width: 24px;
    height: 18px;
    position: relative;
}

.menu-icon span {
    display: block;
    width: 100%;
    height: 2px;
    background: var(--text-primary);
    margin: 4px 0;
    transition: 0.3s ease;
}

.menu-toggle.active .menu-icon span:nth-child(1) { transform: rotate(45deg) translate(5px, 5px); }
.menu-toggle.active .menu-icon span:nth-child(2) { opacity: 0; }
.menu-toggle.active .menu-icon span:nth-child(3) { transform: rotate(-45deg) translate(7px, -6px); }

.control-panel {
    position: fixed;
    top: 0;
    right: -360px;
    width: 360px;
    height: 95vh;
    background: var(--bg-primary);
    backdrop-filter: blur(20px);
    border-left: 1px solid var(--border-primary);
    z-index: 999;
    transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    overflow-y: auto;
    color: var(--text-primary);
}

.control-panel.open { right: 0; }

.panel-header {
    padding: 20px;
    border-bottom: 1px solid var(--border-primary);
}

.panel-title {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 5px;
}

.panel-subtitle {
    font-size: 12px;
    opacity: 0.7;
}

.control-section {
    padding: 20px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.section-title {
    font-size: 14px;
    font-weight: 500;
    margin-bottom: 15px;
    opacity: 0.9;
}

.control-group {
    margin-bottom: 20px;
}

.control-label {
    display: block;
    font-size: 12px;
    margin-bottom: 8px;
    opacity: 0.8;
}

.select-input {
    width: 100%;
    padding: 8px;
    background: var(--bg-button);
    border: 1px solid var(--border-primary);
    border-radius: 6px;
    color: var(--text-primary);
    font-size: 13px;
    cursor: pointer;
    transition: 0.2s ease;
}

.select-input:hover { background: var(--bg-button-hover); }
.select-input:focus { outline: none; border-color: var(--color-primary); }

.slider-container {
    position: relative;
}

.slider {
    width: 100%;
    height: 6px;
    background: var(--bg-button);
    border-radius: 3px;
    outline: none;
    appearance: none;
    -webkit-appearance: none;
}

.slider::-webkit-slider-thumb {
    appearance: none;
    -webkit-appearance: none;
    width: 20px;
    height: 20px;
    background: var(--text-primary);
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: var(--text-primary);
    border-radius: 50%;
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.slider-value {
    position: absolute;
    right: 0;
    top: -25px;
    font-size: 11px;
    background: var(--bg-button);
    padding: 2px 6px;
    border-radius: 3px;
    min-width: 35px;
    text-align: center;
}

.button-group {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.control-button {
    flex: 1;
    min-width: 80px;
    padding: 12px 16px;
    background: var(--bg-button);
    border: 1px solid var(--border-primary);
    border-radius: 8px;
    color: var(--text-primary);
    font-size: 13px;
    cursor: pointer;
    transition: 0.2s ease;
}

.control-button:hover { background: var(--bg-button-hover); }
.control-button:active { transform: scale(0.98); }

.control-button.active {
    background: var(--bg-button-active);
    border-color: rgba(255, 255, 255, 0.5);
}

.control-button.primary {
    background: rgba(0, 255, 136, 0.2);
    border-color: rgba(0, 255, 136, 0.4);
}

.control-button.primary:hover { background: rgba(0, 255, 136, 0.3); }

.control-button.secondary {
    background: rgba(0, 136, 255, 0.2);
    border-color: rgba(0, 136, 255, 0.4);
}

.control-button.secondary:hover { background: rgba(0, 136, 255, 0.3); }

.control-button.danger {
    background: rgba(255, 68, 68, 0.2);
    border-color: rgba(255, 68, 68, 0.4);
}

.control-button.danger:hover { background: rgba(255, 68, 68, 0.3); }

.control-button.pattern {
    background: rgba(138, 43, 226, 0.2);
    border-color: rgba(138, 43, 226, 0.4);
}

.control-button.pattern:hover { background: rgba(138, 43, 226, 0.3); }

.toggle-button.active {
    background: rgba(0, 255, 136, 0.3);
    border-color: rgba(0, 255, 136, 0.6);
    box-shadow: 0 0 10px rgba(0, 255, 136, 0.2);
}

.toggle-switch {
    position: relative;
    width: 50px;
    height: 24px;
    background: var(--bg-button);
    border-radius: 12px;
    cursor: pointer;
    transition: background 0.3s ease;
    border: 1px solid var(--border-primary);
}

.toggle-switch.active {
    background: rgba(0, 255, 136, 0.3);
    border-color: rgba(0, 255, 136, 0.6);
}

.toggle-circle {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 18px;
    height: 18px;
    background: white;
    border-radius: 50%;
    transition: transform 0.3s ease;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.toggle-switch.active .toggle-circle {
    transform: translateX(26px);
}

.color-picker-container {
    display: flex;
    gap: 10px;
    align-items: center;
}

.color-preview {
    width: 40px;
    height: 24px;
    border-radius: 4px;
    cursor: pointer;
    border: 1px solid var(--border-primary);
    transition: 0.2s ease;
}

.color-preview:hover {
    border-color: var(--color-primary);
    box-shadow: 0 0 8px rgba(0, 255, 136, 0.3);
}

.color-input {
    display: none;
}

.info-text {
    font-size: 11px;
    opacity: 0.6;
    margin-top: 10px;
}

.stats-text {
    font-size: 10px;
    opacity: 0.5;
    margin-top: 5px;
    font-family: monospace;
}

.point-section {
    background: var(--bg-secondary);
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
}

.point-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.point-id {
    font-size: 12px;
    opacity: 0.7;
    font-family: monospace;
}

.point-list {
    max-height: 200px;
    overflow-y: auto;
    border: 1px solid var(--border-primary);
    border-radius: 5px;
}

.point-item {
    padding: 8px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    cursor: pointer;
    transition: background 0.2s ease;
    font-size: 12px;
}

.point-item:hover { background: var(--bg-button); }
.point-item.selected { background: var(--bg-button-hover); }

.empty-state {
    text-align: center;
    opacity: 0.5;
    font-size: 12px;
    padding: 20px;
}

.panel-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.3);
    z-index: 998;
    opacity: 0;
    visibility: hidden;
    transition: 0.3s ease;
}

.panel-overlay.active {
    opacity: 1;
    visibility: visible;
}

.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(10px);
    z-index: 2000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
}

.modal {
    background: var(--bg-primary);
    backdrop-filter: blur(20px);
    border: 1px solid var(--border-primary);
    border-radius: 16px;
    max-width: 500px;
    width: 100%;
    color: var(--text-primary);
    overflow: hidden;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    max-height: 90vh;
    overflow-y: auto;
}

.modal-header {
    padding: 30px 30px 20px;
    text-align: center;
    border-bottom: 1px solid var(--border-primary);
}

.modal-header h2 {
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 8px;
}

.modal-header p {
    font-size: 14px;
    opacity: 0.7;
    margin: 0;
}

.modal-content {
    padding: 25px 30px;
}

.instruction-list {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.instruction-item {
    font-size: 14px;
    line-height: 1.5;
    padding: 12px 16px;
    background: var(--bg-secondary);
    border-radius: 8px;
    border-left: 3px solid rgba(255, 255, 255, 0.3);
}

.instruction-item strong {
    color: var(--color-primary);
    font-weight: 600;
}

.warning-item {
    border-left: 3px solid var(--color-warning);
}

.warning-item strong {
    color: var(--color-warning);
}

.modal-footer {
    padding: 20px 30px 30px;
    text-align: center;
}

.modal-button {
    background: linear-gradient(135deg, var(--color-primary), #00cc6a);
    border: none;
    border-radius: 12px;
    color: white;
    font-size: 16px;
    font-weight: 600;
    padding: 16px 32px;
    cursor: pointer;
    transition: 0.3s ease;
    box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
    margin: 0 5px;
}

.modal-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4);
}

.modal-button:active { transform: translateY(0); }

.modal-button.secondary {
    background: linear-gradient(135deg, var(--color-secondary), #0066cc);
    box-shadow: 0 4px 15px rgba(0, 136, 255, 0.3);
}

.modal-button.secondary:hover {
    box-shadow: 0 6px 20px rgba(0, 136, 255, 0.4);
}

.keyboard-shortcuts {
    display: grid;
    gap: 8px;
    margin: 15px 0;
}

.shortcut-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    background: var(--bg-secondary);
    border-radius: 6px;
    font-size: 12px;
}

.shortcut-key {
    background: var(--bg-button);
    padding: 4px 8px;
    border-radius: 4px;
    font-family: monospace;
    font-size: 11px;
}

.about-section {
    text-align: center;
    margin: 20px 0;
    padding: 15px;
    background: var(--bg-secondary);
    border-radius: 8px;
}

.about-section p {
    margin: 8px 0;
    font-size: 13px;
    line-height: 1.4;
}

.license-text {
    font-size: 11px;
    opacity: 0.6;
    margin-top: 15px;
    font-family: monospace;
}

@media (min-width: 768px) {
    .help-button, .menu-toggle {
        top: 30px;
        width: 60px;
        height: 60px;
    }
    
    .help-button {
        left: 30px;
    }
    
    .menu-toggle {
        right: 30px;
    }
    
    .control-panel {
        width: 400px;
        right: -400px;
    }
    
    .control-section {
        padding: 25px;
    }
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div class="visual-indicator long-press-indicator" id="longPressIndicator"></div>

<div class="modal-overlay" id="welcomeOverlay">
    <div class="modal">
        <div class="modal-header">
            <h2>Wave Physics Simulation</h2>
            <p>Interactive wave interference patterns</p>
        </div>
        <div class="modal-content">
            <div class="instruction-list">
                <div class="instruction-item">
                    <strong>Create waves:</strong> Press and hold on empty space to add wave sources
                </div>
                <div class="instruction-item">
                    <strong>Generate patterns:</strong> Use Pattern Generator for mathematical layouts
                </div>
                <div class="instruction-item">
                    <strong>Manipulate:</strong> Select, move, clone, and customize wave points
                </div>
                <div class="instruction-item">
                    <strong>Visualize:</strong> Watch interference patterns form in real-time
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="modal-button" id="welcomeStartBtn">Get Started</button>
        </div>
    </div>
</div>

<div class="modal-overlay" id="healthWarningOverlay" style="display: none;">
    <div class="modal">
        <div class="modal-header">
            <h2>Health & Safety Warning</h2>
            <p>Important information before you begin</p>
        </div>
        <div class="modal-content">
            <div class="instruction-list">
                <div class="instruction-item warning-item">
                    <strong>Photosensitive Epilepsy:</strong> This simulation contains flashing patterns and rapid visual changes that may trigger seizures in individuals with photosensitive epilepsy
                </div>
                <div class="instruction-item warning-item">
                    <strong>Motion Sensitivity:</strong> The dynamic wave patterns may cause discomfort for those sensitive to motion or visual effects
                </div>
                <div class="instruction-item">
                    <strong>Safe Usage:</strong> If you experience any discomfort, dizziness, or unusual symptoms, please stop using the simulation immediately
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="modal-button secondary" id="healthBackBtn">Go Back</button>
            <button class="modal-button" id="healthContinueBtn">I Understand, Continue</button>
        </div>
    </div>
</div>

<div class="modal-overlay" id="helpOverlay" style="display: none;">
    <div class="modal">
        <div class="modal-header">
            <h2>Help & Instructions</h2>
            <p>Complete guide to wave simulation</p>
        </div>
        <div class="modal-content">
            <div class="section-title">Basic Controls</div>
            <div class="instruction-list">
                <div class="instruction-item">
                    <strong>Add Points:</strong> Press and hold on empty space until indicator completes
                </div>
                <div class="instruction-item">
                    <strong>Select Points:</strong> Tap on wave points to select them
                </div>
                <div class="instruction-item">
                    <strong>Multi-Select:</strong> Double-tap on points when visible for multiple selection
                </div>
                <div class="instruction-item">
                    <strong>Move Points:</strong> Drag selected points to new positions
                </div>
                <div class="instruction-item">
                    <strong>Delete Points:</strong> Select points and use delete button or keyboard
                </div>
            </div>
            
            <div class="section-title">Keyboard Shortcuts</div>
            <div class="keyboard-shortcuts">
                <div class="shortcut-item">
                    <span>Delete selected points</span>
                    <span class="shortcut-key">Del / Backspace</span>
                </div>
                <div class="shortcut-item">
                    <span>Clone selected points</span>
                    <span class="shortcut-key">C</span>
                </div>
                <div class="shortcut-item">
                    <span>Close panels</span>
                    <span class="shortcut-key">Esc</span>
                </div>
            </div>
            
            <div class="section-title">Wave Properties</div>
            <div class="instruction-list">
                <div class="instruction-item">
                    <strong>Amplitude:</strong> Controls wave intensity (brightness/color)
                </div>
                <div class="instruction-item">
                    <strong>Wavelength:</strong> Distance between wave peaks
                </div>
                <div class="instruction-item">
                    <strong>Speed:</strong> How fast waves propagate outward
                </div>
                <div class="instruction-item">
                    <strong>Phase Offset:</strong> Creates time delays between points
                </div>
            </div>
            
            <div class="about-section">
                <p><strong>Wave Physics Simulation</strong></p>
                <p>Vibe coded during commute and coffee breaks by David Donelan</p>
                <p class="license-text">Released under MIT License<br>
                Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
            </div>
        </div>
        <div class="modal-footer">
            <button class="modal-button" id="helpCloseBtn">Close</button>
        </div>
    </div>
</div>

<button class="help-button" id="helpBtn">?</button>

<button class="menu-toggle" id="menuToggle">
    <div class="menu-icon">
        <span></span>
        <span></span>
        <span></span>
    </div>
</button>

<div class="panel-overlay" id="panelOverlay"></div>
<div class="control-panel" id="controlPanel">
    <div class="panel-header">
        <div class="panel-title">Wave Point Editor</div>
        <div class="panel-subtitle">Press and hold on canvas to add points</div>
    </div>
    
    <div class="control-section">
        <div class="section-title">Animation</div>
        <div class="button-group">
            <button class="control-button" id="syncBtn">Sync</button>
            <div class="control-group">
                <label class="control-label">Show Points</label>
                <div class="toggle-switch" id="showPointsToggle">
                    <div class="toggle-circle"></div>
                </div>
            </div>
        </div>
        <div class="button-group" style="margin-top: 10px;">
            <button class="control-button toggle-button" id="playPauseBtn">Pause</button>
            <button class="control-button" id="clearBtn">Clear All</button>
        </div>
        <div class="info-text" id="stats">Points: 0</div>
    </div>
    
    <div class="control-section">
        <div class="section-title">Pattern Generator</div>
        <div class="control-group">
            <label class="control-label">Pattern Type</label>
            <select id="patternType" class="select-input">
                <option value="grid">Grid</option>
                <option value="radial">Radial</option>
                <option value="spiral">Spiral</option>
                <option value="sunflower">Sunflower</option>
            </select>
        </div>
        <div class="control-group">
            <label class="control-label">Number of Points</label>
            <div class="slider-container">
                <input type="range" class="slider" id="patternCount" min="4" max="36" step="1" value="16">
                <div class="slider-value" id="patternCountValue">16</div>
            </div>
        </div>
        <div class="control-group">
            <label class="control-label">Pattern Scale</label>
            <div class="slider-container">
                <input type="range" class="slider" id="patternScale" min="0.3" max="2.0" step="0.1" value="1.0">
                <div class="slider-value" id="patternScaleValue">1.0×</div>
            </div>
        </div>
        <div class="button-group">
            <button class="control-button pattern" id="generatePatternBtn">Add Pattern</button>
        </div>
        <div class="info-text">Adds to existing points (max 36 total)</div>
    </div>
    
    <div class="control-section">
        <div class="section-title">Point List</div>
        <div class="point-list" id="pointList">
            <div class="empty-state">No points created</div>
        </div>
    </div>
    
    <div class="control-section" id="selectedPointSection" style="display: none;">
        <div class="section-title">Selected Point</div>
        <div class="point-section">
            <div class="point-header">
                <span class="point-id" id="selectedPointId">Point #1</span>
            </div>
            
            <div class="control-group">
                <label class="control-label">Wave Type</label>
                <div class="button-group">
                    <button class="control-button toggle-button active" id="pointWaveTypeBtn">Sine</button>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label">Amplitude</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="pointAmplitude" min="10" max="100" step="5" value="60">
                    <div class="slider-value" id="pointAmplitudeValue">60</div>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label">Wavelength</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="pointWavelength" min="20" max="400" step="10" value="100">
                    <div class="slider-value" id="pointWavelengthValue">100px</div>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label">Propagation Speed</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="pointSpeed" min="0.1" max="1.0" step="0.1" value="1.0">
                    <div class="slider-value" id="pointSpeedValue">1.0</div>
                </div>
            </div>
            
            <div class="button-group">
                <button class="control-button secondary" id="clonePointBtn">Clone Point</button>
                <button class="control-button danger" id="deletePointBtn">Delete Point</button>
            </div>
            
            <div class="button-group" style="margin-top: 10px;">
                <button class="control-button primary" id="applyToAllBtn">Apply to All Points</button>
            </div>
        </div>
    </div>
    
    <div class="control-section">
        <div class="section-title">Medium</div>
        
        <div class="control-group">
            <label class="control-label">Color Mode</label>
            <div class="toggle-switch" id="colorToggle">
                <div class="toggle-circle"></div>
            </div>
        </div>
        
        <div class="control-group" id="colorControls" style="display: none;">
            <label class="control-label">Wave Colors</label>
            <div class="color-picker-container">
                <div class="color-preview" id="color1Preview" style="background-color: hsl(240, 70%, 50%);"></div>
                <input type="color" id="color1Input" class="color-input" value="#4d4dff">
                <span style="font-size: 12px; opacity: 0.7;">to</span>
                <div class="color-preview" id="color2Preview" style="background-color: hsl(0, 70%, 50%);"></div>
                <input type="color" id="color2Input" class="color-input" value="#ff4d4d">
            </div>
        </div>
        
        <div class="control-group">
            <label class="control-label">Point Phase Offset</label>
            <div class="slider-container">
                <input type="range" class="slider" id="pointPhaseOffsetSlider" min="-2" max="2" step="0.1" value="0">
                <div class="slider-value" id="pointPhaseOffsetValue">0</div>
            </div>
        </div>
        
        <div class="control-group">
            <label class="control-label">Damping</label>
            <div class="slider-container">
                <input type="range" class="slider" id="dampingSlider" min="0.0" max="0.03" step="0.002" value="0.008">
                <div class="slider-value" id="dampingValue">0.008</div>
            </div>
        </div>
        
        <div class="control-group">
            <label class="control-label">Resolution</label>
            <div class="slider-container">
                <input type="range" class="slider" id="performanceSlider" min="0" max="5" step="1" value="2">
                <div class="slider-value" id="performanceValue">Fast</div>
            </div>
            <div class="stats-text" id="performanceInfo">Resolution: calculating...</div>
        </div>
    </div>
</div>

<script>
'use strict';

// ====================================================================
// CONFIGURATION
// ====================================================================
const CONFIG = {
    maxPoints: 36,
    pointVisualRadius: 12,
    pointHitRadius: 25,
    pointBorderWidth: 2,
    longPressDuration: 500,
    frameInterval: 20, // 50fps
    minPointDistance: 40,
    
    defaults: {
        amplitude: 60,
        wavelength: 100,
        speed: 1.0,
        waveType: 'sine',
        performanceLevel: 2, // Fast
        damping: 0.008,
        showPoints: false
    },
    
    performanceLevels: [
        { skip: 1, label: 'Quality' },
        { skip: 2, label: 'Balanced' },
        { skip: 4, label: 'Fast' },
        { skip: 8, label: 'Faster' },
        { skip: 16, label: 'Very Fast' },
        { skip: 32, label: 'Ultra Fast' }
    ],
    
    patterns: {
        grid: 'Grid',
        radial: 'Radial', 
        spiral: 'Spiral',
        sunflower: 'Sunflower'
    }
};

// ====================================================================
// UTILITY FUNCTIONS
// ====================================================================
const Utils = {
    clamp: (val, min, max) => Math.max(min, Math.min(max, val)),
    distance: (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2),
    formatValue: (val, decimals = 3) => Number(val).toFixed(decimals),
    generateId: () => `point_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    
    haptic: () => {
        if ('vibrate' in navigator) navigator.vibrate(10);
    },
    
    showVisual: (x, y, className, duration = 500) => {
        const element = document.createElement('div');
        element.className = `visual-indicator ${className}`;
        element.style.left = `${x}px`;
        element.style.top = `${y}px`;
        document.body.appendChild(element);
        setTimeout(() => element.remove(), duration);
    },
    
    formatPiMultiplier: (value) => {
        if (value === 0) return '0';
        if (value === 1) return 'π';
        if (value === -1) return '-π';
        if (value % 1 === 0) return `${value}π`;
        return `${Utils.formatValue(value, 1)}π`;
    },
    
    hexToHsl: (hex) => {
        const r = parseInt(hex.slice(1, 3), 16) / 255;
        const g = parseInt(hex.slice(3, 5), 16) / 255;
        const b = parseInt(hex.slice(5, 7), 16) / 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        
        if (max === min) {
            h = s = 0;
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        
        return {
            h: Math.round(h * 360),
            s: Math.round(s * 100),
            l: Math.round(l * 100)
        };
    },
    
    lerpHue: (hue1, hue2, t) => {
        let diff = Math.abs(hue1 - hue2);
        if (diff > 180) {
            if (hue2 > hue1) hue1 += 360;
            else hue2 += 360;
        }
        return Math.round((hue1 + (hue2 - hue1) * t) % 360);
    },
    
    hslToRgb: (h, s, l) => {
        h /= 360;
        s /= 100;
        l /= 100;
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h * 6) % 2 - 1));
        const m = l - c / 2;
        
        let r, g, b;
        if (h < 1/6) [r, g, b] = [c, x, 0];
        else if (h < 2/6) [r, g, b] = [x, c, 0];
        else if (h < 3/6) [r, g, b] = [0, c, x];
        else if (h < 4/6) [r, g, b] = [0, x, c];
        else if (h < 5/6) [r, g, b] = [x, 0, c];
        else [r, g, b] = [c, 0, x];
        
        return {
            r: Math.round((r + m) * 255),
            g: Math.round((g + m) * 255),
            b: Math.round((b + m) * 255)
        };
    }
};

// ====================================================================
// WAVE POINT CLASS
// ====================================================================
class WavePoint {
    constructor(x, y, properties = {}) {
        this.id = Utils.generateId();
        this.x = x;
        this.y = y;
        this.startTime = 0;
        this.selected = false;
        this.amplitude = properties.amplitude || CONFIG.defaults.amplitude;
        this.wavelength = properties.wavelength || CONFIG.defaults.wavelength;
        this.speed = properties.speed || CONFIG.defaults.speed;
        this.waveType = properties.waveType || CONFIG.defaults.waveType;
        this.phaseOffset = properties.phaseOffset || 0;
        this.creationIndex = properties.creationIndex || 0;
    }
    
    getProperties() {
        return {
            amplitude: this.amplitude,
            wavelength: this.wavelength,
            speed: this.speed,
            waveType: this.waveType,
            phaseOffset: this.phaseOffset
        };
    }
    
    distanceTo(x, y) {
        return Utils.distance(this.x, this.y, x, y);
    }
    
    isHit(x, y) {
        return this.distanceTo(x, y) <= CONFIG.pointHitRadius;
    }
    
    getDisplayName() {
        return `Point ${this.id.split('_')[1].slice(-3)}`;
    }
    
    get frequency() {
        return (2 * Math.PI) / this.wavelength;
    }
}

// ====================================================================
// PATTERN GENERATOR
// ====================================================================
class PatternGenerator {
    static generate(type, count, bounds, scale = 1.0) {
        const cx = bounds.width / 2;
        const cy = bounds.height / 2;
        const maxRadius = (Math.min(bounds.width, bounds.height) / 2 - 50) * scale;
        
        switch (type) {
            case 'grid': return this.generateGrid(count, cx, cy, maxRadius);
            case 'radial': return this.generateRadial(count, cx, cy, maxRadius);
            case 'spiral': return this.generateSpiral(count, cx, cy, maxRadius);
            case 'sunflower': return this.generateSunflower(count, cx, cy, maxRadius);
            default: return [];
        }
    }
    
    static generateGrid(count, cx, cy, maxRadius) {
        const points = [];
        const gridSize = Math.ceil(Math.sqrt(count));
        const spacing = (maxRadius * 2) / (gridSize + 1);
        const startX = cx - (gridSize - 1) * spacing / 2;
        const startY = cy - (gridSize - 1) * spacing / 2;
        
        for (let i = 0; i < gridSize * gridSize && points.length < count; i++) {
            const row = Math.floor(i / gridSize);
            const col = i % gridSize;
            points.push({
                x: startX + col * spacing,
                y: startY + row * spacing
            });
        }
        return points;
    }
    
    static generateRadial(count, cx, cy, maxRadius) {
        const points = [];
        const rings = Math.min(4, Math.ceil(count / 8));
        const pointsPerRing = Math.ceil(count / rings);
        
        for (let ring = 0; ring < rings; ring++) {
            const radius = ((ring + 1) / rings) * maxRadius;
            const ringCount = Math.min(pointsPerRing, count - points.length);
            
            for (let i = 0; i < ringCount; i++) {
                const angle = (i / ringCount) * 2 * Math.PI - Math.PI / 2;
                points.push({
                    x: cx + radius * Math.cos(angle),
                    y: cy + radius * Math.sin(angle)
                });
            }
        }
        return points;
    }
    
    static generateSpiral(count, cx, cy, maxRadius) {
        const points = [];
        const maxAngle = 4 * Math.PI;
        
        for (let i = 0; i < count; i++) {
            const t = (i / count) * maxAngle;
            const radius = (t / maxAngle) * maxRadius;
            points.push({
                x: cx + radius * Math.cos(t),
                y: cy + radius * Math.sin(t)
            });
        }
        return points;
    }
    
    static generateSunflower(count, cx, cy, maxRadius) {
        const points = [];
        const golden = Math.PI * (3 - Math.sqrt(5));
        
        for (let i = 0; i < count; i++) {
            const theta = i * golden;
            const radius = Math.sqrt(i / count) * maxRadius;
            points.push({
                x: cx + radius * Math.cos(theta),
                y: cy + radius * Math.sin(theta)
            });
        }
        return points;
    }
    
    static findRandomPosition(existingPoints, bounds) {
        const margin = 30;
        const minDist = CONFIG.minPointDistance;
        const maxAttempts = 50;
        
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            const x = margin + Math.random() * (bounds.width - 2 * margin);
            const y = margin + Math.random() * (bounds.height - 2 * margin);
            
            const tooClose = existingPoints.some(point => 
                Utils.distance(x, y, point.x, point.y) < minDist
            );
            
            if (!tooClose) return { x, y };
        }
        
        return {
            x: margin + Math.random() * (bounds.width - 2 * margin),
            y: margin + Math.random() * (bounds.height - 2 * margin)
        };
    }
}

// ====================================================================
// WAVE ENGINE CLASS
// ====================================================================
class WaveEngine {
    constructor() {
        this.points = new Map();
        this.time = 0;
        this.pointPhaseOffset = 0;
        this.mediumDamping = CONFIG.defaults.damping;
        this.creationCounter = 0;
        this.color1 = { h: 240, s: 70, l: 50 };
        this.color2 = { h: 0, s: 70, l: 50 };
        this.useColor = false;
    }
    
    addPoint(x, y, properties = {}) {
        if (this.points.size >= CONFIG.maxPoints) {
            Utils.haptic();
            return null;
        }
        
        const point = new WavePoint(x, y, { 
            ...properties, 
            creationIndex: this.creationCounter++,
            phaseOffset: this.pointPhaseOffset * (this.creationCounter - 1)
        });
        point.startTime = this.time;
        this.points.set(point.id, point);
        return point;
    }
    
    removePoint(id) {
        return this.points.delete(id);
    }
    
    getPoint(id) {
        return this.points.get(id);
    }
    
    getAllPoints() {
        return Array.from(this.points.values());
    }
    
    findPointAt(x, y) {
        for (const point of this.points.values()) {
            if (point.isHit(x, y)) return point;
        }
        return null;
    }
    
    clearAll() {
        this.points.clear();
        this.time = 0;
        this.creationCounter = 0;
    }
    
    syncPoints() {
        this.time = 0;
        this.pointPhaseOffset = 0;
        
        for (const point of this.points.values()) {
            point.startTime = 0;
            point.phaseOffset = 0;
        }
    }
    
    applyPointPhaseOffsets() {
        const points = this.getAllPoints().sort((a, b) => a.creationIndex - b.creationIndex);
        points.forEach((point, index) => {
            point.phaseOffset = this.pointPhaseOffset * index;
        });
    }
    
    calculatePixel(x, y) {
        let totalWave = 0;
        
        for (const point of this.points.values()) {
            const age = this.time - point.startTime;
            if (age < 0) continue;
            
            const dist = point.distanceTo(x, y);
            const phase = point.frequency * dist - point.speed * age + point.phaseOffset;
            
            let waveValue;
            if (point.waveType === 'sine') {
                waveValue = point.amplitude * Math.sin(phase);
            } else {
                const normalized = ((phase % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
                waveValue = point.amplitude * (normalized < Math.PI ? 1 : -1);
            }
            
            waveValue *= Math.exp(-dist * this.mediumDamping);
            totalWave += waveValue;
        }
        
        return this.waveToColor(totalWave);
    }
    
    waveToColor(waveValue) {
        if (!this.useColor) {
            const normalized = waveValue / 100;
            return Utils.clamp(128 + normalized * 127, 0, 255);
        }
        
        const normalizedValue = Utils.clamp((waveValue / 100 + 1) / 2, 0, 1);
        const interpolatedHue = Utils.lerpHue(this.color1.h, this.color2.h, normalizedValue);
        return Utils.hslToRgb(interpolatedHue, 70, 50);
    }
    
    updateTime(deltaTime) {
        this.time += deltaTime;
    }
    
    setColorMode(enabled) {
        this.useColor = enabled;
    }
    
    setColors(color1, color2) {
        this.color1 = color1;
        this.color2 = color2;
    }
    
    setPointPhaseOffset(offset) {
        this.pointPhaseOffset = offset;
        this.applyPointPhaseOffsets();
    }
    
    setDamping(damping) {
        this.mediumDamping = damping;
    }
}

// ====================================================================
// RENDERER CLASS
// ====================================================================
class Renderer {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.imageData = null;
        this.skipFactor = CONFIG.performanceLevels[CONFIG.defaults.performanceLevel].skip;
        this.resize();
    }
    
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
    }
    
    setPerformanceLevel(level) {
        this.skipFactor = CONFIG.performanceLevels[level].skip;
    }
    
    render(engine, showPoints, selectedPoints) {
        this.clearCanvas();
        if (engine.points.size > 0) {
            this.renderWaveField(engine);
        }
        this.ctx.putImageData(this.imageData, 0, 0);
        this.renderPoints(engine.getAllPoints(), showPoints, selectedPoints);
    }
    
    clearCanvas() {
        const data = this.imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            data[i] = data[i + 1] = data[i + 2] = 0;
            data[i + 3] = 255;
        }
    }
    
    renderWaveField(engine) {
        const { width, height } = this.canvas;
        const skip = this.skipFactor;
        
        for (let y = 0; y < height; y += skip) {
            for (let x = 0; x < width; x += skip) {
                const color = engine.calculatePixel(x, y);
                this.fillBlock(x, y, color, skip);
            }
        }
    }
    
    fillBlock(startX, startY, color, size) {
        const data = this.imageData.data;
        const { width, height } = this.canvas;
        
        for (let dy = 0; dy < size && startY + dy < height; dy++) {
            for (let dx = 0; dx < size && startX + dx < width; dx++) {
                const index = ((startY + dy) * width + (startX + dx)) * 4;
                
                if (typeof color === 'object') {
                    data[index] = color.r;
                    data[index + 1] = color.g;
                    data[index + 2] = color.b;
                } else {
                    data[index] = data[index + 1] = data[index + 2] = color;
                }
            }
        }
    }
    
    renderPoints(allPoints, showPoints, selectedPoints) {
        if (showPoints) {
            allPoints.forEach(point => this.drawPoint(point));
        } else if (selectedPoints.length > 0) {
            selectedPoints.forEach(point => this.drawPoint(point));
        }
    }
    
    drawPoint(point) {
        const visualRadius = CONFIG.pointVisualRadius;
        const hitRadius = CONFIG.pointHitRadius;
        const borderWidth = CONFIG.pointBorderWidth;
        
        if (point.selected) {
            this.ctx.strokeStyle = '#00ff88';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(point.x, point.y, hitRadius, 0, 2 * Math.PI);
            this.ctx.stroke();
        }
        
        // Draw border (dark outline)
        this.ctx.fillStyle = '#333333';
        this.ctx.beginPath();
        this.ctx.arc(point.x, point.y, visualRadius + borderWidth, 0, 2 * Math.PI);
        this.ctx.fill();
        
        // Draw main dot (white)
        this.ctx.fillStyle = 'white';
        this.ctx.beginPath();
        this.ctx.arc(point.x, point.y, visualRadius, 0, 2 * Math.PI);
        this.ctx.fill();
    }
    
    getPerformanceInfo() {
        const config = CONFIG.performanceLevels.find(level => level.skip === this.skipFactor);
        const width = Math.floor(window.innerWidth / this.skipFactor);
        const height = Math.floor(window.innerHeight / this.skipFactor);
        const speedup = this.skipFactor === 1 ? '' : ` (${this.skipFactor ** 2}x faster)`;
        
        return {
            label: config.label,
            resolution: `${width}×${height}${speedup}`
        };
    }
}

// ====================================================================
// ANIMATION MANAGER CLASS
// ====================================================================
class AnimationManager {
    constructor(renderer, engine) {
        this.renderer = renderer;
        this.engine = engine;
        this.isAnimating = false;
        this.animationId = null;
        this.lastFrameTime = 0;
        this.frameInterval = CONFIG.frameInterval;
        this.showPoints = CONFIG.defaults.showPoints;
        this.selectedPoints = [];
    }
    
    start() {
        if (this.isAnimating) return;
        
        this.isAnimating = true;
        this.lastFrameTime = performance.now();
        this.animate();
    }
    
    stop() {
        this.isAnimating = false;
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
    }
    
    toggle() {
        this.isAnimating ? this.stop() : this.start();
    }
    
    animate() {
        const currentTime = performance.now();
        
        if (this.isAnimating && (currentTime - this.lastFrameTime) >= this.frameInterval) {
            this.engine.updateTime(0.2);
            this.renderer.render(this.engine, this.showPoints, this.selectedPoints);
            this.lastFrameTime = currentTime;
        }
        
        if (this.isAnimating) {
            this.animationId = requestAnimationFrame(() => this.animate());
        }
    }
    
    setShowPoints(show) {
        this.showPoints = show;
        this.renderer.render(this.engine, this.showPoints, this.selectedPoints);
    }
    
    setSelectedPoints(points) {
        this.selectedPoints = points;
        this.renderer.render(this.engine, this.showPoints, this.selectedPoints);
    }
    
    forceRender() {
        this.renderer.render(this.engine, this.showPoints, this.selectedPoints);
    }
}

// ====================================================================
// UI CONTROLLER CLASS
// ====================================================================
class UIController {
    constructor(engine, animationManager, renderer) {
        this.engine = engine;
        this.animationManager = animationManager;
        this.renderer = renderer;
        this.selectedIds = new Set();
        this.panelOpen = false;
        this.elements = this.cacheElements();
        this.setupEventListeners();
        this.updatePerformanceInfo();
    }
    
    cacheElements() {
        const ids = [
            'helpBtn', 'menuToggle', 'panelOverlay', 'controlPanel',
            'welcomeOverlay', 'welcomeStartBtn', 'healthWarningOverlay',
            'healthBackBtn', 'healthContinueBtn', 'helpOverlay', 'helpCloseBtn',
            'clearBtn', 'playPauseBtn', 'syncBtn', 'showPointsToggle',
            'generatePatternBtn', 'pointWaveTypeBtn', 'clonePointBtn',
            'deletePointBtn', 'applyToAllBtn', 'colorToggle',
            'color1Preview', 'color1Input', 'color2Preview', 'color2Input',
            'pointList', 'selectedPointSection', 'selectedPointId',
            'stats', 'colorControls', 'performanceInfo'
        ];
        
        const elements = {};
        ids.forEach(id => {
            elements[id] = document.getElementById(id);
        });
        return elements;
    }
    
    setupEventListeners() {
        // Modal management
        this.elements.welcomeStartBtn.addEventListener('click', () => this.showHealthWarning());
        this.elements.healthBackBtn.addEventListener('click', () => this.showWelcome());
        this.elements.healthContinueBtn.addEventListener('click', () => this.startApp());
        this.elements.helpBtn.addEventListener('click', () => this.showHelp());
        this.elements.helpCloseBtn.addEventListener('click', () => this.hideHelp());
        
        // Panel management
        this.elements.menuToggle.addEventListener('click', () => this.togglePanel());
        this.elements.panelOverlay.addEventListener('click', () => this.closePanel());
        
        // Control buttons
        this.elements.clearBtn.addEventListener('click', () => this.clearAll());
        this.elements.playPauseBtn.addEventListener('click', () => this.toggleAnimation());
        this.elements.syncBtn.addEventListener('click', () => this.syncPoints());
        this.elements.showPointsToggle.addEventListener('click', () => this.toggleShowPoints());
        this.elements.generatePatternBtn.addEventListener('click', () => this.generatePattern());
        this.elements.pointWaveTypeBtn.addEventListener('click', () => this.toggleWaveType());
        this.elements.clonePointBtn.addEventListener('click', () => this.clonePoint());
        this.elements.deletePointBtn.addEventListener('click', () => this.deletePoint());
        this.elements.applyToAllBtn.addEventListener('click', () => this.applyToAllPoints());
        this.elements.colorToggle.addEventListener('click', () => this.toggleColorMode());
        
        // Color pickers
        this.elements.color1Preview.addEventListener('click', () => this.elements.color1Input.click());
        this.elements.color2Preview.addEventListener('click', () => this.elements.color2Input.click());
        this.elements.color1Input.addEventListener('change', (e) => this.updateColor1(e.target.value));
        this.elements.color2Input.addEventListener('change', (e) => this.updateColor2(e.target.value));
        
        // Sliders
        this.setupSliders();
        
        // Point list
        this.elements.pointList.addEventListener('click', (e) => {
            const item = e.target.closest('.point-item');
            if (item) {
                const isMultiSelect = e.ctrlKey || e.shiftKey;
                this.selectPoint(item.dataset.id, isMultiSelect);
            }
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => this.handleKeyboard(e));
        
        // Window events
        window.addEventListener('resize', () => {
            this.renderer.resize();
            this.updatePerformanceInfo();
        });
    }
    
    setupSliders() {
        this.setupSlider('pointAmplitude', (v) => this.updatePointProperty('amplitude', parseInt(v)), 0);
        this.setupSlider('pointWavelength', (v) => this.updatePointProperty('wavelength', parseInt(v)), 0, 'px');
        this.setupSlider('pointSpeed', (v) => this.updatePointProperty('speed', parseFloat(v)), 1);
        this.setupSlider('dampingSlider', (v) => { 
            this.engine.setDamping(parseFloat(v)); 
            this.updateSliderValue('dampingValue', v); 
        });
        this.setupSlider('performanceSlider', (v) => this.setPerformanceLevel(parseInt(v)));
        this.setupSlider('patternCount', (v) => this.updateSliderValue('patternCountValue', v));
        this.setupSlider('patternScale', (v) => this.updateSliderValue('patternScaleValue', v + '×'));
        this.setupSlider('pointPhaseOffsetSlider', (v) => { 
            this.engine.setPointPhaseOffset(parseFloat(v) * Math.PI); 
            this.updateSliderValue('pointPhaseOffsetValue', Utils.formatPiMultiplier(parseFloat(v)));
        });
    }
    
    setupSlider(id, handler, decimals = 3, suffix = '') {
        const slider = document.getElementById(id);
        const valueEl = document.getElementById(id.replace('Slider', 'Value'));
        
        if (slider) {
            slider.addEventListener('input', (e) => {
                const value = e.target.value;
                handler(value);
                if (valueEl) {
                    const formatted = decimals > 0 ? Utils.formatValue(value, decimals) : value;
                    valueEl.textContent = formatted + suffix;
                }
            });
        }
    }
    
    updateSliderValue(id, value) {
        const el = document.getElementById(id);
        if (el) el.textContent = value;
    }
    
    // Modal methods
    showWelcome() {
        this.elements.welcomeOverlay.style.display = 'flex';
        this.elements.healthWarningOverlay.style.display = 'none';
    }
    
    showHealthWarning() {
        this.elements.welcomeOverlay.style.display = 'none';
        this.elements.healthWarningOverlay.style.display = 'flex';
    }
    
    startApp() {
        this.elements.healthWarningOverlay.style.display = 'none';
        this.createStarterPoint();
    }
    
    showHelp() {
        this.elements.helpOverlay.style.display = 'flex';
    }
    
    hideHelp() {
        this.elements.helpOverlay.style.display = 'none';
    }
    
    // Panel methods
    togglePanel() {
        this.panelOpen ? this.closePanel() : this.openPanel();
    }
    
    openPanel() {
        this.panelOpen = true;
        this.elements.controlPanel.classList.add('open');
        this.elements.panelOverlay.classList.add('active');
        this.elements.menuToggle.classList.add('active');
    }
    
    closePanel() {
        this.panelOpen = false;
        this.elements.controlPanel.classList.remove('open');
        this.elements.panelOverlay.classList.remove('active');
        this.elements.menuToggle.classList.remove('active');
    }
    
    // Point management methods
    selectPoint(id, multiSelect = false) {
        if (!multiSelect) {
            for (const prevId of this.selectedIds) {
                const prev = this.engine.getPoint(prevId);
                if (prev) prev.selected = false;
            }
            this.selectedIds.clear();
        }
        
        const point = this.engine.getPoint(id);
        if (point) {
            if (this.selectedIds.has(id) && multiSelect) {
                this.selectedIds.delete(id);
                point.selected = false;
            } else {
                this.selectedIds.add(id);
                point.selected = true;
            }
        }
        
        this.updateSelectedPointUI();
        this.updatePointsUI();
        this.animationManager.setSelectedPoints(this.getSelectedPoints());
    }
    
    deselectAll() {
        for (const id of this.selectedIds) {
            const point = this.engine.getPoint(id);
            if (point) point.selected = false;
        }
        this.selectedIds.clear();
        this.updateSelectedPointUI();
        this.updatePointsUI();
        this.animationManager.setSelectedPoints([]);
    }
    
    getSelectedPoints() {
        return Array.from(this.selectedIds).map(id => this.engine.getPoint(id)).filter(p => p);
    }
    
    // Action methods
    clearAll() {
        this.engine.clearAll();
        this.selectedIds.clear();
        this.animationManager.stop();
        this.animationManager.setShowPoints(false);
        this.updatePointsUI();
        this.updateSelectedPointUI();
        this.updateButton('showPointsToggle', false);
        this.updateButton('playPauseBtn', true, 'Play', 'Pause');
        this.animationManager.forceRender();
    }
    
    createStarterPoint() {
        const cx = Math.floor(window.innerWidth / 2);
        const cy = Math.floor(window.innerHeight / 2);
        const point = this.engine.addPoint(cx, cy);
        if (point) {
            this.selectPoint(point.id);
            this.animationManager.start();
            this.updatePointsUI();
            this.updateButton('playPauseBtn', false, 'Play', 'Pause');
        }
    }
    
    addPoint(x, y, properties = {}) {
        const point = this.engine.addPoint(x, y, properties);
        if (point) {
            this.selectPoint(point.id);
            if (!this.animationManager.isAnimating && this.engine.points.size > 0) {
                this.animationManager.start();
                this.updateButton('playPauseBtn', false, 'Play', 'Pause');
            }
            this.updatePointsUI();
        }
        return point;
    }
    
    removePoint(id) {
        this.selectedIds.delete(id);
        this.engine.removePoint(id);
        this.updatePointsUI();
        this.updateSelectedPointUI();
        this.animationManager.setSelectedPoints(this.getSelectedPoints());
        
        if (this.engine.points.size === 0) {
            this.animationManager.stop();
            this.updateButton('playPauseBtn', true, 'Play', 'Pause');
        }
    }
    
    generatePattern() {
        const type = document.getElementById('patternType').value;
        const count = parseInt(document.getElementById('patternCount').value);
        const scale = parseFloat(document.getElementById('patternScale').value);
        
        const currentCount = this.engine.points.size;
        const availableSlots = CONFIG.maxPoints - currentCount;
        
        if (availableSlots <= 0) {
            Utils.haptic();
            return;
        }
        
        const actualCount = Math.min(count, availableSlots);
        const bounds = { width: window.innerWidth, height: window.innerHeight };
        const positions = PatternGenerator.generate(type, actualCount, bounds, scale);
        
        positions.forEach((pos, index) => {
            const point = this.engine.addPoint(pos.x, pos.y, {
                creationIndex: this.engine.creationCounter++,
                phaseOffset: this.engine.pointPhaseOffset * (this.engine.creationCounter - 1)
            });
            if (point) {
                point.startTime = this.engine.time - (index * 0.1);
            }
        });
        
        if (positions.length > 0) {
            const allPoints = this.engine.getAllPoints();
            const firstNew = allPoints[allPoints.length - positions.length];
            if (firstNew) this.selectPoint(firstNew.id);
            
            this.animationManager.setShowPoints(true);
            this.updateButton('showPointsToggle', true);
            if (!this.animationManager.isAnimating) {
                this.animationManager.start();
                this.updateButton('playPauseBtn', false, 'Play', 'Pause');
            }
        }
        
        this.updatePointsUI();
        Utils.haptic();
    }
    
    clonePoint() {
        const selectedPoints = this.getSelectedPoints();
        if (selectedPoints.length === 0) return;
        
        const bounds = { width: window.innerWidth, height: window.innerHeight };
        const newPoints = [];
        
        selectedPoints.forEach(selected => {
            const availableSlots = CONFIG.maxPoints - this.engine.points.size;
            if (availableSlots <= 0) return;
            
            const pos = PatternGenerator.findRandomPosition(this.engine.getAllPoints(), bounds);
            const clone = this.engine.addPoint(pos.x, pos.y, {
                ...selected.getProperties(),
                creationIndex: this.engine.creationCounter++,
                phaseOffset: this.engine.pointPhaseOffset * (this.engine.creationCounter - 1)
            });
            
            if (clone) {
                clone.startTime = this.engine.time;
                newPoints.push(clone);
                Utils.showVisual(pos.x, pos.y, 'clone-flash');
            }
        });
        
        if (newPoints.length > 0) {
            this.deselectAll();
            newPoints.forEach((point, index) => {
                this.selectPoint(point.id, index > 0);
            });
            
            if (!this.animationManager.isAnimating) {
                this.animationManager.start();
                this.updateButton('playPauseBtn', false, 'Play', 'Pause');
            }
        }
        
        this.updatePointsUI();
        Utils.haptic();
    }
    
    deletePoint() {
        const selectedPoints = this.getSelectedPoints();
        selectedPoints.forEach(point => {
            this.removePoint(point.id);
        });
    }
    
    toggleWaveType() {
        const selectedPoints = this.getSelectedPoints();
        if (selectedPoints.length > 0) {
            selectedPoints.forEach(point => {
                point.waveType = point.waveType === 'sine' ? 'step' : 'sine';
            });
            this.updateSelectedPointUI();
            this.updatePointsUI();
        }
    }
    
    updatePointProperty(property, value) {
        const selectedPoints = this.getSelectedPoints();
        if (selectedPoints.length > 0) {
            selectedPoints.forEach(point => {
                point[property] = value;
            });
            this.updateSelectedPointUI();
            this.updatePointsUI();
        }
    }
    
    applyToAllPoints() {
        if (this.engine.points.size === 0) return;
        
        const amplitude = parseInt(document.getElementById('pointAmplitude').value);
        const wavelength = parseInt(document.getElementById('pointWavelength').value);
        const speed = parseFloat(document.getElementById('pointSpeed').value);
        const waveTypeBtn = document.getElementById('pointWaveTypeBtn');
        const waveType = waveTypeBtn.classList.contains('active') ? 'sine' : 'step';
        
        for (const point of this.engine.getAllPoints()) {
            point.amplitude = amplitude;
            point.wavelength = wavelength;
            point.speed = speed;
            point.waveType = waveType;
        }
        
        this.updatePointsUI();
        Utils.haptic();
        this.animationManager.forceRender();
    }
    
    syncPoints() {
        if (this.engine.points.size === 0) return;
        
        this.engine.syncPoints();
        
        // Reset UI controls
        document.getElementById('pointPhaseOffsetSlider').value = 0;
        this.updateSliderValue('pointPhaseOffsetValue', '0');
        
        if (!this.animationManager.isAnimating) {
            this.animationManager.start();
            this.updateButton('playPauseBtn', false, 'Play', 'Pause');
        }
        
        this.animationManager.forceRender();
    }
    
    toggleAnimation() {
        this.animationManager.toggle();
        this.updateButton('playPauseBtn', !this.animationManager.isAnimating, 'Play', 'Pause');
    }
    
    toggleShowPoints() {
        const newState = !this.animationManager.showPoints;
        this.animationManager.setShowPoints(newState);
        this.updateButton('showPointsToggle', newState);
    }
    
    toggleColorMode() {
        const newState = !this.engine.useColor;
        this.engine.setColorMode(newState);
        this.updateButton('colorToggle', newState);
        this.updateColorControls();
        this.animationManager.forceRender();
    }
    
    updateColor1(hex) {
        const hsl = Utils.hexToHsl(hex);
        this.engine.color1 = hsl;
        this.elements.color1Preview.style.backgroundColor = hex;
        this.animationManager.forceRender();
    }
    
    updateColor2(hex) {
        const hsl = Utils.hexToHsl(hex);
        this.engine.color2 = hsl;
        this.elements.color2Preview.style.backgroundColor = hex;
        this.animationManager.forceRender();
    }
    
    setPerformanceLevel(level) {
        this.renderer.setPerformanceLevel(level);
        this.updatePerformanceInfo();
    }
    
    handleKeyboard(e) {
        if (e.key === 'Escape' && this.panelOpen) {
            this.closePanel();
        }
        
        const selected = this.getSelectedPoints();
        if (selected.length > 0) {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                e.preventDefault();
                this.deletePoint();
            } else if (e.key === 'c' || e.key === 'C') {
                e.preventDefault();
                this.clonePoint();
            }
        }
    }
    
    // UI update methods
    updateButton(elementId, isActive, activeText = null, inactiveText = null) {
        const element = typeof elementId === 'string' ? this.elements[elementId] : elementId;
        if (!element) return;
        
        element.classList.toggle('active', isActive);
        if (activeText && inactiveText) {
            element.textContent = isActive ? activeText : inactiveText;
        }
    }
    
    updateColorControls() {
        this.elements.colorControls.style.display = this.engine.useColor ? 'block' : 'none';
    }
    
    updatePointsUI() {
        const count = this.engine.points.size;
        this.elements.stats.textContent = `Points: ${count}/${CONFIG.maxPoints}`;
        
        if (count === 0) {
            this.elements.pointList.innerHTML = '<div class="empty-state">No points created</div>';
        } else {
            this.elements.pointList.innerHTML = this.engine.getAllPoints().map(point => `
                <div class="point-item ${point.selected ? 'selected' : ''}" data-id="${point.id}">
                    ${point.getDisplayName()} - ${point.waveType} (${point.amplitude})
                </div>
            `).join('');
        }
    }
    
    updateSelectedPointUI() {
        const selectedPoints = this.getSelectedPoints();
        this.elements.selectedPointSection.style.display = selectedPoints.length > 0 ? 'block' : 'none';
        if (selectedPoints.length === 0) return;
        
        if (selectedPoints.length > 1) {
            this.elements.selectedPointId.textContent = `${selectedPoints.length} Points Selected`;
            
            // Show average values
            const avgAmplitude = Math.round(selectedPoints.reduce((sum, p) => sum + p.amplitude, 0) / selectedPoints.length);
            const avgWavelength = Math.round(selectedPoints.reduce((sum, p) => sum + p.wavelength, 0) / selectedPoints.length);
            const avgSpeed = selectedPoints.reduce((sum, p) => sum + p.speed, 0) / selectedPoints.length;
            
            document.getElementById('pointAmplitude').value = avgAmplitude;
            document.getElementById('pointAmplitudeValue').textContent = avgAmplitude;
            document.getElementById('pointWavelength').value = avgWavelength;
            document.getElementById('pointWavelengthValue').textContent = avgWavelength + 'px';
            document.getElementById('pointSpeed').value = avgSpeed;
            document.getElementById('pointSpeedValue').textContent = Utils.formatValue(avgSpeed, 1);
            
            const firstType = selectedPoints[0].waveType;
            const allSameType = selectedPoints.every(p => p.waveType === firstType);
            
            if (allSameType) {
                this.updateButton('pointWaveTypeBtn', firstType === 'sine', 'Sine', 'Digital');
            } else {
                document.getElementById('pointWaveTypeBtn').textContent = 'Mixed';
                document.getElementById('pointWaveTypeBtn').classList.remove('active');
            }
        } else {
            const point = selectedPoints[0];
            this.elements.selectedPointId.textContent = point.getDisplayName();
            
            document.getElementById('pointAmplitude').value = point.amplitude;
            document.getElementById('pointAmplitudeValue').textContent = point.amplitude;
            document.getElementById('pointWavelength').value = point.wavelength;
            document.getElementById('pointWavelengthValue').textContent = point.wavelength + 'px';
            document.getElementById('pointSpeed').value = point.speed;
            document.getElementById('pointSpeedValue').textContent = Utils.formatValue(point.speed, 1);
            
            this.updateButton('pointWaveTypeBtn', point.waveType === 'sine', 'Sine', 'Digital');
        }
    }
    
    updatePerformanceInfo() {
        const info = this.renderer.getPerformanceInfo();
        this.updateSliderValue('performanceValue', info.label);
        this.elements.performanceInfo.textContent = `Resolution: ${info.resolution}`;
    }
}

// ====================================================================
// INTERACTION MANAGER CLASS
// ====================================================================
class InteractionManager {
    constructor(canvas, uiController) {
        this.canvas = canvas;
        this.ui = uiController;
        
        // State
        this.isDragging = false;
        this.dragPoint = null;
        this.startPos = { x: 0, y: 0 };
        this.longPressTimer = null;
        this.isLongPressing = false;
        this.lastTapTime = 0;
        this.lastTapPoint = null;
        
        // Elements
        this.indicator = document.getElementById('longPressIndicator');
        
        this.setupEvents();
    }
    
    setupEvents() {
        const options = { passive: false };
        this.canvas.addEventListener('touchstart', e => this.handleStart(e, e.touches[0]), options);
        this.canvas.addEventListener('touchmove', e => this.handleMove(e, e.touches[0]), options);
        this.canvas.addEventListener('touchend', e => this.handleEnd(e), options);
        this.canvas.addEventListener('mousedown', e => this.handleStart(e, e), options);
        this.canvas.addEventListener('mousemove', e => this.handleMove(e, e), options);
        this.canvas.addEventListener('mouseup', e => this.handleEnd(e), options);
        this.canvas.addEventListener('contextmenu', e => e.preventDefault());
    }
    
    getCoordinates(pointer) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        
        return {
            x: Math.floor((pointer.clientX - rect.left) * scaleX),
            y: Math.floor((pointer.clientY - rect.top) * scaleY)
        };
    }
    
    handleStart(event, pointer) {
        event.preventDefault();
        const coords = this.getCoordinates(pointer);
        this.startPos = coords;
        
        const hitPoint = this.ui.engine.findPointAt(coords.x, coords.y);
        const isMultiSelect = event.ctrlKey || event.shiftKey;
        
        if (hitPoint) {
            // Check for mobile multi-select (double-tap on existing point when points are visible)
            const currentTime = performance.now();
            const isDoubleTap = this.ui.animationManager.showPoints && 
                               this.lastTapPoint === hitPoint && 
                               (currentTime - this.lastTapTime) < 300;
            
            if (isDoubleTap) {
                Utils.showVisual(coords.x, coords.y, 'multi-select-indicator');
                this.ui.selectPoint(hitPoint.id, true);
                this.lastTapTime = 0;
                this.lastTapPoint = null;
            } else {
                this.ui.selectPoint(hitPoint.id, isMultiSelect);
                this.isDragging = true;
                this.dragPoint = hitPoint;
                this.canvas.style.cursor = 'grabbing';
                this.lastTapTime = currentTime;
                this.lastTapPoint = hitPoint;
            }
        } else {
            if (!isMultiSelect) {
                this.startLongPress(coords.x, coords.y);
                this.ui.deselectAll();
            }
            this.lastTapTime = 0;
            this.lastTapPoint = null;
        }
    }
    
    handleMove(event, pointer) {
        const coords = this.getCoordinates(pointer);
        const dist = Utils.distance(coords.x, coords.y, this.startPos.x, this.startPos.y);
        
        if (dist > 10) {
            this.cancelLongPress();
        }
        
        if (this.isDragging && this.dragPoint) {
            event.preventDefault();
            if (dist > 5) {
                // Move all selected points if dragging a selected point
                const selectedPoints = this.ui.getSelectedPoints();
                if (selectedPoints.includes(this.dragPoint)) {
                    const deltaX = coords.x - this.dragPoint.x;
                    const deltaY = coords.y - this.dragPoint.y;
                    
                    selectedPoints.forEach(point => {
                        point.x += deltaX;
                        point.y += deltaY;
                    });
                } else {
                    this.dragPoint.x = coords.x;
                    this.dragPoint.y = coords.y;
                }
                this.ui.animationManager.forceRender();
            }
        }
    }
    
    handleEnd(event) {
        if (this.isDragging) {
            event.preventDefault();
            this.isDragging = false;
            this.dragPoint = null;
            this.canvas.style.cursor = 'crosshair';
        }
        this.cancelLongPress();
    }
    
    startLongPress(x, y) {
        this.isLongPressing = true;
        
        if (this.indicator) {
            this.indicator.style.left = `${x}px`;
            this.indicator.style.top = `${y}px`;
            this.indicator.classList.add('active');
        }
        
        this.longPressTimer = setTimeout(() => {
            if (this.isLongPressing) {
                this.completeLongPress(x, y);
            }
        }, CONFIG.longPressDuration);
    }
    
    completeLongPress(x, y) {
        Utils.haptic();
        
        if (this.indicator) {
            this.indicator.classList.remove('active');
            this.indicator.classList.add('complete');
            setTimeout(() => this.indicator.classList.remove('complete'), 300);
        }
        
        this.ui.addPoint(x, y);
        this.cancelLongPress();
    }
    
    cancelLongPress() {
        if (this.longPressTimer) {
            clearTimeout(this.longPressTimer);
            this.longPressTimer = null;
        }
        this.isLongPressing = false;
        
        if (this.indicator) {
            this.indicator.classList.remove('active', 'complete');
        }
    }
    
    cleanup() {
        this.isDragging = false;
        this.dragPoint = null;
        this.canvas.style.cursor = 'crosshair';
        this.cancelLongPress();
    }
}

// ====================================================================
// MAIN WAVE SIMULATION CLASS
// ====================================================================
class WaveSimulation {
    constructor() {
        this.canvas = document.getElementById('canvas');
        
        // Initialize components
        this.engine = new WaveEngine();
        this.renderer = new Renderer(this.canvas);
        this.animationManager = new AnimationManager(this.renderer, this.engine);
        this.uiController = new UIController(this.engine, this.animationManager, this.renderer);
        this.interactionManager = new InteractionManager(this.canvas, this.uiController);
        
        console.log('Wave simulation initialized with refactored architecture');
    }
}

// ====================================================================
// INITIALIZATION
// ====================================================================
document.addEventListener('DOMContentLoaded', () => {
    try {
        new WaveSimulation();
    } catch (error) {
        console.error('Failed to initialize wave simulation:', error);
        document.body.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; height: 100vh; color: white; text-align: center; font-family: monospace;">
                <div>
                    <h2>Wave Simulation Error</h2>
                    <p>Failed to initialize application</p>
                    <p style="font-size: 12px; opacity: 0.7;">Check console for details</p>
                </div>
            </div>
        `;
    }
});
</script>
</body>
</html>