<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Wave Simulation - Point Editor</title>
<style>
:root {
    --bg-primary: rgba(20, 20, 20, 0.95);
    --bg-secondary: rgba(255, 255, 255, 0.05);
    --bg-button: rgba(255, 255, 255, 0.1);
    --bg-button-hover: rgba(255, 255, 255, 0.2);
    --bg-button-active: rgba(255, 255, 255, 0.3);
    --color-primary: #00ff88;
    --color-secondary: #0088ff;
    --color-danger: #ff4444;
    --color-warning: #ff9500;
    --text-primary: white;
    --border-primary: rgba(255, 255, 255, 0.1);
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    overflow: hidden;
    background: #000;
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    position: fixed;
}

#canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: #000;
    cursor: url("data:image/svg+xml,%3csvg width='20' height='20' xmlns='http://www.w3.org/2000/svg'%3e%3cline x1='10' y1='0' x2='10' y2='20' stroke='%2300ff88' stroke-width='2'/%3e%3cline x1='0' y1='10' x2='20' y2='10' stroke='%2300ff88' stroke-width='2'/%3e%3c/svg%3e") 10 10, crosshair;
    touch-action: none;
    display: block;
}

.visual-indicator {
    position: fixed;
    pointer-events: none;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    opacity: 0;
    z-index: 1000;
}

.long-press-indicator {
    width: 60px;
    height: 60px;
    border: 2px solid rgba(0, 255, 136, 0.6);
}

.long-press-indicator.active {
    animation: longPressGrow 0.5s ease-out forwards;
}

.long-press-indicator.complete {
    animation: fadeOut 0.3s ease-out forwards;
}

.clone-flash {
    width: 80px;
    height: 80px;
    border: 3px solid var(--color-secondary);
    animation: pulseOut 0.5s ease-out;
}

.snap-preview {
    width: 16px;
    height: 16px;
    border: 2px solid var(--color-secondary);
    background: rgba(0, 136, 255, 0.3);
    animation: snapPulse 0.5s ease-out infinite alternate;
}

.deletion-zone {
    position: fixed;
    pointer-events: none;
    z-index: 500;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.deletion-zone.active {
    opacity: 1;
}

.deletion-edge-top, .deletion-edge-bottom {
    left: 0;
    width: 100vw;
    height: 4px;
    background: linear-gradient(to bottom, rgba(255, 68, 68, 0.8), transparent);
    box-shadow: 0 0 10px rgba(255, 68, 68, 0.6);
}

.deletion-edge-top { top: 0; }
.deletion-edge-bottom { 
    bottom: 0; 
    background: linear-gradient(to top, rgba(255, 68, 68, 0.8), transparent);
}

.deletion-edge-left, .deletion-edge-right {
    top: 0;
    height: 100vh;
    width: 4px;
    background: linear-gradient(to right, rgba(255, 68, 68, 0.8), transparent);
    box-shadow: 0 0 10px rgba(255, 68, 68, 0.6);
}

.deletion-edge-left { left: 0; }
.deletion-edge-right { 
    right: 0;
    background: linear-gradient(to left, rgba(255, 68, 68, 0.8), transparent);
}

@keyframes longPressGrow {
    from { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
    to { opacity: 1; transform: translate(-50%, -50%) scale(1.2); border-color: var(--color-primary); box-shadow: 0 0 20px rgba(0, 255, 136, 0.6); }
}

@keyframes fadeOut {
    from { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
    to { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
}

@keyframes pulseOut {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    50% { opacity: 1; }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(2); }
}

.help-button {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 1000;
    width: 50px;
    height: 50px;
    background: var(--bg-button);
    backdrop-filter: blur(10px);
    border: 1px solid var(--border-primary);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: 0.3s ease;
    color: var(--text-primary);
    font-size: 20px;
    font-weight: 600;
}

.help-button:hover { background: var(--bg-button-hover); }

.menu-toggle {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1000;
    width: 50px;
    height: 50px;
    background: var(--bg-button);
    backdrop-filter: blur(10px);
    border: 1px solid var(--border-primary);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: 0.3s ease;
}

.menu-toggle:hover { background: var(--bg-button-hover); }

.menu-icon {
    width: 24px;
    height: 18px;
    position: relative;
}

.menu-icon span {
    display: block;
    width: 100%;
    height: 2px;
    background: var(--text-primary);
    margin: 4px 0;
    transition: 0.3s ease;
}

.menu-toggle.active .menu-icon span:nth-child(1) { transform: rotate(45deg) translate(5px, 5px); }
.menu-toggle.active .menu-icon span:nth-child(2) { opacity: 0; }
.menu-toggle.active .menu-icon span:nth-child(3) { transform: rotate(-45deg) translate(7px, -6px); }

.control-panel {
    position: fixed;
    top: 0;
    right: -360px;
    width: 360px;
    height: 95vh;
    background: var(--bg-primary);
    backdrop-filter: blur(20px);
    border-left: 1px solid var(--border-primary);
    z-index: 999;
    transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    overflow-y: auto;
    color: var(--text-primary);
}

.control-panel.open { right: 0; }

.panel-header {
    padding: 20px;
    border-bottom: 1px solid var(--border-primary);
}

.panel-title {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 5px;
}

.panel-subtitle {
    font-size: 12px;
    opacity: 0.7;
}

.control-section {
    padding: 20px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.section-title {
    font-size: 14px;
    font-weight: 500;
    margin-bottom: 15px;
    opacity: 0.9;
}

.control-group {
    margin-bottom: 20px;
}

.control-label {
    display: block;
    font-size: 12px;
    margin-bottom: 8px;
    opacity: 0.8;
}

.select-input {
    width: 100%;
    padding: 8px;
    background: var(--bg-button);
    border: 1px solid var(--border-primary);
    border-radius: 6px;
    color: var(--text-primary);
    font-size: 13px;
    cursor: pointer;
    transition: 0.2s ease;
}

.select-input:hover { background: var(--bg-button-hover); }
.select-input:focus { outline: none; border-color: var(--color-primary); }

.slider-container {
    position: relative;
}

.slider {
    width: 100%;
    height: 6px;
    background: var(--bg-button);
    border-radius: 3px;
    outline: none;
    appearance: none;
    -webkit-appearance: none;
}

.slider::-webkit-slider-thumb {
    appearance: none;
    -webkit-appearance: none;
    width: 20px;
    height: 20px;
    background: var(--text-primary);
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: var(--text-primary);
    border-radius: 50%;
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.slider-value {
    position: absolute;
    right: 0;
    top: -25px;
    font-size: 11px;
    background: var(--bg-button);
    padding: 2px 6px;
    border-radius: 3px;
    min-width: 35px;
    text-align: center;
    border: 1px solid var(--border-primary);
    color: var(--text-primary);
    cursor: pointer;
    transition: 0.2s ease;
}

.slider-value:hover {
    border-color: var(--color-primary);
}

.slider-value:focus {
    outline: none;
    border-color: var(--color-primary);
    box-shadow: 0 0 5px rgba(0, 255, 136, 0.3);
}

.button-group {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.control-button {
    flex: 1;
    min-width: 80px;
    padding: 12px 16px;
    background: var(--bg-button);
    border: 1px solid var(--border-primary);
    border-radius: 8px;
    color: var(--text-primary);
    font-size: 13px;
    cursor: pointer;
    transition: 0.2s ease;
}

.control-button:hover { background: var(--bg-button-hover); }
.control-button:active { transform: scale(0.98); }

.control-button.active {
    background: var(--bg-button-active);
    border-color: rgba(255, 255, 255, 0.5);
}

.control-button.primary {
    background: rgba(0, 255, 136, 0.2);
    border-color: rgba(0, 255, 136, 0.4);
}

.control-button.primary:hover { background: rgba(0, 255, 136, 0.3); }

.control-button.secondary {
    background: rgba(0, 136, 255, 0.2);
    border-color: rgba(0, 136, 255, 0.4);
}

.control-button.secondary:hover { background: rgba(0, 136, 255, 0.3); }

.control-button.danger {
    background: rgba(255, 68, 68, 0.2);
    border-color: rgba(255, 68, 68, 0.4);
}

.control-button.danger:hover { background: rgba(255, 68, 68, 0.3); }

.control-button.pattern {
    background: rgba(138, 43, 226, 0.2);
    border-color: rgba(138, 43, 226, 0.4);
}

.control-button.pattern:hover { background: rgba(138, 43, 226, 0.3); }

.toggle-button.active {
    background: rgba(0, 255, 136, 0.3);
    border-color: rgba(0, 255, 136, 0.6);
    box-shadow: 0 0 10px rgba(0, 255, 136, 0.2);
}

.toggle-switch {
    position: relative;
    width: 50px;
    height: 24px;
    background: var(--bg-button);
    border-radius: 12px;
    cursor: pointer;
    transition: background 0.3s ease;
    border: 1px solid var(--border-primary);
}

.toggle-switch.active {
    background: rgba(0, 255, 136, 0.3);
    border-color: rgba(0, 255, 136, 0.6);
}

.toggle-circle {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 18px;
    height: 18px;
    background: white;
    border-radius: 50%;
    transition: transform 0.3s ease;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.toggle-switch.active .toggle-circle {
    transform: translateX(26px);
}

.info-text {
    font-size: 11px;
    opacity: 0.6;
    margin-top: 10px;
}

.stats-text {
    font-size: 10px;
    opacity: 0.5;
    margin-top: 5px;
    font-family: monospace;
}

.point-section {
    background: var(--bg-secondary);
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
}

.point-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.point-id {
    font-size: 12px;
    opacity: 0.7;
    font-family: monospace;
}

.point-list {
    max-height: 200px;
    overflow-y: auto;
    border: 1px solid var(--border-primary);
    border-radius: 5px;
}

.point-item {
    padding: 8px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    cursor: pointer;
    transition: background 0.2s ease;
    font-size: 12px;
}

.point-item:hover { background: var(--bg-button); }
.point-item.selected { background: var(--bg-button-hover); }

.empty-state {
    text-align: center;
    opacity: 0.5;
    font-size: 12px;
    padding: 20px;
}

.panel-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.3);
    z-index: 998;
    opacity: 0;
    visibility: hidden;
    transition: 0.3s ease;
}

.panel-overlay.active {
    opacity: 1;
    visibility: visible;
}

.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(10px);
    z-index: 2000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
}

.modal {
    background: var(--bg-primary);
    backdrop-filter: blur(20px);
    border: 1px solid var(--border-primary);
    border-radius: 16px;
    max-width: 500px;
    width: 100%;
    color: var(--text-primary);
    overflow: hidden;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    max-height: 90vh;
    overflow-y: auto;
}

.modal-header {
    padding: 30px 30px 20px;
    text-align: center;
    border-bottom: 1px solid var(--border-primary);
}

.modal-header h2 {
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 8px;
}

.modal-header p {
    font-size: 14px;
    opacity: 0.7;
    margin: 0;
}

.modal-content {
    padding: 25px 30px;
}

.instruction-list {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.instruction-item {
    font-size: 14px;
    line-height: 1.5;
    padding: 12px 16px;
    background: var(--bg-secondary);
    border-radius: 8px;
    border-left: 3px solid rgba(255, 255, 255, 0.3);
}

.instruction-item strong {
    color: var(--color-primary);
    font-weight: 600;
}

.warning-item {
    border-left: 3px solid var(--color-warning);
}

.warning-item strong {
    color: var(--color-warning);
}

.modal-footer {
    padding: 20px 30px 30px;
    text-align: center;
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
}

.modal-button {
    background: linear-gradient(135deg, var(--color-primary), #00cc6a);
    border: none;
    border-radius: 12px;
    color: white;
    font-size: 16px;
    font-weight: 600;
    padding: 16px 32px;
    cursor: pointer;
    transition: 0.3s ease;
    box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
    margin: 0 5px;
}

.modal-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4);
}

.modal-button:active { transform: translateY(0); }

.modal-button.secondary {
    background: linear-gradient(135deg, var(--color-secondary), #0066cc);
    box-shadow: 0 4px 15px rgba(0, 136, 255, 0.3);
}

.modal-button.secondary:hover {
    box-shadow: 0 6px 20px rgba(0, 136, 255, 0.4);
}

.keyboard-shortcuts {
    display: grid;
    gap: 8px;
    margin: 15px 0;
}

.shortcut-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    background: var(--bg-secondary);
    border-radius: 6px;
    font-size: 12px;
}

.shortcut-key {
    background: var(--bg-button);
    padding: 4px 8px;
    border-radius: 4px;
    font-family: monospace;
    font-size: 11px;
}

.about-section {
    text-align: center;
    margin: 20px 0;
    padding: 15px;
    background: var(--bg-secondary);
    border-radius: 8px;
}

.about-section p {
    margin: 8px 0;
    font-size: 13px;
    line-height: 1.4;
}

.license-text {
    font-size: 11px;
    opacity: 0.6;
    margin-top: 15px;
    font-family: monospace;
}

@media (min-width: 768px) {
    .help-button, .menu-toggle {
        top: 30px;
        width: 60px;
        height: 60px;
    }
    
    .help-button {
        left: 30px;
    }
    
    .menu-toggle {
        right: 30px;
    }
    
    .control-panel {
        width: 400px;
        right: -400px;
    }
    
    .control-section {
        padding: 25px;
    }
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div class="visual-indicator long-press-indicator" id="longPressIndicator"></div>
<div class="visual-indicator snap-preview" id="snapPreview"></div>

<div class="deletion-zone deletion-edge-top" id="deletionTop"></div>
<div class="deletion-zone deletion-edge-bottom" id="deletionBottom"></div>
<div class="deletion-zone deletion-edge-left" id="deletionLeft"></div>
<div class="deletion-zone deletion-edge-right" id="deletionRight"></div>

<div class="modal-overlay" id="welcomeOverlay">
    <div class="modal">
        <div class="modal-header">
            <h2>Wave Physics Simulation</h2>
            <p>Interactive wave interference patterns</p>
        </div>
        <div class="modal-content">
            <div class="instruction-list">
                <div class="instruction-item">
                    <strong>Create waves:</strong> Press and hold on empty space to add wave sources
                </div>
                <div class="instruction-item">
                    <strong>Generate patterns:</strong> Use Pattern Generator for mathematical layouts
                </div>
                <div class="instruction-item">
                    <strong>Manipulate:</strong> Select, move, clone, and customize wave points
                </div>
                <div class="instruction-item">
                    <strong>Visualize:</strong> Watch interference patterns form in real-time
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="modal-button" id="welcomeStartBtn">Get Started</button>
        </div>
    </div>
</div>

<div class="modal-overlay" id="healthWarningOverlay" style="display: none;">
    <div class="modal">
        <div class="modal-header">
            <h2>Health & Safety Warning</h2>
            <p>Important information before you begin</p>
        </div>
        <div class="modal-content">
            <div class="instruction-list">
                <div class="instruction-item warning-item">
                    <strong>Photosensitive Epilepsy:</strong> This simulation contains flashing patterns and rapid visual changes that may trigger seizures in individuals with photosensitive epilepsy
                </div>
                <div class="instruction-item warning-item">
                    <strong>Motion Sensitivity:</strong> The dynamic wave patterns may cause discomfort for those sensitive to motion or visual effects
                </div>
                <div class="instruction-item">
                    <strong>Safe Usage:</strong> If you experience any discomfort, dizziness, or unusual symptoms, please stop using the simulation immediately
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="modal-button secondary" id="healthBackBtn">Go Back</button>
            <button class="modal-button" id="healthContinueBtn">I Understand, Continue</button>
        </div>
    </div>
</div>

<div class="modal-overlay" id="helpOverlay" style="display: none;">
    <div class="modal">
        <div class="modal-header">
            <h2>Help & Instructions</h2>
            <p>Complete guide to wave simulation</p>
        </div>
        <div class="modal-content">
            <div class="section-title">Basic Controls</div>
            <div class="instruction-list">
                <div class="instruction-item">
                    <strong>Add Point:</strong> Press and hold on empty space until indicator completes
                </div>
                <div class="instruction-item">
                    <strong>Select Point:</strong> Tap on wave point to select it
                </div>
                <div class="instruction-item">
                    <strong>Move Point:</strong> Drag selected point to new position
                </div>
                <div class="instruction-item">
                    <strong>Delete Point:</strong> Select point and use delete button or keyboard
                </div>
            </div>
            
            <div class="section-title">Keyboard Shortcuts</div>
            <div class="keyboard-shortcuts">
                <div class="shortcut-item">
                    <span>Delete selected point</span>
                    <span class="shortcut-key">Del / Backspace</span>
                </div>
                <div class="shortcut-item">
                    <span>Clone selected point</span>
                    <span class="shortcut-key">C</span>
                </div>
                <div class="shortcut-item">
                    <span>Close panels</span>
                    <span class="shortcut-key">Esc</span>
                </div>
            </div>
            
            <div class="section-title">Wave Properties</div>
            <div class="instruction-list">
                <div class="instruction-item">
                    <strong>Amplitude:</strong> Controls wave intensity (brightness/color)
                </div>
                <div class="instruction-item">
                    <strong>Wavelength:</strong> Distance between wave peaks
                </div>
                <div class="instruction-item">
                    <strong>Speed:</strong> How fast waves propagate outward
                </div>
                <div class="instruction-item">
                    <strong>Phase Offset:</strong> Creates time delays between points
                </div>
            </div>
            
            <div class="about-section">
                <p><strong>Wave Physics Simulation</strong></p>
                <p>Vibe coded during commute and coffee breaks by David Donelan</p>
                <p class="license-text">Released under MIT License<br>
                Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
            </div>
        </div>
        <div class="modal-footer">
            <button class="modal-button" id="helpCloseBtn">Close</button>
        </div>
    </div>
</div>

<button class="help-button" id="helpBtn">?</button>

<button class="menu-toggle" id="menuToggle">
    <div class="menu-icon">
        <span></span>
        <span></span>
        <span></span>
    </div>
</button>

<div class="panel-overlay" id="panelOverlay"></div>
<div class="control-panel" id="controlPanel">
    <div class="panel-header">
        <div class="panel-title">Wave Point Editor</div>
        <div class="panel-subtitle">Press and hold on canvas to add points</div>
    </div>
    
    <div class="control-section">
        <div class="section-title">Animation</div>
        <div class="button-group">
            <button class="control-button" id="syncBtn">Sync</button>
            <div class="control-group">
                <label class="control-label">Show Points</label>
                <div class="toggle-switch" id="showPointsToggle">
                    <div class="toggle-circle"></div>
                </div>
            </div>
            <div class="control-group">
                <label class="control-label">Show Grid</label>
                <div class="toggle-switch" id="showGridToggle">
                    <div class="toggle-circle"></div>
                </div>
            </div>
        </div>
        <div class="button-group" style="margin-top: 10px;">
            <button class="control-button toggle-button" id="playPauseBtn">Pause</button>
            <button class="control-button" id="clearBtn">Clear All</button>
        </div>
        <div class="info-text" id="stats">Points: 0</div>
    </div>
    
    <div class="control-section">
        <div class="section-title">Pattern Generator</div>
        <div class="control-group">
            <label class="control-label">Pattern Type</label>
            <select id="patternType" class="select-input">
                <option value="grid">Grid</option>
                <option value="radial">Radial</option>
                <option value="spiral">Spiral</option>
                <option value="sunflower">Sunflower</option>
            </select>
        </div>
        <div class="control-group">
            <label class="control-label">Number of Points</label>
            <div class="slider-container">
                <input type="range" class="slider" id="patternCount" min="3" max="36" step="1" value="16">
                <input type="number" class="slider-value" id="patternCountValue" min="3" max="36" value="16">
            </div>
        </div>
        <div class="control-group">
            <label class="control-label">Pattern Scale</label>
            <div class="slider-container">
                <input type="range" class="slider" id="patternScale" min="0.3" max="2.0" step="0.1" value="1.0">
                <input type="number" class="slider-value" id="patternScaleValue" min="0.3" max="2.0" step="0.1" value="1.0">
            </div>
        </div>
        <div class="button-group">
            <button class="control-button pattern" id="generatePatternBtn">Add Pattern</button>
        </div>
        <div class="info-text">Adds to existing points (max 36 total)</div>
    </div>
    
    <div class="control-section">
        <div class="section-title">Point List</div>
        <div class="point-list" id="pointList">
            <div class="empty-state">No points created</div>
        </div>
    </div>
    
    <div class="control-section" id="selectedPointSection" style="display: none;">
        <div class="section-title">
            <span id="editModeIndicator">Selected Point</span>
            <div class="control-group" style="margin-top: 10px;">
                <label class="control-label">
                    <input type="checkbox" id="singleEditMode" style="margin-right: 8px;">
                    Edit Selected Only
                </label>
            </div>
        </div>
        <div class="point-section">
            <div class="point-header">
                <span class="point-id" id="selectedPointId">Point #1</span>
            </div>
            
            <div class="control-group">
                <label class="control-label">Wave Type</label>
                <div class="toggle-switch" id="pointWaveTypeToggle">
                    <div class="toggle-circle"></div>
                </div>
                <div class="info-text">Sine wave (on) / Digital wave (off)</div>
            </div>
            
            <div class="control-group">
                <label class="control-label">Amplitude</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="pointAmplitude" min="10" max="100" step="5" value="60">
                    <input type="number" class="slider-value" id="pointAmplitudeValue" min="10" max="100" value="60">
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label">Wavelength</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="pointWavelength" min="20" max="400" step="10" value="100">
                    <input type="number" class="slider-value" id="pointWavelengthValue" min="20" max="400" value="100">
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label">Propagation Speed</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="pointSpeed" min="0.1" max="1.0" step="0.1" value="1.0">
                    <input type="number" class="slider-value" id="pointSpeedValue" min="0.1" max="1.0" step="0.1" value="1.0">
                </div>
            </div>
            
            <div class="button-group">
                <button class="control-button secondary" id="clonePointBtn">Clone Point</button>
                <button class="control-button danger" id="deletePointBtn">Delete Point</button>
            </div>
        </div>
    </div>
    
    <div class="control-section">
        <div class="section-title">Medium</div>
        
        <div class="control-group">
            <label class="control-label">Color Mode</label>
            <div class="toggle-switch" id="colorToggle">
                <div class="toggle-circle"></div>
            </div>
        </div>
        
        <div class="control-group" id="colorControls" style="display: none;">
            <label class="control-label">Minima Color (Hue)</label>
            <div class="slider-container">
                <input type="range" class="slider" id="hue1Slider" min="0" max="360" step="1" value="185">
                <input type="number" class="slider-value" id="hue1Value" min="0" max="360" value="185">
            </div>
        </div>
        
        <div class="control-group" id="colorControls2" style="display: none;">
            <label class="control-label">Maxima Color (Hue)</label>
            <div class="slider-container">
                <input type="range" class="slider" id="hue2Slider" min="0" max="360" step="1" value="285">
                <input type="number" class="slider-value" id="hue2Value" min="0" max="360" value="285">
            </div>
        </div>
        
        <div class="control-group" id="colorPreview" style="display: none;">
            <label class="control-label">Color Preview</label>
            <div id="gradientPreview" style="width: 100%; height: 20px; border-radius: 4px; background: linear-gradient(to right, hsl(185, 70%, 50%), hsl(285, 70%, 50%)); border: 1px solid rgba(255, 255, 255, 0.2);"></div>
        </div>
        
        <div class="control-group">
            <label class="control-label">Point Phase Offset</label>
            <div class="slider-container">
                <input type="range" class="slider" id="pointPhaseOffsetSlider" min="-2" max="2" step="0.1" value="0">
                <input type="number" class="slider-value" id="pointPhaseOffsetValue" min="-2" max="2" step="0.1" value="0">
            </div>
        </div>
        
        <div class="control-group">
            <label class="control-label">Damping</label>
            <div class="slider-container">
                <input type="range" class="slider" id="dampingSlider" min="0.0" max="0.03" step="0.002" value="0.008">
                <input type="number" class="slider-value" id="dampingValue" min="0.0" max="0.03" step="0.002" value="0.008">
            </div>
        </div>
        
        <div class="control-group">
            <label class="control-label">Resolution</label>
            <div class="slider-container">
                <input type="range" class="slider" id="performanceSlider" min="0" max="5" step="1" value="2">
                <input type="number" class="slider-value" id="performanceValue" min="0" max="5" value="2">
            </div>
            <div class="stats-text" id="performanceInfo">Resolution: calculating...</div>
        </div>
    </div>
</div>

<script>
'use strict';

// ====================================================================
// CONFIGURATION
// ====================================================================
const CONFIG = {
    maxPoints: 36,
    pointVisualRadius: 12,
    pointHitRadius: 25,
    pointBorderWidth: 2,
    longPressDuration: 500,
    frameInterval: 20, // 50fps
    minPointDistance: 40,
    
    defaults: {
        amplitude: 60,
        wavelength: 100,
        speed: 1.0,
        waveType: 'sine',
        performanceLevel: 2, // Fast
        damping: 0.008,
        showPoints: false
    },
    
    ranges: {
        amplitude: { min: 10, max: 100, mid: 55 },
        wavelength: { min: 20, max: 400, mid: 210 },
        speed: { min: 0.1, max: 1.0, mid: 0.55 },
        hue1: { min: 0, max: 360, mid: 180 },
        hue2: { min: 0, max: 360, mid: 180 },
        phaseOffset: { min: -2, max: 2, mid: 0 },
        damping: { min: 0.0, max: 0.03, mid: 0.015 },
        performance: { min: 0, max: 5, mid: 3 },
        patternCount: { min: 3, max: 36, mid: 20 },
        patternScale: { min: 0.3, max: 2.0, mid: 1.15 }
    },
    
    performanceLevels: [
        { skip: 1, label: 'Quality' },
        { skip: 2, label: 'Balanced' },
        { skip: 4, label: 'Fast' },
        { skip: 8, label: 'Faster' },
        { skip: 16, label: 'Very Fast' },
        { skip: 32, label: 'Ultra Fast' }
    ],
    
    patterns: {
        grid: 'Grid',
        radial: 'Radial', 
        spiral: 'Spiral',
        sunflower: 'Sunflower'
    }
};

// ====================================================================
// UTILITY FUNCTIONS
// ====================================================================
const Utils = {
    clamp: (val, min, max) => Math.max(min, Math.min(max, val)),
    distance: (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2),
    formatValue: (val, decimals = 3) => Number(val).toFixed(decimals),
    generateId: () => `point_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    
    haptic: () => {
        if ('vibrate' in navigator) navigator.vibrate(10);
    },
    
    showVisual: (x, y, className, duration = 500) => {
        const element = document.createElement('div');
        element.className = `visual-indicator ${className}`;
        element.style.left = `${x}px`;
        element.style.top = `${y}px`;
        document.body.appendChild(element);
        setTimeout(() => element.remove(), duration);
    },
    
    snapToGrid: (x, y, gridSpacing) => {
        return {
            x: Math.round(x / gridSpacing) * gridSpacing,
            y: Math.round(y / gridSpacing) * gridSpacing
        };
    },
    
    formatPiMultiplier: (value) => {
        if (value === 0) return '0';
        if (value === 1) return 'π';
        if (value === -1) return '-π';
        if (value % 1 === 0) return `${value}π`;
        return `${Utils.formatValue(value, 1)}π`;
    },
    
    // Fixed: Added missing formatInputValue function
    formatInputValue: (value, fieldType) => {
        switch (fieldType) {
            case 'amplitude':
            case 'wavelength':
            case 'patternCount':
            case 'performance':
            case 'hue1':
            case 'hue2':
                return Math.round(value).toString();
            case 'damping':
                return Utils.formatValue(value, 3); // Show 3 decimal places for damping
            case 'speed':
            case 'patternScale':
            case 'phaseOffset':
                return Utils.formatValue(value, 1);
            default:
                return value.toString();
        }
    },
    
    validateNumericInput: (value, fieldType) => {
        const range = CONFIG.ranges[fieldType];
        if (!range) return value;
        
        // Convert to number and check if valid
        const numValue = parseFloat(value);
        
        // Invalid input (NaN, empty, etc.) - use mid value
        if (isNaN(numValue) || value === '' || value === null || value === undefined) {
            return range.mid;
        }
        
        // Out of range - clamp to min/max
        if (numValue < range.min) return range.min;
        if (numValue > range.max) return range.max;
        
        // Valid input within range
        return numValue;
    }
};

// ====================================================================
// WAVE POINT CLASS
// ====================================================================
class WavePoint {
    constructor(x, y, properties = {}) {
        this.id = Utils.generateId();
        this.x = x;
        this.y = y;
        this.startTime = 0;
        this.selected = false;
        this.amplitude = properties.amplitude || CONFIG.defaults.amplitude;
        this.wavelength = properties.wavelength || CONFIG.defaults.wavelength;
        this.speed = properties.speed || CONFIG.defaults.speed;
        this.waveType = properties.waveType || CONFIG.defaults.waveType;
        this.phaseOffset = properties.phaseOffset || 0;
        this.creationIndex = properties.creationIndex || 0;
    }
    
    getProperties() {
        return {
            amplitude: this.amplitude,
            wavelength: this.wavelength,
            speed: this.speed,
            waveType: this.waveType,
            phaseOffset: this.phaseOffset
        };
    }
    
    distanceTo(x, y) {
        return Utils.distance(this.x, this.y, x, y);
    }
    
    isHit(x, y) {
        return this.distanceTo(x, y) <= CONFIG.pointHitRadius;
    }
    
    getDisplayName() {
        return `Point ${this.id.split('_')[1].slice(-3)}`;
    }
    
    get frequency() {
        return (2 * Math.PI) / this.wavelength;
    }
}

// ====================================================================
// PATTERN GENERATOR
// ====================================================================
class PatternGenerator {
    static generate(type, count, bounds, scale = 1.0) {
        const cx = bounds.width / 2;
        const cy = bounds.height / 2;
        const maxRadius = (Math.min(bounds.width, bounds.height) / 2 - 50) * scale;
        
        switch (type) {
            case 'grid': return this.generateGrid(count, cx, cy, maxRadius);
            case 'radial': return this.generateRadial(count, cx, cy, maxRadius);
            case 'spiral': return this.generateSpiral(count, cx, cy, maxRadius);
            case 'sunflower': return this.generateSunflower(count, cx, cy, maxRadius);
            default: return [];
        }
    }
    
    static generateGrid(count, cx, cy, maxRadius) {
        const points = [];
        const gridSize = Math.ceil(Math.sqrt(count));
        const spacing = (maxRadius * 2) / (gridSize + 1);
        const startX = cx - (gridSize - 1) * spacing / 2;
        const startY = cy - (gridSize - 1) * spacing / 2;
        
        for (let i = 0; i < gridSize * gridSize && points.length < count; i++) {
            const row = Math.floor(i / gridSize);
            const col = i % gridSize;
            points.push({
                x: startX + col * spacing,
                y: startY + row * spacing
            });
        }
        return points;
    }
    
    static generateRadial(count, cx, cy, maxRadius) {
        const points = [];
        const rings = Math.min(4, Math.ceil(count / 8));
        const pointsPerRing = Math.ceil(count / rings);
        
        for (let ring = 0; ring < rings; ring++) {
            const radius = ((ring + 1) / rings) * maxRadius;
            const ringCount = Math.min(pointsPerRing, count - points.length);
            
            for (let i = 0; i < ringCount; i++) {
                const angle = (i / ringCount) * 2 * Math.PI - Math.PI / 2;
                points.push({
                    x: cx + radius * Math.cos(angle),
                    y: cy + radius * Math.sin(angle)
                });
            }
        }
        return points;
    }
    
    static generateSpiral(count, cx, cy, maxRadius) {
        const points = [];
        const maxAngle = 4 * Math.PI;
        
        for (let i = 0; i < count; i++) {
            const t = (i / count) * maxAngle;
            const radius = (t / maxAngle) * maxRadius;
            points.push({
                x: cx + radius * Math.cos(t),
                y: cy + radius * Math.sin(t)
            });
        }
        return points;
    }
    
    static generateSunflower(count, cx, cy, maxRadius) {
        const points = [];
        const golden = Math.PI * (3 - Math.sqrt(5));
        
        for (let i = 0; i < count; i++) {
            const theta = i * golden;
            const radius = Math.sqrt(i / count) * maxRadius;
            points.push({
                x: cx + radius * Math.cos(theta),
                y: cy + radius * Math.sin(theta)
            });
        }
        return points;
    }
    
    static findRandomPosition(existingPoints, bounds) {
        const margin = 30;
        const minDist = CONFIG.minPointDistance;
        const maxAttempts = 50;
        
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            const x = margin + Math.random() * (bounds.width - 2 * margin);
            const y = margin + Math.random() * (bounds.height - 2 * margin);
            
            const tooClose = existingPoints.some(point => 
                Utils.distance(x, y, point.x, point.y) < minDist
            );
            
            if (!tooClose) return { x, y };
        }
        
        return {
            x: margin + Math.random() * (bounds.width - 2 * margin),
            y: margin + Math.random() * (bounds.height - 2 * margin)
        };
    }
}

// ====================================================================
// WAVE ENGINE CLASS
// ====================================================================
class WaveEngine {
    constructor() {
        this.points = new Map();
        this.time = 0;
        this.pointPhaseOffset = 0;
        this.mediumDamping = CONFIG.defaults.damping;
        this.creationCounter = 0;
        this.hue1 = 185; // Default hues 
        this.hue2 = 285;
        this.useColor = false;
    }
    
    addPoint(x, y, properties = {}) {
        if (this.points.size >= CONFIG.maxPoints) {
            Utils.haptic();
            return null;
        }
        
        const point = new WavePoint(x, y, { 
            ...properties, 
            creationIndex: this.creationCounter++,
            phaseOffset: this.pointPhaseOffset * (this.creationCounter - 1)
        });
        point.startTime = this.time;
        this.points.set(point.id, point);
        return point;
    }
    
    removePoint(id) {
        return this.points.delete(id);
    }
    
    getPoint(id) {
        return this.points.get(id);
    }
    
    getAllPoints() {
        return Array.from(this.points.values());
    }
    
    findPointAt(x, y) {
        for (const point of this.points.values()) {
            if (point.isHit(x, y)) return point;
        }
        return null;
    }
    
    clearAll() {
        this.points.clear();
        this.time = 0;
        this.creationCounter = 0;
    }
    
    syncPoints() {
        this.time = 0;
        this.pointPhaseOffset = 0;
        
        for (const point of this.points.values()) {
            point.startTime = 0;
            point.phaseOffset = 0;
        }
    }
    
    applyPointPhaseOffsets() {
        const points = this.getAllPoints().sort((a, b) => a.creationIndex - b.creationIndex);
        points.forEach((point, index) => {
            point.phaseOffset = this.pointPhaseOffset * index;
        });
    }
    
    calculatePixel(x, y) {
        let totalWave = 0;
        
        for (const point of this.points.values()) {
            const age = this.time - point.startTime;
            if (age < 0) continue;
            
            const dist = point.distanceTo(x, y);
            const phase = point.frequency * dist - point.speed * age + point.phaseOffset;
            
            let waveValue;
            if (point.waveType === 'sine') {
                waveValue = point.amplitude * Math.sin(phase);
            } else {
                const normalized = ((phase % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
                waveValue = point.amplitude * (normalized < Math.PI ? 1 : -1);
            }
            
            waveValue *= Math.exp(-dist * this.mediumDamping);
            totalWave += waveValue;
        }
        
        return this.waveToColor(totalWave);
    }
    
    waveToColor(waveValue) {
        if (!this.useColor) {
            const normalized = waveValue / 100;
            return Utils.clamp(128 + normalized * 127, 0, 255);
        }
        
        const normalizedValue = Utils.clamp((waveValue / 100 + 1) / 2, 0, 1);
        const interpolatedHue = this.lerpHue(this.hue1, this.hue2, normalizedValue);
        return this.hslToRgb(interpolatedHue, 70, 50);
    }
    
    lerpHue(hue1, hue2, t) {
        let diff = Math.abs(hue1 - hue2);
        if (diff > 180) {
            if (hue2 > hue1) hue1 += 360;
            else hue2 += 360;
        }
        return Math.round((hue1 + (hue2 - hue1) * t) % 360);
    }
    
    hslToRgb(h, s, l) {
        h /= 360;
        s /= 100;
        l /= 100;
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h * 6) % 2 - 1));
        const m = l - c / 2;
        
        let r, g, b;
        if (h < 1/6) [r, g, b] = [c, x, 0];
        else if (h < 2/6) [r, g, b] = [x, c, 0];
        else if (h < 3/6) [r, g, b] = [0, c, x];
        else if (h < 4/6) [r, g, b] = [0, x, c];
        else if (h < 5/6) [r, g, b] = [x, 0, c];
        else [r, g, b] = [c, 0, x];
        
        return {
            r: Math.round((r + m) * 255),
            g: Math.round((g + m) * 255),
            b: Math.round((b + m) * 255)
        };
    }
    
    updateTime(deltaTime) {
        this.time += deltaTime;
    }
    
    setColorMode(enabled) {
        this.useColor = enabled;
    }
    
    setColors(hue1, hue2) {
        this.hue1 = hue1;
        this.hue2 = hue2;
    }
    
    setHues(hue1, hue2) {
        this.hue1 = hue1;
        this.hue2 = hue2;
    }
    
    setPointPhaseOffset(offset) {
        this.pointPhaseOffset = offset;
        this.applyPointPhaseOffsets();
    }
    
    setDamping(damping) {
        this.mediumDamping = damping;
    }
}

// ====================================================================
// RENDERER CLASS
// ====================================================================
class Renderer {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.imageData = null;
        this.skipFactor = CONFIG.performanceLevels[CONFIG.defaults.performanceLevel].skip;
        this.resize();
    }
    
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
    }
    
    setPerformanceLevel(level) {
        this.skipFactor = CONFIG.performanceLevels[level].skip;
    }
    
    render(engine, showPoints, showGrid, selectedPoint) {
        this.clearCanvas();
        if (engine.points.size > 0) {
            this.renderWaveField(engine);
        }
        this.ctx.putImageData(this.imageData, 0, 0);
        if (showGrid) {
            this.renderGrid(engine);
        }
        this.renderPoints(engine.getAllPoints(), showPoints, selectedPoint);
    }
    
    clearCanvas() {
        const data = this.imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            data[i] = data[i + 1] = data[i + 2] = 0;
            data[i + 3] = 255;
        }
    }
    
    renderWaveField(engine) {
        const { width, height } = this.canvas;
        const skip = this.skipFactor;
        
        for (let y = 0; y < height; y += skip) {
            for (let x = 0; x < width; x += skip) {
                const color = engine.calculatePixel(x, y);
                this.fillBlock(x, y, color, skip);
            }
        }
    }
    
    fillBlock(startX, startY, color, size) {
        const data = this.imageData.data;
        const { width, height } = this.canvas;
        
        for (let dy = 0; dy < size && startY + dy < height; dy++) {
            for (let dx = 0; dx < size && startX + dx < width; dx++) {
                const index = ((startY + dy) * width + (startX + dx)) * 4;
                
                if (typeof color === 'object') {
                    data[index] = color.r;
                    data[index + 1] = color.g;
                    data[index + 2] = color.b;
                } else {
                    data[index] = data[index + 1] = data[index + 2] = color;
                }
            }
        }
    }
    
    renderGrid(engine) {
        const { width, height } = this.canvas;
        const gridSpacing = this.skipFactor * 10; // Grid spacing proportional to performance level
        
        // Adaptive opacity: brighter when fewer points exist
        const baseOpacity = 0.2 + (0.3 * (1 - engine.points.size / CONFIG.maxPoints));
        this.ctx.strokeStyle = `rgba(255, 255, 255, ${baseOpacity})`;
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        
        // Vertical lines
        for (let x = gridSpacing; x < width; x += gridSpacing) {
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, height);
        }
        
        // Horizontal lines
        for (let y = gridSpacing; y < height; y += gridSpacing) {
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(width, y);
        }
        
        this.ctx.stroke();
    }
    
    renderPoints(allPoints, showPoints, selectedPoint) {
        if (showPoints) {
            allPoints.forEach(point => this.drawPoint(point));
        } else if (selectedPoint) {
            this.drawPoint(selectedPoint);
        }
    }
    
    drawPoint(point) {
        const visualRadius = CONFIG.pointVisualRadius;
        const hitRadius = CONFIG.pointHitRadius;
        const borderWidth = CONFIG.pointBorderWidth;
        
        if (point.selected) {
            this.ctx.strokeStyle = '#00ff88';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(point.x, point.y, hitRadius, 0, 2 * Math.PI);
            this.ctx.stroke();
        }
        
        // Calculate deletion countdown visual feedback
        let deletionProgress = 0;
        let finalRadius = visualRadius;
        let pointColor = 'white';
        
        if (point.inDeletionZone && point.deletionTimer) {
            const elapsed = performance.now() - point.deletionTimer;
            deletionProgress = Math.min(elapsed / 1000, 1); // 1 second timer
            
            // Point gets redder and larger as deletion approaches
            const redIntensity = Math.floor(255 * deletionProgress);
            const whiteIntensity = Math.floor(255 * (1 - deletionProgress));
            pointColor = `rgb(255, ${whiteIntensity}, ${whiteIntensity})`;
            finalRadius = visualRadius + (deletionProgress * 4); // Grow up to 4px larger
        } else if (point.inDeletionZone) {
            pointColor = '#ff4444'; // Static red when in zone but no timer
        }
        
        // Draw border (dark outline)
        this.ctx.fillStyle = '#333333';
        this.ctx.beginPath();
        this.ctx.arc(point.x, point.y, finalRadius + borderWidth, 0, 2 * Math.PI);
        this.ctx.fill();
        
        // Draw main dot with countdown feedback
        this.ctx.fillStyle = pointColor;
        this.ctx.beginPath();
        this.ctx.arc(point.x, point.y, finalRadius, 0, 2 * Math.PI);
        this.ctx.fill();
    }
    
    getPerformanceInfo() {
        const config = CONFIG.performanceLevels.find(level => level.skip === this.skipFactor);
        const width = Math.floor(window.innerWidth / this.skipFactor);
        const height = Math.floor(window.innerHeight / this.skipFactor);
        const speedup = this.skipFactor === 1 ? '' : ` (${this.skipFactor ** 2}x faster)`;
        
        return {
            label: config.label,
            resolution: `${width}×${height}${speedup}`
        };
    }
}

// ====================================================================
// ANIMATION MANAGER CLASS
// ====================================================================
class AnimationManager {
    constructor(renderer, engine) {
        this.renderer = renderer;
        this.engine = engine;
        this.isAnimating = false;
        this.animationId = null;
        this.lastFrameTime = 0;
        this.frameInterval = CONFIG.frameInterval;
        this.showPoints = CONFIG.defaults.showPoints;
        this.showGrid = false;
        this.selectedPoint = null;
    }
    
    start() {
        if (this.isAnimating) return;
        
        this.isAnimating = true;
        this.lastFrameTime = performance.now();
        this.animate();
    }
    
    stop() {
        this.isAnimating = false;
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
    }
    
    toggle() {
        this.isAnimating ? this.stop() : this.start();
    }
    
    animate() {
        const currentTime = performance.now();
        
        if (this.isAnimating && (currentTime - this.lastFrameTime) >= this.frameInterval) {
            this.engine.updateTime(0.2);
            this.renderer.render(this.engine, this.showPoints, this.showGrid, this.selectedPoint);
            this.lastFrameTime = currentTime;
        }
        
        if (this.isAnimating) {
            this.animationId = requestAnimationFrame(() => this.animate());
        }
    }
    
    setShowPoints(show) {
        this.showPoints = show;
        this.renderer.render(this.engine, this.showPoints, this.showGrid, this.selectedPoint);
    }
    
    setShowGrid(show) {
        this.showGrid = show;
        this.renderer.render(this.engine, this.showPoints, this.showGrid, this.selectedPoint);
    }
    
    setSelectedPoint(point) {
        this.selectedPoint = point;
        this.renderer.render(this.engine, this.showPoints, this.showGrid, this.selectedPoint);
    }
    
    forceRender() {
        this.renderer.render(this.engine, this.showPoints, this.showGrid, this.selectedPoint);
    }
}

// ====================================================================
// INPUT CONTROLLER CLASS - NEW: Simplified input handling
// ====================================================================
class InputController {
    constructor() {
        this.handlers = new Map();
    }
    
    registerSliderPair(sliderId, inputId, handler) {
        const slider = document.getElementById(sliderId);
        const input = document.getElementById(inputId);
        
        if (!slider || !input) return;
        
        const fieldType = this.getFieldType(sliderId);
        
        // Slider updates input and calls handler
        slider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            input.value = this.formatDisplayValue(value, fieldType);
            handler(value);
        });
        
        // Input updates slider and calls handler
        input.addEventListener('input', (e) => {
            const rawValue = e.target.value;
            const numValue = parseFloat(rawValue);
            
            if (!isNaN(numValue)) {
                const validValue = Utils.validateNumericInput(numValue, fieldType);
                slider.value = validValue;
                handler(validValue);
            }
        });
        
        // Validate on blur
        input.addEventListener('blur', (e) => {
            const rawValue = e.target.value;
            const validValue = Utils.validateNumericInput(rawValue, fieldType);
            slider.value = validValue;
            input.value = this.formatDisplayValue(validValue, fieldType);
            handler(validValue);
        });
    }
    
    getFieldType(id) {
        const fieldMap = {
            'pointAmplitude': 'amplitude',
            'pointWavelength': 'wavelength',
            'pointSpeed': 'speed',
            'hue1Slider': 'hue1',
            'hue2Slider': 'hue2',
            'pointPhaseOffsetSlider': 'phaseOffset',
            'dampingSlider': 'damping',
            'performanceSlider': 'performance',
            'patternCount': 'patternCount',
            'patternScale': 'patternScale'
        };
        return fieldMap[id] || id;
    }
    
    formatDisplayValue(value, fieldType) {
        return Utils.formatInputValue(value, fieldType);
    }
    
    updatePair(sliderId, inputId, value) {
        const slider = document.getElementById(sliderId);
        const input = document.getElementById(inputId);
        const fieldType = this.getFieldType(sliderId);
        
        if (slider) slider.value = value;
        if (input) input.value = this.formatDisplayValue(value, fieldType);
    }
}

// ====================================================================
// UI CONTROLLER CLASS - REFACTORED
// ====================================================================
class UIController {
    constructor(engine, animationManager, renderer) {
        this.engine = engine;
        this.animationManager = animationManager;
        this.renderer = renderer;
        this.selectedPointId = null; // Single selection only
        this.panelOpen = false;
        this.singleEditMode = false; // New: track edit mode
        this.elements = this.cacheElements();
        this.inputController = new InputController();
        this.setupEventListeners();
        this.setupInputControls();
        this.updatePerformanceInfo();
    }
    
    cacheElements() {
        const ids = [
            'helpBtn', 'menuToggle', 'panelOverlay', 'controlPanel',
            'welcomeOverlay', 'welcomeStartBtn', 'healthWarningOverlay',
            'healthBackBtn', 'healthContinueBtn', 'helpOverlay', 'helpCloseBtn',
            'clearBtn', 'playPauseBtn', 'syncBtn', 'showPointsToggle', 'showGridToggle',
            'generatePatternBtn', 'pointWaveTypeToggle', 'clonePointBtn',
            'deletePointBtn', 'colorToggle', 'singleEditMode',
            'pointList', 'selectedPointSection', 'selectedPointId', 'editModeIndicator',
            'stats', 'colorControls', 'colorControls2', 'colorPreview', 'performanceInfo'
        ];
        
        const elements = {};
        ids.forEach(id => {
            elements[id] = document.getElementById(id);
        });
        return elements;
    }
    
    setupEventListeners() {
        // Modal management
        this.elements.welcomeStartBtn.addEventListener('click', () => this.showHealthWarning());
        this.elements.healthBackBtn.addEventListener('click', () => this.showWelcome());
        this.elements.healthContinueBtn.addEventListener('click', () => this.startApp());
        this.elements.helpBtn.addEventListener('click', () => this.showHelp());
        this.elements.helpCloseBtn.addEventListener('click', () => this.hideHelp());
        
        // Panel management
        this.elements.menuToggle.addEventListener('click', () => this.togglePanel());
        this.elements.panelOverlay.addEventListener('click', () => this.closePanel());
        
        // Control buttons
        this.elements.clearBtn.addEventListener('click', () => this.clearAll());
        this.elements.playPauseBtn.addEventListener('click', () => this.toggleAnimation());
        this.elements.syncBtn.addEventListener('click', () => this.syncPoints());
        this.elements.showPointsToggle.addEventListener('click', () => this.toggleShowPoints());
        this.elements.showGridToggle.addEventListener('click', () => this.toggleShowGrid());
        this.elements.generatePatternBtn.addEventListener('click', () => this.generatePattern());
        this.elements.pointWaveTypeToggle.addEventListener('click', () => this.toggleWaveType());
        this.elements.clonePointBtn.addEventListener('click', () => this.clonePoint());
        this.elements.deletePointBtn.addEventListener('click', () => this.deletePoint());
        this.elements.colorToggle.addEventListener('click', () => this.toggleColorMode());
        this.elements.singleEditMode.addEventListener('change', (e) => this.setSingleEditMode(e.target.checked));
        
        // Point list
        this.elements.pointList.addEventListener('click', (e) => {
            const item = e.target.closest('.point-item');
            if (item) {
                this.selectPoint(item.dataset.id);
            }
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => this.handleKeyboard(e));
        
        // Window events
        window.addEventListener('resize', () => {
            this.renderer.resize();
            this.updatePerformanceInfo();
        });
    }
    
    setupInputControls() {
        // Point property sliders
        this.inputController.registerSliderPair('pointAmplitude', 'pointAmplitudeValue', 
            (v) => this.updatePointProperty('amplitude', parseInt(v)));
        this.inputController.registerSliderPair('pointWavelength', 'pointWavelengthValue', 
            (v) => this.updatePointProperty('wavelength', parseInt(v)));
        this.inputController.registerSliderPair('pointSpeed', 'pointSpeedValue', 
            (v) => this.updatePointProperty('speed', parseFloat(v)));
        
        // Color sliders
        this.inputController.registerSliderPair('hue1Slider', 'hue1Value', (v) => {
            this.engine.hue1 = parseInt(v);
            this.updateColorPreview();
            this.animationManager.forceRender();
        });
        this.inputController.registerSliderPair('hue2Slider', 'hue2Value', (v) => {
            this.engine.hue2 = parseInt(v);
            this.updateColorPreview();
            this.animationManager.forceRender();
        });
        
        // Medium controls
        this.inputController.registerSliderPair('pointPhaseOffsetSlider', 'pointPhaseOffsetValue', (v) => {
            this.engine.setPointPhaseOffset(parseFloat(v) * Math.PI);
        });
        this.inputController.registerSliderPair('dampingSlider', 'dampingValue', (v) => {
            this.engine.setDamping(parseFloat(v));
        });
        this.inputController.registerSliderPair('performanceSlider', 'performanceValue', (v) => {
            this.setPerformanceLevel(parseInt(v));
        });
        
        // Pattern generator sliders
        this.inputController.registerSliderPair('patternCount', 'patternCountValue', () => {});
        this.inputController.registerSliderPair('patternScale', 'patternScaleValue', () => {});
        
        // Initialize all input displays with current slider values
        this.initializeInputDisplays();
    }
    
    // Modal methods
    showWelcome() {
        this.elements.welcomeOverlay.style.display = 'flex';
        this.elements.healthWarningOverlay.style.display = 'none';
    }
    
    showHealthWarning() {
        this.elements.welcomeOverlay.style.display = 'none';
        this.elements.healthWarningOverlay.style.display = 'flex';
    }
    
    startApp() {
        this.elements.healthWarningOverlay.style.display = 'none';
        this.createStarterPoint();
    }
    
    showHelp() {
        this.elements.helpOverlay.style.display = 'flex';
    }
    
    hideHelp() {
        this.elements.helpOverlay.style.display = 'none';
    }
    
    // Panel methods
    togglePanel() {
        this.panelOpen ? this.closePanel() : this.openPanel();
    }
    
    openPanel() {
        this.panelOpen = true;
        this.elements.controlPanel.classList.add('open');
        this.elements.panelOverlay.classList.add('active');
        this.elements.menuToggle.classList.add('active');
    }
    
    closePanel() {
        this.panelOpen = false;
        this.elements.controlPanel.classList.remove('open');
        this.elements.panelOverlay.classList.remove('active');
        this.elements.menuToggle.classList.remove('active');
    }
    
    // Point management - SIMPLIFIED: Single selection only
    selectPoint(id) {
        // Deselect previous
        if (this.selectedPointId) {
            const prevPoint = this.engine.getPoint(this.selectedPointId);
            if (prevPoint) prevPoint.selected = false;
        }
        
        // Select new
        this.selectedPointId = id;
        const point = this.engine.getPoint(id);
        if (point) {
            point.selected = true;
        }
        
        this.updateSelectedPointUI();
        this.updatePointsUI();
        this.animationManager.setSelectedPoint(point);
    }
    
    deselectAll() {
        if (this.selectedPointId) {
            const point = this.engine.getPoint(this.selectedPointId);
            if (point) point.selected = false;
        }
        this.selectedPointId = null;
        this.singleEditMode = false; // Reset single edit mode when deselecting
        this.elements.singleEditMode.checked = false;
        this.updateSelectedPointUI();
        this.updatePointsUI();
        this.animationManager.setSelectedPoint(null);
    }
    
    getSelectedPoint() {
        return this.selectedPointId ? this.engine.getPoint(this.selectedPointId) : null;
    }
    
    // Action methods
    clearAll() {
        this.engine.clearAll();
        this.selectedPointId = null;
        this.animationManager.stop();
        this.animationManager.setShowPoints(false);
        this.animationManager.setShowGrid(false);
        this.updatePointsUI();
        this.updateSelectedPointUI();
        this.updateButton('showPointsToggle', false);
        this.updateButton('showGridToggle', false);
        this.updateButton('playPauseBtn', true, 'Play', 'Pause');
        this.animationManager.forceRender();
    }
    
    createStarterPoint() {
        const cx = Math.floor(window.innerWidth / 2);
        const cy = Math.floor(window.innerHeight / 2);
        const point = this.engine.addPoint(cx, cy);
        if (point) {
            this.selectPoint(point.id);
            this.animationManager.start();
            this.updatePointsUI();
            this.updateButton('playPauseBtn', false, 'Play', 'Pause');
        }
    }
    
    addPoint(x, y, properties = {}) {
        const point = this.engine.addPoint(x, y, properties);
        if (point) {
            this.selectPoint(point.id);
            if (!this.animationManager.isAnimating && this.engine.points.size > 0) {
                this.animationManager.start();
                this.updateButton('playPauseBtn', false, 'Play', 'Pause');
            }
            this.updatePointsUI();
        }
        return point;
    }
    
    removePoint(id) {
        if (this.selectedPointId === id) {
            this.selectedPointId = null;
        }
        this.engine.removePoint(id);
        this.updatePointsUI();
        this.updateSelectedPointUI();
        this.animationManager.setSelectedPoint(null);
        
        if (this.engine.points.size === 0) {
            this.animationManager.stop();
            this.updateButton('playPauseBtn', true, 'Play', 'Pause');
        }
    }
    
    generatePattern() {
        const type = document.getElementById('patternType').value;
        const count = parseInt(document.getElementById('patternCount').value);
        const scale = parseFloat(document.getElementById('patternScale').value);
        
        const currentCount = this.engine.points.size;
        const availableSlots = CONFIG.maxPoints - currentCount;
        
        if (availableSlots <= 0) {
            Utils.haptic();
            return;
        }
        
        const actualCount = Math.min(count, availableSlots);
        const bounds = { width: window.innerWidth, height: window.innerHeight };
        const positions = PatternGenerator.generate(type, actualCount, bounds, scale);
        
        let firstNewPoint = null;
        positions.forEach((pos, index) => {
            // Apply grid snapping if grid is visible
            let finalX = pos.x, finalY = pos.y;
            if (this.animationManager.showGrid) {
                const gridSpacing = this.renderer.skipFactor * 10;
                const snapped = Utils.snapToGrid(pos.x, pos.y, gridSpacing);
                finalX = snapped.x;
                finalY = snapped.y;
            }
            
            const point = this.engine.addPoint(finalX, finalY, {
                creationIndex: this.engine.creationCounter++,
                phaseOffset: this.engine.pointPhaseOffset * (this.engine.creationCounter - 1)
            });
            if (point) {
                point.startTime = this.engine.time - (index * 0.1);
                if (!firstNewPoint) firstNewPoint = point;
            }
        });
        
        if (firstNewPoint) {
            this.selectPoint(firstNewPoint.id);
            this.animationManager.setShowPoints(true);
            this.updateButton('showPointsToggle', true);
            if (!this.animationManager.isAnimating) {
                this.animationManager.start();
                this.updateButton('playPauseBtn', false, 'Play', 'Pause');
            }
        }
        
        this.updatePointsUI();
        Utils.haptic();
    }
    
    clonePoint() {
        const selectedPoint = this.getSelectedPoint();
        if (!selectedPoint) return;
        
        const bounds = { width: window.innerWidth, height: window.innerHeight };
        const pos = PatternGenerator.findRandomPosition(this.engine.getAllPoints(), bounds);
        
        // Apply grid snapping if grid is visible
        let finalX = pos.x, finalY = pos.y;
        if (this.animationManager.showGrid) {
            const gridSpacing = this.renderer.skipFactor * 10;
            const snapped = Utils.snapToGrid(pos.x, pos.y, gridSpacing);
            finalX = snapped.x;
            finalY = snapped.y;
        }
        
        const clone = this.engine.addPoint(finalX, finalY, {
            ...selectedPoint.getProperties(),
            creationIndex: this.engine.creationCounter++,
            phaseOffset: this.engine.pointPhaseOffset * (this.engine.creationCounter - 1)
        });
        
        if (clone) {
            clone.startTime = this.engine.time;
            this.selectPoint(clone.id);
            Utils.showVisual(finalX, finalY, 'clone-flash');
            
            if (!this.animationManager.isAnimating) {
                this.animationManager.start();
                this.updateButton('playPauseBtn', false, 'Play', 'Pause');
            }
        }
        
        this.updatePointsUI();
        Utils.haptic();
    }
    
    deletePoint() {
        const selectedPoint = this.getSelectedPoint();
        if (selectedPoint) {
            this.removePoint(selectedPoint.id);
        }
    }
    
    toggleWaveType() {
        if (this.singleEditMode) {
            // Single edit mode: only update selected point
            const selectedPoint = this.getSelectedPoint();
            if (selectedPoint) {
                selectedPoint.waveType = selectedPoint.waveType === 'sine' ? 'step' : 'sine';
                this.updateSelectedPointUI();
                this.updatePointsUI();
            }
        } else {
            // Bulk edit mode: update all points
            const waveTypeToggle = document.getElementById('pointWaveTypeToggle');
            const newWaveType = waveTypeToggle.classList.contains('active') ? 'step' : 'sine';
            for (const point of this.engine.getAllPoints()) {
                point.waveType = newWaveType;
            }
            this.updatePointsUI();
        }
    }
    
    updatePointProperty(property, value) {
        if (this.singleEditMode) {
            // Single edit mode: only update selected point
            const selectedPoint = this.getSelectedPoint();
            if (selectedPoint) {
                selectedPoint[property] = value;
                this.updatePointsUI();
            }
        } else {
            // Bulk edit mode: update all points
            for (const point of this.engine.getAllPoints()) {
                point[property] = value;
            }
            this.updatePointsUI();
        }
    }
    
    applyToAllPoints() {
        // This function is obsolete with single/bulk edit mode system
        // Functionality is now handled by the default bulk edit mode
    }
    
    syncPoints() {
        if (this.engine.points.size === 0) return;
        
        this.engine.syncPoints();
        this.inputController.updatePair('pointPhaseOffsetSlider', 'pointPhaseOffsetValue', 0);
        
        if (!this.animationManager.isAnimating) {
            this.animationManager.start();
            this.updateButton('playPauseBtn', false, 'Play', 'Pause');
        }
        
        this.animationManager.forceRender();
    }
    
    toggleAnimation() {
        this.animationManager.toggle();
        this.updateButton('playPauseBtn', !this.animationManager.isAnimating, 'Play', 'Pause');
    }
    
    toggleShowPoints() {
        const newState = !this.animationManager.showPoints;
        this.animationManager.setShowPoints(newState);
        this.updateButton('showPointsToggle', newState);
    }
    
    toggleShowGrid() {
        const newState = !this.animationManager.showGrid;
        this.animationManager.setShowGrid(newState);
        this.updateButton('showGridToggle', newState);
    }
    
    toggleColorMode() {
        const newState = !this.engine.useColor;
        this.engine.setColorMode(newState);
        this.updateButton('colorToggle', newState);
        this.updateColorControls();
        this.animationManager.forceRender();
    }
    
    updateColorPreview() {
        const preview = document.getElementById('gradientPreview');
        if (preview) {
            preview.style.background = `linear-gradient(to right, hsl(${this.engine.hue1}, 70%, 50%), hsl(${this.engine.hue2}, 70%, 50%))`;
        }
    }
    
    setPerformanceLevel(level) {
        this.renderer.setPerformanceLevel(level);
        this.updatePerformanceInfo();
    }
    
    handleKeyboard(e) {
        if (e.key === 'Escape' && this.panelOpen) {
            this.closePanel();
        }
        
        const selectedPoint = this.getSelectedPoint();
        if (selectedPoint) {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                e.preventDefault();
                this.deletePoint();
            } else if (e.key === 'c' || e.key === 'C') {
                e.preventDefault();
                this.clonePoint();
            }
        }
    }
    
    // UI update methods
    updateButton(elementId, isActive, activeText = null, inactiveText = null) {
        const element = typeof elementId === 'string' ? this.elements[elementId] : elementId;
        if (!element) return;
        
        element.classList.toggle('active', isActive);
        if (activeText && inactiveText) {
            element.textContent = isActive ? activeText : inactiveText;
        }
    }
    
    updateColorControls() {
        const controls = ['colorControls', 'colorControls2', 'colorPreview'];
        controls.forEach(id => {
            const element = document.getElementById(id);
            if (element) element.style.display = this.engine.useColor ? 'block' : 'none';
        });
        
        if (this.engine.useColor) {
            this.updateColorPreview();
        }
    }
    
    updatePointsUI() {
        const count = this.engine.points.size;
        this.elements.stats.textContent = `Points: ${count}/${CONFIG.maxPoints}`;
        
        if (count === 0) {
            this.elements.pointList.innerHTML = '<div class="empty-state">No points created</div>';
        } else {
            this.elements.pointList.innerHTML = this.engine.getAllPoints().map(point => `
                <div class="point-item ${point.selected ? 'selected' : ''}" data-id="${point.id}">
                    ${point.getDisplayName()} - ${point.waveType} (${point.amplitude})
                </div>
            `).join('');
        }
    }
    
    updateSelectedPointUI() {
        const selectedPoint = this.getSelectedPoint();
        this.elements.selectedPointSection.style.display = selectedPoint ? 'block' : 'none';
        
        if (!selectedPoint) return;
        
        this.elements.selectedPointId.textContent = selectedPoint.getDisplayName();
        
        // Update edit mode indicator
        this.updateEditModeIndicator();
        
        // Update controls to match selected point (in single edit mode) or show average (in bulk edit mode)
        if (this.singleEditMode) {
            // Show selected point's properties
            this.inputController.updatePair('pointAmplitude', 'pointAmplitudeValue', selectedPoint.amplitude);
            this.inputController.updatePair('pointWavelength', 'pointWavelengthValue', selectedPoint.wavelength);
            this.inputController.updatePair('pointSpeed', 'pointSpeedValue', selectedPoint.speed);
            this.updateButton('pointWaveTypeToggle', selectedPoint.waveType === 'sine');
        } else {
            // Show average values of all points
            const allPoints = this.engine.getAllPoints();
            if (allPoints.length > 0) {
                const avgAmplitude = Math.round(allPoints.reduce((sum, p) => sum + p.amplitude, 0) / allPoints.length);
                const avgWavelength = Math.round(allPoints.reduce((sum, p) => sum + p.wavelength, 0) / allPoints.length);
                const avgSpeed = allPoints.reduce((sum, p) => sum + p.speed, 0) / allPoints.length;
                
                this.inputController.updatePair('pointAmplitude', 'pointAmplitudeValue', avgAmplitude);
                this.inputController.updatePair('pointWavelength', 'pointWavelengthValue', avgWavelength);
                this.inputController.updatePair('pointSpeed', 'pointSpeedValue', avgSpeed);
                
                // Show wave type toggle based on majority
                const sineCount = allPoints.filter(p => p.waveType === 'sine').length;
                this.updateButton('pointWaveTypeToggle', sineCount > allPoints.length / 2);
            }
        }
    }
    
    updatePerformanceInfo() {
        const info = this.renderer.getPerformanceInfo();
        this.elements.performanceInfo.textContent = `Resolution: ${info.resolution}`;
    }
    
    setSingleEditMode(enabled) {
        this.singleEditMode = enabled;
        this.updateEditModeIndicator();
    }
    
    updateEditModeIndicator() {
        const selectedPoint = this.getSelectedPoint();
        if (selectedPoint) {
            if (this.singleEditMode) {
                this.elements.editModeIndicator.textContent = `Editing: ${selectedPoint.getDisplayName()}`;
            } else {
                this.elements.editModeIndicator.textContent = `Editing: All Points (${this.engine.points.size} total)`;
            }
        }
    }
    
    initializeInputDisplays() {
        // Initialize all input fields with their slider's current values
        const sliderPairs = [
            ['pointAmplitude', 'pointAmplitudeValue'],
            ['pointWavelength', 'pointWavelengthValue'],
            ['pointSpeed', 'pointSpeedValue'],
            ['hue1Slider', 'hue1Value'],
            ['hue2Slider', 'hue2Value'],
            ['pointPhaseOffsetSlider', 'pointPhaseOffsetValue'],
            ['dampingSlider', 'dampingValue'],
            ['performanceSlider', 'performanceValue'],
            ['patternCount', 'patternCountValue'],
            ['patternScale', 'patternScaleValue']
        ];
        
        sliderPairs.forEach(([sliderId, inputId]) => {
            const slider = document.getElementById(sliderId);
            const input = document.getElementById(inputId);
            if (slider && input) {
                const fieldType = this.inputController.getFieldType(sliderId);
                const value = parseFloat(slider.value);
                input.value = Utils.formatInputValue(value, fieldType);
            }
        });
    }
}

// ====================================================================
// INTERACTION MANAGER CLASS - SIMPLIFIED
// ====================================================================
class InteractionManager {
    constructor(canvas, uiController) {
        this.canvas = canvas;
        this.ui = uiController;
        
        // State
        this.isDragging = false;
        this.dragPoint = null;
        this.startPos = { x: 0, y: 0 };
        this.longPressTimer = null;
        this.isLongPressing = false;
        this.inDeletionZone = false;
        this.deletionTimer = null;
        this.deletionDuration = 500; // 1/2 second
        
        // Elements
        this.indicator = document.getElementById('longPressIndicator');
        this.snapPreview = document.getElementById('snapPreview');
        this.deletionZones = {
            top: document.getElementById('deletionTop'),
            bottom: document.getElementById('deletionBottom'),
            left: document.getElementById('deletionLeft'),
            right: document.getElementById('deletionRight')
        };
        
        this.setupEvents();
    }
    
    setupEvents() {
        const options = { passive: false };
        this.canvas.addEventListener('touchstart', e => this.handleStart(e, e.touches[0]), options);
        this.canvas.addEventListener('touchmove', e => this.handleMove(e, e.touches[0]), options);
        this.canvas.addEventListener('touchend', e => this.handleEnd(e), options);
        this.canvas.addEventListener('mousedown', e => this.handleStart(e, e), options);
        this.canvas.addEventListener('mousemove', e => this.handleMove(e, e), options);
        this.canvas.addEventListener('mouseup', e => this.handleEnd(e), options);
        this.canvas.addEventListener('contextmenu', e => e.preventDefault());
    }
    
    getCoordinates(pointer) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        
        return {
            x: Math.floor((pointer.clientX - rect.left) * scaleX),
            y: Math.floor((pointer.clientY - rect.top) * scaleY)
        };
    }
    
    handleStart(event, pointer) {
        event.preventDefault();
        const coords = this.getCoordinates(pointer);
        this.startPos = coords;
        
        const hitPoint = this.ui.engine.findPointAt(coords.x, coords.y);
        
        if (hitPoint) {
            // SIMPLIFIED: Just select and start dragging
            this.ui.selectPoint(hitPoint.id);
            this.isDragging = true;
            this.dragPoint = hitPoint;
            this.canvas.style.cursor = 'grabbing';
        } else {
            // SIMPLIFIED: Just deselect and start long press
            this.startLongPress(coords.x, coords.y);
            this.ui.deselectAll();
        }
    }
    
    handleMove(event, pointer) {
        const coords = this.getCoordinates(pointer);
        const dist = Utils.distance(coords.x, coords.y, this.startPos.x, this.startPos.y);
        
        if (dist > 10) {
            this.cancelLongPress();
        }
        
        if (this.isDragging && this.dragPoint) {
            event.preventDefault();
            if (dist > 5) {
                let finalX = coords.x;
                let finalY = coords.y;
                
                // Apply grid snapping during drag if grid is visible
                if (this.ui.animationManager.showGrid) {
                    const gridSpacing = this.ui.renderer.skipFactor * 10;
                    const snapped = Utils.snapToGrid(coords.x, coords.y, gridSpacing);
                    finalX = snapped.x;
                    finalY = snapped.y;
                }
                
                // Check for deletion zone (50px from edge)
                const deletionMargin = 50;
                const inDeletionZone = (
                    finalX < deletionMargin || 
                    finalX > this.canvas.width - deletionMargin ||
                    finalY < deletionMargin || 
                    finalY > this.canvas.height - deletionMargin
                );
                
                // Update deletion zone visual feedback
                if (inDeletionZone !== this.inDeletionZone) {
                    this.inDeletionZone = inDeletionZone;
                    this.updateDeletionZoneVisuals(inDeletionZone);
                    
                    // Start deletion timer when entering zone
                    if (inDeletionZone && !this.deletionTimer) {
                        this.startDeletionTimer();
                    }
                    
                    // Cancel deletion timer when leaving zone
                    if (!inDeletionZone && this.deletionTimer) {
                        this.cancelDeletionTimer();
                    }
                }
                
                // Update point color for deletion feedback
                this.dragPoint.inDeletionZone = inDeletionZone;
                
                this.dragPoint.x = finalX;
                this.dragPoint.y = finalY;
                this.ui.animationManager.forceRender();
            }
        }
    }
    
    handleEnd(event) {
        if (this.isDragging) {
            event.preventDefault();
            
            // Cancel any pending deletion timer
            this.cancelDeletionTimer();
            
            // Clear deletion zone flag
            if (this.dragPoint) {
                this.dragPoint.inDeletionZone = false;
            }
            
            this.isDragging = false;
            this.dragPoint = null;
            this.canvas.style.cursor = 'crosshair';
            
            // Hide deletion zone visuals
            this.updateDeletionZoneVisuals(false);
            this.inDeletionZone = false;
        }
        this.cancelLongPress();
    }
    
    startLongPress(x, y) {
        this.isLongPressing = true;
        
        if (this.indicator) {
            this.indicator.style.left = `${x}px`;
            this.indicator.style.top = `${y}px`;
            this.indicator.classList.add('active');
        }
        
        // Show snap preview if grid is visible
        if (this.ui.animationManager.showGrid && this.snapPreview) {
            const gridSpacing = this.ui.renderer.skipFactor * 10;
            const snapped = Utils.snapToGrid(x, y, gridSpacing);
            this.snapPreview.style.left = `${snapped.x}px`;
            this.snapPreview.style.top = `${snapped.y}px`;
            this.snapPreview.style.opacity = '1';
        }
        
        this.longPressTimer = setTimeout(() => {
            if (this.isLongPressing) {
                this.completeLongPress(x, y);
            }
        }, CONFIG.longPressDuration);
    }
    
    completeLongPress(x, y) {
        Utils.haptic();
        
        if (this.indicator) {
            this.indicator.classList.remove('active');
            this.indicator.classList.add('complete');
            setTimeout(() => this.indicator.classList.remove('complete'), 300);
        }
        
        // Use snapped coordinates if grid is visible
        let finalX = x, finalY = y;
        if (this.ui.animationManager.showGrid) {
            const gridSpacing = this.ui.renderer.skipFactor * 10;
            const snapped = Utils.snapToGrid(x, y, gridSpacing);
            finalX = snapped.x;
            finalY = snapped.y;
        }
        
        this.ui.addPoint(finalX, finalY);
        this.cancelLongPress();
    }
    
    cancelLongPress() {
        if (this.longPressTimer) {
            clearTimeout(this.longPressTimer);
            this.longPressTimer = null;
        }
        this.isLongPressing = false;
        
        if (this.indicator) {
            this.indicator.classList.remove('active', 'complete');
        }
        
        if (this.snapPreview) {
            this.snapPreview.style.opacity = '0';
        }
    }
    
    cleanup() {
        this.isDragging = false;
        this.dragPoint = null;
        this.canvas.style.cursor = 'crosshair';
        this.cancelLongPress();
        this.cancelDeletionTimer();
        this.updateDeletionZoneVisuals(false);
    }
    
    updateDeletionZoneVisuals(active) {
        Object.values(this.deletionZones).forEach(zone => {
            if (zone) {
                zone.classList.toggle('active', active);
            }
        });
    }
    
    startDeletionTimer() {
        if (this.deletionTimer) return; // Prevent multiple timers
        
        this.deletionTimer = setTimeout(() => {
            if (this.dragPoint && this.isDragging) {
                Utils.haptic();
                this.ui.removePoint(this.dragPoint.id);
                
                // Clean up drag state
                this.isDragging = false;
                this.dragPoint = null;
                this.canvas.style.cursor = 'crosshair';
                this.updateDeletionZoneVisuals(false);
                this.inDeletionZone = false;
            }
            this.deletionTimer = null;
        }, this.deletionDuration);
        
        // Add visual countdown feedback to point
        if (this.dragPoint) {
            this.dragPoint.deletionTimer = performance.now();
        }
    }
    
    cancelDeletionTimer() {
        if (this.deletionTimer) {
            clearTimeout(this.deletionTimer);
            this.deletionTimer = null;
        }
        
        // Clear visual countdown feedback
        if (this.dragPoint) {
            this.dragPoint.deletionTimer = null;
        }
    }
}

// ====================================================================
// MAIN WAVE SIMULATION CLASS
// ====================================================================
class WaveSimulation {
    constructor() {
        this.canvas = document.getElementById('canvas');
        
        // Initialize components
        this.engine = new WaveEngine();
        this.renderer = new Renderer(this.canvas);
        this.animationManager = new AnimationManager(this.renderer, this.engine);
        this.uiController = new UIController(this.engine, this.animationManager, this.renderer);
        this.interactionManager = new InteractionManager(this.canvas, this.uiController);
        
        console.log('Wave simulation initialized - refactored version');
    }
}

// ====================================================================
// INITIALIZATION
// ====================================================================
document.addEventListener('DOMContentLoaded', () => {
    try {
        new WaveSimulation();
    } catch (error) {
        console.error('Failed to initialize wave simulation:', error);
        document.body.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; height: 100vh; color: white; text-align: center; font-family: monospace;">
                <div>
                    <h2>Wave Simulation Error</h2>
                    <p>Failed to initialize application</p>
                    <p style="font-size: 12px; opacity: 0.7;">Check console for details</p>
                </div>
            </div>
        `;
    }
});
</script>
</body>
</html>
