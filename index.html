<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Wave Simulation - Bottom Sheet UI</title>
<style>
:root {
    --bg-primary: rgba(20, 20, 20, 0.95);
    --bg-secondary: rgba(255, 255, 255, 0.05);
    --bg-button: rgba(255, 255, 255, 0.1);
    --bg-button-hover: rgba(255, 255, 255, 0.2);
    --bg-button-active: rgba(255, 255, 255, 0.3);
    --color-primary: #00ff88;
    --color-secondary: #0088ff;
    --color-danger: #ff4444;
    --color-warning: #ff9500;
    --color-accent: #8a2be2;
    --text-primary: white;
    --border-primary: rgba(255, 255, 255, 0.1);
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    overflow: hidden;
    background: #000;
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    position: fixed;
}

#canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: #000;
    cursor: url("data:image/svg+xml,%3csvg width='20' height='20' xmlns='http://www.w3.org/2000/svg'%3e%3cline x1='10' y1='0' x2='10' y2='20' stroke='%2300ff88' stroke-width='2'/%3e%3cline x1='0' y1='10' x2='20' y2='10' stroke='%2300ff88' stroke-width='2'/%3e%3c/svg%3e") 10 10, crosshair;
    touch-action: none;
    display: block;
}

.visual-indicator {
    position: fixed;
    pointer-events: none;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    opacity: 0;
    z-index: 1000;
}

.long-press-indicator {
    width: 60px;
    height: 60px;
    border: 2px solid rgba(0, 255, 136, 0.6);
}

.long-press-indicator.active {
    animation: longPressGrow 0.5s ease-out forwards;
}

.long-press-indicator.complete {
    animation: fadeOut 0.3s ease-out forwards;
}

.clone-flash {
    width: 80px;
    height: 80px;
    border: 3px solid var(--color-secondary);
    animation: pulseOut 0.5s ease-out;
}

.deletion-zone {
    position: fixed;
    pointer-events: none;
    z-index: 500;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.deletion-zone.active { opacity: 1; }

.deletion-edge-top, .deletion-edge-bottom {
    left: 0; width: 100vw; height: 4px;
    background: linear-gradient(to bottom, rgba(255, 68, 68, 0.8), transparent);
    box-shadow: 0 0 10px rgba(255, 68, 68, 0.6);
}

.deletion-edge-top { top: 0; }
.deletion-edge-bottom { 
    bottom: 0; 
    background: linear-gradient(to top, rgba(255, 68, 68, 0.8), transparent);
}

.deletion-edge-left, .deletion-edge-right {
    top: 0; height: 100vh; width: 4px;
    background: linear-gradient(to right, rgba(255, 68, 68, 0.8), transparent);
    box-shadow: 0 0 10px rgba(255, 68, 68, 0.6);
}

.deletion-edge-left { left: 0; }
.deletion-edge-right { 
    right: 0;
    background: linear-gradient(to left, rgba(255, 68, 68, 0.8), transparent);
}

@keyframes longPressGrow {
    from { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
    to { opacity: 1; transform: translate(-50%, -50%) scale(1.2); border-color: var(--color-primary); box-shadow: 0 0 20px rgba(0, 255, 136, 0.6); }
}

@keyframes fadeOut {
    from { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
    to { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
}

@keyframes pulseOut {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    50% { opacity: 1; }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(2); }
}

/* Floating Action Buttons */
.help-button {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 1000;
    width: 56px;
    height: 56px;
    background: var(--bg-primary);
    backdrop-filter: blur(20px);
    border: 1px solid var(--border-primary);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: 0.3s ease;
    color: var(--text-primary);
    font-size: 20px;
    font-weight: 600;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.help-button:hover { 
    background: var(--bg-button-hover);
    transform: translateY(-2px);
    box-shadow: 0 6px 25px rgba(0, 0, 0, 0.4);
}

.add-button {
    position: fixed;
    bottom: 80px;
    right: 20px;
    z-index: 900;
    width: 56px;
    height: 56px;
    background: linear-gradient(135deg, var(--color-primary), #00cc6a);
    border: none;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: 0.3s ease;
    color: white;
    font-size: 24px;
    font-weight: 300;
    box-shadow: 0 4px 20px rgba(0, 255, 136, 0.4);
}

.add-button:hover { 
    transform: translateY(-2px);
    box-shadow: 0 6px 25px rgba(0, 255, 136, 0.5);
}

.add-button:active { 
    transform: translateY(0);
}

/* Bottom Sheet */
.bottom-sheet {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 70vh;
    background: var(--bg-primary);
    backdrop-filter: blur(20px);
    border-top: 1px solid var(--border-primary);
    border-radius: 16px 16px 0 0;
    z-index: 999;
    transform: translateY(calc(100% - 40px));
    transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 0 -4px 30px rgba(0, 0, 0, 0.5);
}

.bottom-sheet.expanded {
    transform: translateY(0);
}

.sheet-handle {
    width: 40px;
    height: 4px;
    background: rgba(255, 255, 255, 0.3);
    border-radius: 2px;
    margin: 16px auto 0;
    cursor: pointer;
    transition: 0.2s ease;
}

.sheet-handle:hover {
    background: rgba(255, 255, 255, 0.5);
}

.sheet-header {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px 24px 0;
    border-bottom: 1px solid var(--border-primary);
    color: var(--text-primary);
}

.panel-title {
    font-size: 18px;
    font-weight: 600;
    color: var(--color-primary);
    text-align: center;
    margin-bottom: 16px;
}

.panel-navigation {
    width: 100%;
    height: 16px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    margin-bottom: 20px;
    position: relative;
    overflow: hidden;
    display: flex;
}

.nav-segment {
    flex: 1;
    height: 100%;
    cursor: pointer;
    transition: background 0.2s ease;
    position: relative;
}

.nav-segment:not(:last-child)::after {
    content: '';
    position: absolute;
    right: 0;
    top: 2px;
    bottom: 2px;
    width: 0.5px;
    background: rgba(255, 255, 255, 0.2);
}

.nav-segment.active {
    background: var(--color-primary);
    box-shadow: 0 0 8px rgba(0, 255, 136, 0.3);
}

.nav-segment:hover:not(.active) {
    background: rgba(255, 255, 255, 0.1);
}

.sheet-content {
    flex: 1;
    overflow: hidden;
    position: relative;
}

.panels-container {
    display: flex;
    height: 100%;
    overflow-x: auto;
    overflow-y: hidden;
    scroll-snap-type: x mandatory;
    scroll-behavior: smooth;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.panels-container::-webkit-scrollbar {
    display: none;
}

.panel {
    min-width: 100%;
    width: 100%;
    height: 100%;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    padding: 20px 24px 24px;
    scroll-snap-align: start;
    scroll-snap-stop: always;
}

.control-section {
    margin-bottom: 32px;
}

.section-title {
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 16px;
    color: var(--text-primary);
    opacity: 0.9;
}

.control-group {
    margin-bottom: 20px;
}

.control-label {
    display: block;
    font-size: 12px;
    margin-bottom: 8px;
    opacity: 0.8;
    color: var(--text-primary);
}

.button-group {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
}

.control-button {
    flex: 1;
    min-width: 100px;
    padding: 12px 16px;
    background: var(--bg-button);
    border: 1px solid var(--border-primary);
    border-radius: 8px;
    color: var(--text-primary);
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: 0.2s ease;
}

.control-button:hover { background: var(--bg-button-hover); }
.control-button:active { transform: scale(0.98); }

.control-button.primary {
    background: rgba(0, 255, 136, 0.2);
    border-color: rgba(0, 255, 136, 0.4);
}

.control-button.primary:hover { background: rgba(0, 255, 136, 0.3); }

.control-button.danger {
    background: rgba(255, 68, 68, 0.2);
    border-color: rgba(255, 68, 68, 0.4);
}

.control-button.danger:hover { background: rgba(255, 68, 68, 0.3); }

.control-button.secondary {
    background: rgba(0, 136, 255, 0.2);
    border-color: rgba(0, 136, 255, 0.4);
}

.control-button.secondary:hover { background: rgba(0, 136, 255, 0.3); }

.control-button.pattern {
    background: rgba(138, 43, 226, 0.2);
    border-color: rgba(138, 43, 226, 0.4);
}

.control-button.pattern:hover { background: rgba(138, 43, 226, 0.3); }

.toggle-row {
    display: flex;
    gap: 20px;
    align-items: center;
}

.toggle-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
    flex: 1;
}

.toggle-switch {
    position: relative;
    width: 50px;
    height: 24px;
    background: var(--bg-button);
    border-radius: 12px;
    cursor: pointer;
    transition: background 0.3s ease;
    border: 1px solid var(--border-primary);
}

.toggle-switch.active {
    background: rgba(0, 255, 136, 0.3);
    border-color: rgba(0, 255, 136, 0.6);
}

.toggle-circle {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 18px;
    height: 18px;
    background: white;
    border-radius: 50%;
    transition: transform 0.3s ease;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.toggle-switch.active .toggle-circle {
    transform: translateX(26px);
}

.slider-container {
    position: relative;
    margin: 12px 0;
}

.slider {
    width: 100%;
    height: 6px;
    background: var(--bg-button);
    border-radius: 3px;
    outline: none;
    appearance: none;
    -webkit-appearance: none;
}

.slider::-webkit-slider-thumb {
    appearance: none;
    -webkit-appearance: none;
    width: 20px;
    height: 20px;
    background: var(--text-primary);
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: var(--text-primary);
    border-radius: 50%;
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.slider-value {
    position: absolute;
    right: 0;
    top: -28px;
    font-size: 11px;
    background: var(--bg-button);
    padding: 4px 8px;
    border-radius: 4px;
    min-width: 40px;
    text-align: center;
    border: 1px solid var(--border-primary);
    color: var(--text-primary);
    cursor: pointer;
    transition: 0.2s ease;
}

.slider-value:hover {
    border-color: var(--color-primary);
}

.slider-value:focus {
    outline: none;
    border-color: var(--color-primary);
    box-shadow: 0 0 5px rgba(0, 255, 136, 0.3);
}

.select-input {
    width: 100%;
    padding: 12px;
    background: var(--bg-button);
    border: 1px solid var(--border-primary);
    border-radius: 8px;
    color: var(--text-primary);
    font-size: 14px;
    cursor: pointer;
    transition: 0.2s ease;
}

.select-input:hover { background: var(--bg-button-hover); }
.select-input:focus { outline: none; border-color: var(--color-primary); }

.info-text {
    font-size: 11px;
    opacity: 0.6;
    margin-top: 8px;
    color: var(--text-primary);
}

.stats-text {
    font-size: 10px;
    opacity: 0.5;
    margin-top: 8px;
    font-family: monospace;
    color: var(--text-primary);
}

.point-section {
    background: var(--bg-secondary);
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 16px;
}

.point-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
}

.point-id {
    font-size: 12px;
    opacity: 0.7;
    font-family: monospace;
    color: var(--text-primary);
}

.point-list {
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid var(--border-primary);
    border-radius: 8px;
    background: var(--bg-secondary);
}

.point-item {
    padding: 12px 16px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    cursor: pointer;
    transition: background 0.2s ease;
    font-size: 13px;
    color: var(--text-primary);
}

.point-item:last-child {
    border-bottom: none;
}

.point-item:hover { background: var(--bg-button); }
.point-item.selected { 
    background: rgba(0, 255, 136, 0.2);
    border-left: 3px solid var(--color-primary);
}

.empty-state {
    text-align: center;
    opacity: 0.5;
    font-size: 13px;
    padding: 40px 20px;
    color: var(--text-primary);
}

.color-preview {
    width: 100%;
    height: 24px;
    border-radius: 6px;
    border: 1px solid var(--border-primary);
    margin: 8px 0;
}

/* Modal Overlays */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(10px);
    z-index: 2000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
}

.modal {
    background: var(--bg-primary);
    backdrop-filter: blur(20px);
    border: 1px solid var(--border-primary);
    border-radius: 16px;
    max-width: 500px;
    width: 100%;
    color: var(--text-primary);
    overflow: hidden;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    max-height: 90vh;
    overflow-y: auto;
}

.modal-header {
    padding: 30px 30px 20px;
    text-align: center;
    border-bottom: 1px solid var(--border-primary);
}

.modal-header h2 {
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 8px;
}

.modal-header p {
    font-size: 14px;
    opacity: 0.7;
    margin: 0;
}

.modal-content {
    padding: 25px 30px;
}

.instruction-list {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.instruction-item {
    font-size: 14px;
    line-height: 1.5;
    padding: 12px 16px;
    background: var(--bg-secondary);
    border-radius: 8px;
    border-left: 3px solid rgba(255, 255, 255, 0.3);
}

.instruction-item strong {
    color: var(--color-primary);
    font-weight: 600;
}

.warning-item {
    border-left: 3px solid var(--color-warning);
}

.warning-item strong {
    color: var(--color-warning);
}

.modal-footer {
    padding: 20px 30px 30px;
    text-align: center;
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
}

.modal-button {
    background: linear-gradient(135deg, var(--color-primary), #00cc6a);
    border: none;
    border-radius: 12px;
    color: white;
    font-size: 16px;
    font-weight: 600;
    padding: 16px 32px;
    cursor: pointer;
    transition: 0.3s ease;
    box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
    margin: 0 5px;
}

.modal-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4);
}

.modal-button:active { transform: translateY(0); }

.modal-button.secondary {
    background: linear-gradient(135deg, var(--color-secondary), #0066cc);
    box-shadow: 0 4px 15px rgba(0, 136, 255, 0.3);
}

.modal-button.secondary:hover {
    box-shadow: 0 6px 20px rgba(0, 136, 255, 0.4);
}

.keyboard-shortcuts {
    display: grid;
    gap: 8px;
    margin: 15px 0;
}

.shortcut-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    background: var(--bg-secondary);
    border-radius: 6px;
    font-size: 12px;
}

.shortcut-key {
    background: var(--bg-button);
    padding: 4px 8px;
    border-radius: 4px;
    font-family: monospace;
    font-size: 11px;
}

.about-section {
    text-align: center;
    margin: 20px 0;
    padding: 15px;
    background: var(--bg-secondary);
    border-radius: 8px;
}

.about-section p {
    margin: 8px 0;
    font-size: 13px;
    line-height: 1.4;
}

.license-text {
    font-size: 11px;
    opacity: 0.6;
    margin-top: 15px;
    font-family: monospace;
}

/* Responsive Design */
@media (min-width: 768px) {
    .help-button {
        top: 30px;
        left: 30px;
        width: 64px;
        height: 64px;
    }

    .add-button {
        bottom: 100px;
        right: 30px;
        width: 64px;
        height: 64px;
    }
    
    .bottom-sheet {
        height: 60vh;
        transform: translateY(calc(100% - 50px));
    }

    .sheet-header {
        padding: 24px 32px 20px;
    }

    .panel {
        padding: 24px 32px 32px;
    }
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div class="visual-indicator long-press-indicator" id="longPressIndicator"></div>

<div class="deletion-zone deletion-edge-top" id="deletionTop"></div>
<div class="deletion-zone deletion-edge-bottom" id="deletionBottom"></div>
<div class="deletion-zone deletion-edge-left" id="deletionLeft"></div>
<div class="deletion-zone deletion-edge-right" id="deletionRight"></div>

<!-- Welcome Modal -->
<div class="modal-overlay" id="welcomeOverlay">
    <div class="modal">
        <div class="modal-header">
            <h2>Wave Physics Simulation</h2>
            <p>Interactive wave interference patterns</p>
        </div>
        <div class="modal-content">
            <div class="instruction-list">
                <div class="instruction-item">
                    <strong>Create waves:</strong> Press and hold on empty space to add wave sources
                </div>
                <div class="instruction-item">
                    <strong>Generate patterns:</strong> Use Pattern Generator for mathematical layouts
                </div>
                <div class="instruction-item">
                    <strong>Manipulate:</strong> Select, move, clone, and customize wave points
                </div>
                <div class="instruction-item">
                    <strong>Controls:</strong> Access tools via bottom sheet - swipe between panels
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="modal-button" id="welcomeStartBtn">Get Started</button>
        </div>
    </div>
</div>

<!-- Health Warning Modal -->
<div class="modal-overlay" id="healthWarningOverlay" style="display: none;">
    <div class="modal">
        <div class="modal-header">
            <h2>Health & Safety Warning</h2>
            <p>Important information before you begin</p>
        </div>
        <div class="modal-content">
            <div class="instruction-list">
                <div class="instruction-item warning-item">
                    <strong>Photosensitive Epilepsy:</strong> This simulation contains flashing patterns and rapid visual changes that may trigger seizures in individuals with photosensitive epilepsy
                </div>
                <div class="instruction-item warning-item">
                    <strong>Motion Sensitivity:</strong> The dynamic wave patterns may cause discomfort for those sensitive to motion or visual effects
                </div>
                <div class="instruction-item">
                    <strong>Safe Usage:</strong> If you experience any discomfort, dizziness, or unusual symptoms, please stop using the simulation immediately
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="modal-button secondary" id="healthBackBtn">Go Back</button>
            <button class="modal-button" id="healthContinueBtn">I Understand, Continue</button>
        </div>
    </div>
</div>

<!-- Help Modal -->
<div class="modal-overlay" id="helpOverlay" style="display: none;">
    <div class="modal">
        <div class="modal-header">
            <h2>Help & Instructions</h2>
            <p>Complete guide to wave simulation</p>
        </div>
        <div class="modal-content">
            <div class="section-title">Basic Controls</div>
            <div class="instruction-list">
                <div class="instruction-item">
                    <strong>Add Point:</strong> Press and hold on empty space until indicator completes
                </div>
                <div class="instruction-item">
                    <strong>Select Point:</strong> Tap on wave point to select it
                </div>
                <div class="instruction-item">
                    <strong>Move Point:</strong> Drag selected point to new position
                </div>
                <div class="instruction-item">
                    <strong>Delete Point:</strong> Drag point to screen edge and hold
                </div>
                <div class="instruction-item">
                    <strong>Clone Point:</strong> Double-tap on existing point
                </div>
            </div>
            
            <div class="section-title">Bottom Sheet Navigation</div>
            <div class="instruction-list">
                <div class="instruction-item">
                    <strong>Expand:</strong> Tap handle or swipe up from bottom
                </div>
                <div class="instruction-item">
                    <strong>Navigate:</strong> Swipe left/right or tap navigation segments
                </div>
                <div class="instruction-item">
                    <strong>Panels:</strong> Quick Controls → Medium Properties → Pattern Generator → Edit Points → Point List
                </div>
            </div>
            
            <div class="section-title">Keyboard Shortcuts</div>
            <div class="keyboard-shortcuts">
                <div class="shortcut-item">
                    <span>Delete selected point</span>
                    <span class="shortcut-key">Del / Backspace</span>
                </div>
                <div class="shortcut-item">
                    <span>Clone selected point</span>
                    <span class="shortcut-key">C</span>
                </div>
                <div class="shortcut-item">
                    <span>Collapse bottom sheet</span>
                    <span class="shortcut-key">Esc</span>
                </div>
            </div>
            
            <div class="about-section">
                <p><strong>Wave Physics Simulation</strong></p>
                <p>Proper integration - Real physics with modern UI</p>
            </div>
        </div>
        <div class="modal-footer">
            <button class="modal-button" id="helpCloseBtn">Close</button>
        </div>
    </div>
</div>

<!-- Floating Action Buttons -->
<button class="help-button" id="helpBtn">?</button>
<button class="add-button" id="addBtn">+</button>

<!-- Bottom Sheet -->
<div class="bottom-sheet" id="bottomSheet">
    <div class="sheet-handle" id="sheetHandle"></div>
    
    <div class="sheet-header">
        <div class="panel-title" id="panelTitle">
            <span id="panelTitleText">Quick Controls</span>
        </div>
        
        <div class="panel-navigation" id="panelNavigation">
            <div class="nav-segment active" data-panel="0"></div>
            <div class="nav-segment" data-panel="1"></div>
            <div class="nav-segment" data-panel="2"></div>
            <div class="nav-segment" data-panel="3"></div>
            <div class="nav-segment" data-panel="4"></div>
        </div>
    </div>
    
    <div class="sheet-content">
        <div class="panels-container" id="panelsContainer">
            
            <!-- Panel 1: Quick Controls -->
            <div class="panel" data-panel-id="0">
                <div class="control-section">
                    <div class="button-group">
                        <button class="control-button primary" id="syncBtn">Sync</button>
                        <button class="control-button danger" id="clearBtn">Clear All</button>
                    </div>
                </div>
                
                <div class="control-section">
                    <div class="toggle-row">
                        <div class="toggle-group">
                            <label class="control-label">Show Points</label>
                            <div class="toggle-switch" id="showPointsToggle">
                                <div class="toggle-circle"></div>
                            </div>
                        </div>
                        <div class="toggle-group">
                            <label class="control-label">Show Grid</label>
                            <div class="toggle-switch" id="showGridToggle">
                                <div class="toggle-circle"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="control-section">
                    <div class="info-text" id="stats">Points: 0 / 36</div>
                    <div class="stats-text" id="performanceInfo">Ready to create waves</div>
                </div>
            </div>
            
            <!-- Panel 2: Medium Properties -->
            <div class="panel" data-panel-id="1">
                <div class="control-section">
                    <div class="control-group">
                        <label class="control-label">Animation Speed</label>
                        <div class="slider-container">
                            <input type="range" class="slider" id="timeMultiplierSlider" min="0.0" max="30.0" step="0.1" value="10.0">
                            <input type="number" class="slider-value" id="timeMultiplierValue" min="0.0" max="30.0" step="0.1" value="10.0">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">Damping</label>
                        <div class="slider-container">
                            <input type="range" class="slider" id="dampingSlider" min="0.0" max="0.03" step="0.002" value="0.008">
                            <input type="number" class="slider-value" id="dampingValue" min="0.0" max="0.03" step="0.002" value="0.008">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">Resolution</label>
                        <div class="slider-container">
                            <input type="range" class="slider" id="performanceSlider" min="0" max="5" step="1" value="2">
                            <input type="number" class="slider-value" id="performanceValue" min="0" max="5" value="2">
                        </div>
                        <div class="info-text">Higher values = faster rendering</div>
                    </div>
                </div>
                
                <div class="control-section">
                    <div class="control-group">
                        <label class="control-label">Color Mode</label>
                        <div class="toggle-switch" id="colorToggle">
                            <div class="toggle-circle"></div>
                        </div>
                        <div class="info-text">Enable for colorful wave patterns</div>
                    </div>
                    
                    <div class="control-group" id="colorControls" style="display: none;">
                        <label class="control-label">Minima Color (Hue)</label>
                        <div class="slider-container">
                            <input type="range" class="slider" id="hue1Slider" min="0" max="360" step="1" value="185">
                            <input type="number" class="slider-value" id="hue1Value" min="0" max="360" value="185">
                        </div>
                    </div>
                    
                    <div class="control-group" id="colorControls2" style="display: none;">
                        <label class="control-label">Maxima Color (Hue)</label>
                        <div class="slider-container">
                            <input type="range" class="slider" id="hue2Slider" min="0" max="360" step="1" value="285">
                            <input type="number" class="slider-value" id="hue2Value" min="0" max="360" value="285">
                        </div>
                    </div>
                    
                    <div class="control-group" id="colorPreview" style="display: none;">
                        <label class="control-label">Color Preview</label>
                        <div class="color-preview" id="gradientPreview" style="background: linear-gradient(to right, hsl(185, 70%, 50%), hsl(285, 70%, 50%));"></div>
                    </div>
                </div>
            </div>
            
            <!-- Panel 3: Pattern Generator -->
            <div class="panel" data-panel-id="2">
                <div class="control-section">
                    <div class="control-group">
                        <label class="control-label">Pattern Type</label>
                        <select id="patternType" class="select-input">
                            <option value="grid">Grid</option>
                            <option value="radial">Radial</option>
                            <option value="spiral">Spiral</option>
                            <option value="sunflower">Sunflower</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">Number of Points</label>
                        <div class="slider-container">
                            <input type="range" class="slider" id="patternCount" min="3" max="36" step="1" value="16">
                            <input type="number" class="slider-value" id="patternCountValue" min="3" max="36" value="16">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">Pattern Scale</label>
                        <div class="slider-container">
                            <input type="range" class="slider" id="patternScale" min="0.3" max="2.0" step="0.1" value="1.0">
                            <input type="number" class="slider-value" id="patternScaleValue" min="0.3" max="2.0" step="0.1" value="1.0">
                        </div>
                    </div>
                </div>
                
                <div class="control-section">
                    <div class="button-group">
                        <button class="control-button pattern" id="generatePatternBtn">Add Pattern</button>
                    </div>
                    <div class="info-text">Adds to existing points (max 36 total)</div>
                </div>
            </div>
            
            <!-- Panel 4: Edit Points -->
            <div class="panel" data-panel-id="3">
                <div class="control-section">
                    <div class="control-group" id="editModeContainer" style="display: none;">
                        <label class="control-label">
                            <input type="checkbox" id="singleEditMode" style="margin-right: 8px;">
                            Edit Selected Point Only
                        </label>
                    </div>
                    
                    <div class="point-section" id="selectedPointInfo" style="display: none;">
                        <div class="point-header">
                            <span class="point-id" id="selectedPointId">Point #1</span>
                        </div>
                    </div>
                </div>
                
                <div class="control-section">
                    <div class="control-group">
                        <label class="control-label">Wave Type</label>
                        <div class="toggle-switch" id="pointWaveTypeToggle">
                            <div class="toggle-circle"></div>
                        </div>
                        <div class="info-text">Sine wave (on) / Square wave (off)</div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">Amplitude</label>
                        <div class="slider-container">
                            <input type="range" class="slider" id="pointAmplitude" min="10" max="100" step="5" value="60">
                            <input type="number" class="slider-value" id="pointAmplitudeValue" min="10" max="100" value="60">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">Wavelength</label>
                        <div class="slider-container">
                            <input type="range" class="slider" id="pointWavelength" min="20" max="400" step="10" value="100">
                            <input type="number" class="slider-value" id="pointWavelengthValue" min="20" max="400" value="100">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">Phase Velocity</label>
                        <div class="slider-container">
                            <input type="range" class="slider" id="pointSpeed" min="0.1" max="1.0" step="0.1" value="1.0">
                            <input type="number" class="slider-value" id="pointSpeedValue" min="0.1" max="1.0" step="0.1" value="1.0">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">Point Phase Offset</label>
                        <div class="slider-container">
                            <input type="range" class="slider" id="pointPhaseOffsetSlider" min="-2" max="2" step="0.1" value="0">
                            <input type="number" class="slider-value" id="pointPhaseOffsetValue" min="-2" max="2" step="0.1" value="0">
                        </div>
                        <div class="info-text">Creates time delays between points</div>
                    </div>
                </div>
                
                <div class="control-section" id="pointActions" style="display: none;">
                    <div class="button-group">
                        <button class="control-button secondary" id="clonePointBtn">Clone Point</button>
                        <button class="control-button danger" id="deletePointBtn">Delete Point</button>
                    </div>
                </div>
            </div>
            
            <!-- Panel 5: Point List -->
            <div class="panel" data-panel-id="4">
                <div class="control-section">
                    <div class="section-title">All Points</div>
                    <div class="point-list" id="pointList">
                        <div class="empty-state">No points created<br>Use + button or long-press on canvas</div>
                    </div>
                </div>
            </div>
            
        </div>
    </div>
</div>

<script>
'use strict';

// ====================================================================
// CONFIGURATION
// ====================================================================
const CONFIG = {
    maxPoints: 36,
    pointVisualRadius: 12,
    pointHitRadius: 25,
    pointBorderWidth: 2,
    longPressDuration: 500,
    frameInterval: 20,
    minPointDistance: 40,
    
    defaults: {
        amplitude: 60,
        wavelength: 100,
        speed: 1.0,
        waveType: 'sine',
        performanceLevel: 2,
        damping: 0.008,
        showPoints: false
    },
    
    ranges: {
        amplitude: { min: 10, max: 100, mid: 55 },
        wavelength: { min: 20, max: 400, mid: 210 },
        speed: { min: 0.1, max: 1.0, mid: 0.55 },
        hue1: { min: 0, max: 360, mid: 180 },
        hue2: { min: 0, max: 360, mid: 180 },
        phaseOffset: { min: -2, max: 2, mid: 0 },
        damping: { min: 0.0, max: 0.03, mid: 0.015 },
        performance: { min: 0, max: 5, mid: 3 },
        patternCount: { min: 3, max: 36, mid: 20 },
        patternScale: { min: 0.3, max: 2.0, mid: 1.15 },
        timeMultiplier: { min: 0.0, max: 30.0, mid: 10.0 }
    },
    
    performanceLevels: [
        { skip: 1, label: 'Quality' },
        { skip: 2, label: 'Balanced' },
        { skip: 4, label: 'Fast' },
        { skip: 8, label: 'Faster' },
        { skip: 16, label: 'Very Fast' },
        { skip: 32, label: 'Ultra Fast' }
    ],
    
    panelNames: [
        'Quick Controls',
        'Medium Properties', 
        'Pattern Generator',
        'Edit Points',
        'Point List'
    ]
};

// ====================================================================
// UTILITY FUNCTIONS
// ====================================================================
const Utils = {
    clamp: (val, min, max) => Math.max(min, Math.min(max, val)),
    distance: (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2),
    formatValue: (val, decimals = 3) => Number(val).toFixed(decimals),
    generateId: () => `point_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    
    haptic: () => {
        if ('vibrate' in navigator) navigator.vibrate(10);
    },
    
    showVisual: (x, y, className, duration = 500) => {
        const element = document.createElement('div');
        element.className = `visual-indicator ${className}`;
        element.style.left = `${x}px`;
        element.style.top = `${y}px`;
        document.body.appendChild(element);
        setTimeout(() => element.remove(), duration);
    },
    
    snapToGrid: (x, y, gridSpacing) => {
        return {
            x: Math.round(x / gridSpacing) * gridSpacing,
            y: Math.round(y / gridSpacing) * gridSpacing
        };
    },
    
    formatInputValue: (value, fieldType) => {
        switch (fieldType) {
            case 'amplitude':
            case 'wavelength':
            case 'patternCount':
            case 'performance':
            case 'hue1':
            case 'hue2':
                return Math.round(value).toString();
            case 'damping':
                return Utils.formatValue(value, 3);
            case 'timeMultiplier':
                return Utils.formatValue(value, 1);
            case 'speed':
            case 'patternScale':
            case 'phaseOffset':
                return Utils.formatValue(value, 1);
            default:
                return value.toString();
        }
    },
    
    validateNumericInput: (value, fieldType) => {
        const range = CONFIG.ranges[fieldType];
        if (!range) return value;
        
        const numValue = parseFloat(value);
        
        if (isNaN(numValue) || value === '' || value === null || value === undefined) {
            return range.mid;
        }
        
        if (numValue < range.min) return range.min;
        if (numValue > range.max) return range.max;
        
        return numValue;
    }
};

// ====================================================================
// PATTERN GENERATOR CLASS
// ====================================================================
class PatternGenerator {
    static generate(type, count, bounds, scale = 1.0) {
        const cx = bounds.width / 2;
        const cy = bounds.height / 2;
        const maxRadius = (Math.min(bounds.width, bounds.height) / 2 - 50) * scale;
        
        switch (type) {
            case 'grid': return this.generateGrid(count, cx, cy, maxRadius);
            case 'radial': return this.generateRadial(count, cx, cy, maxRadius);
            case 'spiral': return this.generateSpiral(count, cx, cy, maxRadius);
            case 'sunflower': return this.generateSunflower(count, cx, cy, maxRadius);
            default: return [];
        }
    }
    
    static generateGrid(count, cx, cy, maxRadius) {
        const points = [];
        const gridSize = Math.ceil(Math.sqrt(count));
        const spacing = (maxRadius * 2) / (gridSize + 1);
        const startX = cx - (gridSize - 1) * spacing / 2;
        const startY = cy - (gridSize - 1) * spacing / 2;
        
        for (let i = 0; i < gridSize * gridSize && points.length < count; i++) {
            const row = Math.floor(i / gridSize);
            const col = i % gridSize;
            points.push({
                x: startX + col * spacing,
                y: startY + row * spacing
            });
        }
        return points;
    }
    
    static generateRadial(count, cx, cy, maxRadius) {
        const points = [];
        const rings = Math.min(4, Math.ceil(count / 8));
        const pointsPerRing = Math.ceil(count / rings);
        
        for (let ring = 0; ring < rings; ring++) {
            const radius = ((ring + 1) / rings) * maxRadius;
            const ringCount = Math.min(pointsPerRing, count - points.length);
            
            for (let i = 0; i < ringCount; i++) {
                const angle = (i / ringCount) * 2 * Math.PI - Math.PI / 2;
                points.push({
                    x: cx + radius * Math.cos(angle),
                    y: cy + radius * Math.sin(angle)
                });
            }
        }
        return points;
    }
    
    static generateSpiral(count, cx, cy, maxRadius) {
        const points = [];
        const maxAngle = 4 * Math.PI;
        
        for (let i = 0; i < count; i++) {
            const t = (i / count) * maxAngle;
            const radius = (t / maxAngle) * maxRadius;
            points.push({
                x: cx + radius * Math.cos(t),
                y: cy + radius * Math.sin(t)
            });
        }
        return points;
    }
    
    static generateSunflower(count, cx, cy, maxRadius) {
        const points = [];
        const golden = Math.PI * (3 - Math.sqrt(5));
        
        for (let i = 0; i < count; i++) {
            const theta = i * golden;
            const radius = Math.sqrt(i / count) * maxRadius;
            points.push({
                x: cx + radius * Math.cos(theta),
                y: cy + radius * Math.sin(theta)
            });
        }
        return points;
    }
    
    static findRandomPosition(existingPoints, bounds) {
        const margin = 30;
        const minDist = CONFIG.minPointDistance;
        const maxAttempts = 50;
        
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            const x = margin + Math.random() * (bounds.width - 2 * margin);
            const y = margin + Math.random() * (bounds.height - 2 * margin);
            
            const tooClose = existingPoints.some(point => 
                Utils.distance(x, y, point.x, point.y) < minDist
            );
            
            if (!tooClose) return { x, y };
        }
        
        return {
            x: margin + Math.random() * (bounds.width - 2 * margin),
            y: margin + Math.random() * (bounds.height - 2 * margin)
        };
    }
}

// ====================================================================
// WAVE POINT CLASS - REAL PHYSICS
// ====================================================================
class WavePoint {
    constructor(x, y, properties = {}) {
        this.id = Utils.generateId();
        this.x = x;
        this.y = y;
        this.startTime = 0;
        this.selected = false;
        this.amplitude = properties.amplitude || CONFIG.defaults.amplitude;
        this.wavelength = properties.wavelength || CONFIG.defaults.wavelength;
        this.speed = properties.speed || CONFIG.defaults.speed;
        this.waveType = properties.waveType || CONFIG.defaults.waveType;
        this.phaseOffset = properties.phaseOffset || 0;
        this.creationIndex = properties.creationIndex || 0;
        
        // Visual feedback properties for deletion zones
        this.inDeletionZone = false;
        this.deletionTimer = null;
    }
    
    getProperties() {
        return {
            amplitude: this.amplitude,
            wavelength: this.wavelength,
            speed: this.speed,
            waveType: this.waveType,
            phaseOffset: this.phaseOffset
        };
    }
    
    distanceTo(x, y) {
        return Utils.distance(this.x, this.y, x, y);
    }
    
    isHit(x, y) {
        return this.distanceTo(x, y) <= CONFIG.pointHitRadius;
    }
    
    getDisplayName() {
        return `Point ${this.id.split('_')[1].slice(-3)}`;
    }
    
    get frequency() {
        return (2 * Math.PI) / this.wavelength;
    }
}

// ====================================================================
// WAVE ENGINE CLASS - REAL PHYSICS
// ====================================================================
class WaveEngine {
    constructor() {
        this.points = new Map();
        this.time = 0;
        this.pointPhaseOffset = 0;
        this.mediumDamping = CONFIG.defaults.damping;
        this.creationCounter = 0;
        this.hue1 = 185;
        this.hue2 = 285;
        this.useColor = false;
        this.timeMultiplier = 10.0;
    }
    
    addPoint(x, y, properties = {}) {
        if (this.points.size >= CONFIG.maxPoints) {
            Utils.haptic();
            return null;
        }
        
        const point = new WavePoint(x, y, { 
            ...properties, 
            creationIndex: this.creationCounter++,
            phaseOffset: this.pointPhaseOffset * (this.creationCounter - 1)
        });
        point.startTime = this.time;
        this.points.set(point.id, point);
        return point;
    }
    
    removePoint(id) {
        return this.points.delete(id);
    }
    
    getPoint(id) {
        return this.points.get(id);
    }
    
    getAllPoints() {
        return Array.from(this.points.values());
    }
    
    findPointAt(x, y) {
        for (const point of this.points.values()) {
            if (point.isHit(x, y)) return point;
        }
        return null;
    }
    
    clearAll() {
        this.points.clear();
        this.time = 0;
        this.creationCounter = 0;
    }
    
    syncPoints() {
        this.time = 0;
        this.pointPhaseOffset = 0;
        
        for (const point of this.points.values()) {
            point.startTime = 0;
            point.phaseOffset = 0;
        }
    }
    
    applyPointPhaseOffsets() {
        const points = this.getAllPoints().sort((a, b) => a.creationIndex - b.creationIndex);
        points.forEach((point, index) => {
            point.phaseOffset = this.pointPhaseOffset * index;
        });
    }
    
    // REAL WAVE PHYSICS CALCULATIONS
    calculatePixel(x, y) {
        let totalWave = 0;
        
        for (const point of this.points.values()) {
            const age = this.time - point.startTime;
            if (age < 0) continue;
            
            const dist = point.distanceTo(x, y);
            const k = (2 * Math.PI) / point.wavelength;
            const phase = k * dist - (point.speed * k) * age + point.phaseOffset;
            
            let waveValue;
            if (point.waveType === 'sine') {
                waveValue = point.amplitude * Math.sin(phase);
            } else {
                const normalized = ((phase % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
                waveValue = point.amplitude * (normalized < Math.PI ? 1 : -1);
            }
            
            waveValue *= Math.exp(-dist * this.mediumDamping);
            totalWave += waveValue;
        }
        
        return this.waveToColor(totalWave);
    }
    
    waveToColor(waveValue) {
        if (!this.useColor) {
            const normalized = waveValue / 100;
            return Utils.clamp(128 + normalized * 127, 0, 255);
        }
        
        const normalizedValue = Utils.clamp((waveValue / 100 + 1) / 2, 0, 1);
        const interpolatedHue = this.lerpHue(this.hue1, this.hue2, normalizedValue);
        return this.hslToRgb(interpolatedHue, 70, 50);
    }
    
    lerpHue(hue1, hue2, t) {
        let diff = Math.abs(hue1 - hue2);
        if (diff > 180) {
            if (hue2 > hue1) hue1 += 360;
            else hue2 += 360;
        }
        return Math.round((hue1 + (hue2 - hue1) * t) % 360);
    }
    
    hslToRgb(h, s, l) {
        h /= 360;
        s /= 100;
        l /= 100;
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h * 6) % 2 - 1));
        const m = l - c / 2;
        
        let r, g, b;
        if (h < 1/6) [r, g, b] = [c, x, 0];
        else if (h < 2/6) [r, g, b] = [x, c, 0];
        else if (h < 3/6) [r, g, b] = [0, c, x];
        else if (h < 4/6) [r, g, b] = [0, x, c];
        else if (h < 5/6) [r, g, b] = [x, 0, c];
        else [r, g, b] = [c, 0, x];
        
        return {
            r: Math.round((r + m) * 255),
            g: Math.round((g + m) * 255),
            b: Math.round((b + m) * 255)
        };
    }
    
    updateTime(deltaTime) {
        this.time += deltaTime * this.timeMultiplier;
    }
    
    setTimeMultiplier(multiplier) {
        this.timeMultiplier = multiplier;
    }
    
    setColorMode(enabled) {
        this.useColor = enabled;
    }
    
    setHues(hue1, hue2) {
        this.hue1 = hue1;
        this.hue2 = hue2;
    }
    
    setPointPhaseOffset(offset) {
        this.pointPhaseOffset = offset;
        this.applyPointPhaseOffsets();
    }
    
    setDamping(damping) {
        this.mediumDamping = damping;
    }
}

// ====================================================================
// RENDERER CLASS - REAL RENDERING
// ====================================================================
class Renderer {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.imageData = null;
        this.skipFactor = CONFIG.performanceLevels[CONFIG.defaults.performanceLevel].skip;
        this.lastRenderTime = 0;
        this.resize();
    }
    
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
    }
    
    setPerformanceLevel(level) {
        this.skipFactor = CONFIG.performanceLevels[level].skip;
    }
    
    render(engine, showPoints, showGrid, selectedPoint) {
        const startTime = performance.now();
        
        this.clearCanvas();
        
        if (engine.points.size > 0) {
            this.renderWaveField(engine);
        }
        
        this.ctx.putImageData(this.imageData, 0, 0);
        
        if (showGrid) {
            this.renderGrid(engine);
        }
        
        this.renderPoints(engine.getAllPoints(), showPoints, selectedPoint);
        
        this.lastRenderTime = performance.now() - startTime;
    }
    
    clearCanvas() {
        const data = this.imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            data[i] = data[i + 1] = data[i + 2] = 0;
            data[i + 3] = 255;
        }
    }
    
    renderWaveField(engine) {
        const { width, height } = this.canvas;
        const skip = this.skipFactor;
        
        for (let y = 0; y < height; y += skip) {
            for (let x = 0; x < width; x += skip) {
                const color = engine.calculatePixel(x, y);
                this.fillBlock(x, y, color, skip);
            }
        }
    }
    
    fillBlock(startX, startY, color, size) {
        const data = this.imageData.data;
        const { width, height } = this.canvas;
        
        for (let dy = 0; dy < size && startY + dy < height; dy++) {
            for (let dx = 0; dx < size && startX + dx < width; dx++) {
                const index = ((startY + dy) * width + (startX + dx)) * 4;
                
                if (typeof color === 'object') {
                    data[index] = color.r;
                    data[index + 1] = color.g;
                    data[index + 2] = color.b;
                } else {
                    data[index] = data[index + 1] = data[index + 2] = color;
                }
            }
        }
    }
    
    renderGrid(engine) {
        const { width, height } = this.canvas;
        const gridSpacing = this.skipFactor * 10;
        
        const baseOpacity = 0.2 + (0.3 * (1 - engine.points.size / CONFIG.maxPoints));
        this.ctx.strokeStyle = `rgba(255, 255, 255, ${baseOpacity})`;
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        
        for (let x = gridSpacing; x < width; x += gridSpacing) {
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, height);
        }
        
        for (let y = gridSpacing; y < height; y += gridSpacing) {
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(width, y);
        }
        
        this.ctx.stroke();
    }
    
    renderPoints(allPoints, showPoints, selectedPoint) {
        if (showPoints) {
            allPoints.forEach(point => this.drawPoint(point));
        } else if (selectedPoint) {
            this.drawPoint(selectedPoint);
        }
    }
    
    drawPoint(point) {
        const visualRadius = CONFIG.pointVisualRadius;
        const hitRadius = CONFIG.pointHitRadius;
        const borderWidth = CONFIG.pointBorderWidth;
        
        if (point.selected) {
            this.ctx.strokeStyle = '#00ff88';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(point.x, point.y, hitRadius, 0, 2 * Math.PI);
            this.ctx.stroke();
        }
        
        let deletionProgress = 0;
        let finalRadius = visualRadius;
        let pointColor = 'white';
        
        if (point.inDeletionZone && point.deletionTimer) {
            const elapsed = performance.now() - point.deletionTimer;
            deletionProgress = Math.min(elapsed / 500, 1);
            
            const redIntensity = Math.floor(255 * deletionProgress);
            const whiteIntensity = Math.floor(255 * (1 - deletionProgress));
            pointColor = `rgb(255, ${whiteIntensity}, ${whiteIntensity})`;
            finalRadius = visualRadius + (deletionProgress * 4);
        } else if (point.inDeletionZone) {
            pointColor = '#ff4444';
        }
        
        this.ctx.fillStyle = '#333333';
        this.ctx.beginPath();
        this.ctx.arc(point.x, point.y, finalRadius + borderWidth, 0, 2 * Math.PI);
        this.ctx.fill();
        
        this.ctx.fillStyle = pointColor;
        this.ctx.beginPath();
        this.ctx.arc(point.x, point.y, finalRadius, 0, 2 * Math.PI);
        this.ctx.fill();
    }
    
    getPerformanceInfo() {
        const config = CONFIG.performanceLevels.find(level => level.skip === this.skipFactor);
        const width = Math.floor(window.innerWidth / this.skipFactor);
        const height = Math.floor(window.innerHeight / this.skipFactor);
        const speedup = this.skipFactor === 1 ? '' : ` (${this.skipFactor ** 2}x faster)`;
        
        return {
            label: config.label,
            resolution: `${width}×${height}${speedup}`,
            renderTime: this.lastRenderTime.toFixed(1)
        };
    }
}

// ====================================================================
// ANIMATION MANAGER
// ====================================================================
class AnimationManager {
    constructor(renderer, engine) {
        this.renderer = renderer;
        this.engine = engine;
        this.isAnimating = false;
        this.animationId = null;
        this.lastFrameTime = 0;
        this.frameInterval = CONFIG.frameInterval;
        this.showPoints = CONFIG.defaults.showPoints;
        this.showGrid = false;
        this.selectedPoint = null;
        this.fps = 60;
        this.frameCount = 0;
        
        this.fpsInterval = setInterval(() => {
            this.fps = this.frameCount;
            this.frameCount = 0;
        }, 1000);
    }
    
    start() {
        if (this.isAnimating) return;
        
        this.isAnimating = true;
        this.lastFrameTime = performance.now();
        this.animate();
    }
    
    stop() {
        this.isAnimating = false;
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
    }
    
    animate() {
        const currentTime = performance.now();
        
        if (this.isAnimating && (currentTime - this.lastFrameTime) >= this.frameInterval) {
            this.engine.updateTime(0.2);
            this.renderer.render(this.engine, this.showPoints, this.showGrid, this.selectedPoint);
            this.lastFrameTime = currentTime;
            this.frameCount++;
        }
        
        if (this.isAnimating) {
            this.animationId = requestAnimationFrame(() => this.animate());
        }
    }
    
    setShowPoints(show) {
        this.showPoints = show;
        this.renderer.render(this.engine, this.showPoints, this.showGrid, this.selectedPoint);
    }
    
    setShowGrid(show) {
        this.showGrid = show;
        this.renderer.render(this.engine, this.showPoints, this.showGrid, this.selectedPoint);
    }
    
    setSelectedPoint(point) {
        this.selectedPoint = point;
        this.renderer.render(this.engine, this.showPoints, this.showGrid, this.selectedPoint);
    }
    
    forceRender() {
        this.renderer.render(this.engine, this.showPoints, this.showGrid, this.selectedPoint);
    }
}

// ====================================================================
// INPUT CONTROLLER
// ====================================================================
class InputController {
    constructor() {
        this.handlers = new Map();
    }
    
    registerSliderPair(sliderId, inputId, handler) {
        const slider = document.getElementById(sliderId);
        const input = document.getElementById(inputId);
        
        if (!slider || !input) return;
        
        const fieldType = this.getFieldType(sliderId);
        
        slider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            input.value = this.formatDisplayValue(value, fieldType);
            handler(value);
        });
        
        input.addEventListener('input', (e) => {
            const rawValue = e.target.value;
            const numValue = parseFloat(rawValue);
            
            if (!isNaN(numValue)) {
                const validValue = Utils.validateNumericInput(numValue, fieldType);
                slider.value = validValue;
                handler(validValue);
            }
        });
        
        input.addEventListener('blur', (e) => {
            const rawValue = e.target.value;
            const validValue = Utils.validateNumericInput(rawValue, fieldType);
            slider.value = validValue;
            input.value = this.formatDisplayValue(validValue, fieldType);
            handler(validValue);
        });
    }
    
    getFieldType(id) {
        const fieldMap = {
            'pointAmplitude': 'amplitude',
            'pointWavelength': 'wavelength',
            'pointSpeed': 'speed',
            'hue1Slider': 'hue1',
            'hue2Slider': 'hue2',
            'pointPhaseOffsetSlider': 'phaseOffset',
            'dampingSlider': 'damping',
            'performanceSlider': 'performance',
            'patternCount': 'patternCount',
            'patternScale': 'patternScale',
            'timeMultiplierSlider': 'timeMultiplier'
        };
        
        return fieldMap[id] || id;
    }
    
    formatDisplayValue(value, fieldType) {
        return Utils.formatInputValue(value, fieldType);
    }
    
    updatePair(sliderId, inputId, value) {
        const slider = document.getElementById(sliderId);
        const input = document.getElementById(inputId);
        const fieldType = this.getFieldType(sliderId);
        
        if (slider) slider.value = value;
        if (input) input.value = this.formatDisplayValue(value, fieldType);
    }
}

// ====================================================================
// BOTTOM SHEET CONTROLLER
// ====================================================================
class BottomSheetController {
    constructor() {
        this.currentPanel = 0;
        this.totalPanels = CONFIG.panelNames.length;
        this.isExpanded = false;
        
        this.isDraggingHandle = false;
        this.dragStartY = 0;
        this.initialTransform = 0;
        
        this.elements = {
            bottomSheet: document.getElementById('bottomSheet'),
            sheetHandle: document.getElementById('sheetHandle'),
            panelTitle: document.getElementById('panelTitleText'),
            panelsContainer: document.getElementById('panelsContainer'),
            panelNavigation: document.getElementById('panelNavigation'),
            navSegments: document.querySelectorAll('.nav-segment')
        };
        
        this.setupEventListeners();
        this.updateUI();
    }
    
    setupEventListeners() {
        if (this.elements.sheetHandle) {
            this.setupHandleDrag();
        }
        
        if (this.elements.panelsContainer) {
            this.setupScrollNavigation();
        }
        
        if (this.elements.navSegments) {
            this.setupSegmentNavigation();
        }
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.isExpanded) {
                this.collapse();
            } else if (this.isExpanded) {
                if (e.key === 'ArrowLeft') {
                    this.scrollToPreviousPanel();
                } else if (e.key === 'ArrowRight') {
                    this.scrollToNextPanel();
                }
            }
        });
    }
    
    setupSegmentNavigation() {
        this.elements.navSegments.forEach((segment, index) => {
            segment.addEventListener('click', () => {
                this.scrollToPanel(index);
            });
        });
    }
    
    setupScrollNavigation() {
        const container = this.elements.panelsContainer;
        let isScrolling = false;
        let scrollTimeout;
        
        container.addEventListener('scroll', () => {
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
            }
            
            isScrolling = true;
            
            scrollTimeout = setTimeout(() => {
                isScrolling = false;
                this.detectCurrentPanel();
            }, 150);
            
            this.detectCurrentPanel();
        }, { passive: true });
    }
    
    detectCurrentPanel() {
        const container = this.elements.panelsContainer;
        const containerWidth = container.offsetWidth;
        const scrollLeft = container.scrollLeft;
        
        const newPanel = Math.round(scrollLeft / containerWidth);
        const clampedPanel = Math.max(0, Math.min(this.totalPanels - 1, newPanel));
        
        if (clampedPanel !== this.currentPanel) {
            this.currentPanel = clampedPanel;
            this.updateUI();
        }
    }
    
    scrollToPanel(index) {
        if (index >= 0 && index < this.totalPanels) {
            const container = this.elements.panelsContainer;
            const containerWidth = container.offsetWidth;
            const scrollLeft = index * containerWidth;
            
            container.scrollTo({
                left: scrollLeft,
                behavior: 'smooth'
            });
            
            this.currentPanel = index;
            this.updateUI();
        }
    }
    
    scrollToPreviousPanel() {
        if (this.currentPanel > 0) {
            this.scrollToPanel(this.currentPanel - 1);
        }
    }
    
    scrollToNextPanel() {
        if (this.currentPanel < this.totalPanels - 1) {
            this.scrollToPanel(this.currentPanel + 1);
        }
    }
    
    setupHandleDrag() {
        const handle = this.elements.sheetHandle;
        const sheet = this.elements.bottomSheet;
        
        handle.addEventListener('touchstart', (e) => {
            this.startDrag(e.touches[0].clientY);
            e.preventDefault();
        }, { passive: false });
        
        document.addEventListener('touchmove', (e) => {
            if (this.isDraggingHandle) {
                this.updateDrag(e.touches[0].clientY);
                e.preventDefault();
            }
        }, { passive: false });
        
        document.addEventListener('touchend', () => {
            if (this.isDraggingHandle) {
                this.endDrag();
            }
        });
        
        handle.addEventListener('mousedown', (e) => {
            this.startDrag(e.clientY);
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (this.isDraggingHandle) {
                this.updateDrag(e.clientY);
                e.preventDefault();
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (this.isDraggingHandle) {
                this.endDrag();
            }
        });
    }
    
    startDrag(clientY) {
        this.isDraggingHandle = true;
        this.dragStartY = clientY;
        
        const sheet = this.elements.bottomSheet;
        const style = window.getComputedStyle(sheet);
        const transform = style.transform;
        
        if (transform !== 'none') {
            const matrix = new DOMMatrix(transform);
            this.initialTransform = matrix.m42;
        } else {
            this.initialTransform = 0;
        }
        
        sheet.style.transition = 'none';
        Utils.haptic();
    }
    
    updateDrag(clientY) {
        if (!this.isDraggingHandle) return;
        
        const deltaY = clientY - this.dragStartY;
        const sheet = this.elements.bottomSheet;
        
        let newTransform = this.initialTransform + deltaY;
        
        const sheetHeight = sheet.offsetHeight;
        const maxCollapsed = sheetHeight - 40;
        const maxExpanded = 0;
        
        newTransform = Math.max(maxExpanded, Math.min(maxCollapsed, newTransform));
        
        sheet.style.transform = `translateY(${newTransform}px)`;
    }
    
    endDrag() {
        if (!this.isDraggingHandle) return;
        
        this.isDraggingHandle = false;
        const sheet = this.elements.bottomSheet;
        
        sheet.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
        
        const style = window.getComputedStyle(sheet);
        const transform = style.transform;
        let currentY = 0;
        
        if (transform !== 'none') {
            const matrix = new DOMMatrix(transform);
            currentY = matrix.m42;
        }
        
        const sheetHeight = sheet.offsetHeight;
        const threshold = sheetHeight * 0.3;
        
        if (currentY > threshold) {
            this.collapse();
        } else {
            this.expand();
        }
    }
    
    expand() {
        this.isExpanded = true;
        if (this.elements.bottomSheet) {
            this.elements.bottomSheet.classList.add('expanded');
            this.elements.bottomSheet.style.transform = '';
        }
        Utils.haptic();
    }
    
    collapse() {
        this.isExpanded = false;
        if (this.elements.bottomSheet) {
            this.elements.bottomSheet.classList.remove('expanded');
            this.elements.bottomSheet.style.transform = '';
        }
        Utils.haptic();
    }
    
    updateUI() {
        if (this.elements.panelTitle) {
            this.elements.panelTitle.textContent = CONFIG.panelNames[this.currentPanel];
        }
        
        this.elements.navSegments.forEach((segment, index) => {
            segment.classList.toggle('active', index === this.currentPanel);
        });
    }
    
    goToPanel(index) {
        this.scrollToPanel(index);
    }
}

// ====================================================================
// INTERACTION MANAGER
// ====================================================================
class InteractionManager {
    constructor(canvas, uiController) {
        this.canvas = canvas;
        this.ui = uiController;
        
        this.isDragging = false;
        this.dragPoint = null;
        this.startPos = { x: 0, y: 0 };
        this.longPressTimer = null;
        this.isLongPressing = false;
        this.inDeletionZone = false;
        this.deletionTimer = null;
        this.deletionDuration = 500;
        
        this.lastTapTime = 0;
        this.lastTapPos = { x: 0, y: 0 };
        this.doubleTapWindow = 300;
        this.doubleTapTolerance = 10;
        
        this.indicator = document.getElementById('longPressIndicator');
        this.deletionZones = {
            top: document.getElementById('deletionTop'),
            bottom: document.getElementById('deletionBottom'),
            left: document.getElementById('deletionLeft'),
            right: document.getElementById('deletionRight')
        };
        
        this.setupEvents();
    }
    
    setupEvents() {
        const options = { passive: false };
        this.canvas.addEventListener('touchstart', e => this.handleStart(e, e.touches[0]), options);
        this.canvas.addEventListener('touchmove', e => this.handleMove(e, e.touches[0]), options);
        this.canvas.addEventListener('touchend', e => this.handleEnd(e), options);
        this.canvas.addEventListener('mousedown', e => this.handleStart(e, e), options);
        this.canvas.addEventListener('mousemove', e => this.handleMove(e, e), options);
        this.canvas.addEventListener('mouseup', e => this.handleEnd(e), options);
        this.canvas.addEventListener('contextmenu', e => e.preventDefault());
    }
    
    getCoordinates(pointer) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        
        return {
            x: Math.floor((pointer.clientX - rect.left) * scaleX),
            y: Math.floor((pointer.clientY - rect.top) * scaleY)
        };
    }
    
    handleStart(event, pointer) {
        event.preventDefault();
        const coords = this.getCoordinates(pointer);
        this.startPos = coords;
        
        const hitPoint = this.ui.engine.findPointAt(coords.x, coords.y);
        const currentTime = performance.now();
        
        if (hitPoint && this.isDoubleTap(coords, currentTime)) {
            this.handleDoubleTap(hitPoint, coords);
            return;
        }
        
        this.lastTapTime = currentTime;
        this.lastTapPos = { x: coords.x, y: coords.y };
        
        if (hitPoint) {
            this.ui.selectPoint(hitPoint.id);
            this.isDragging = true;
            this.dragPoint = hitPoint;
            this.canvas.style.cursor = 'grabbing';
        } else {
            this.startLongPress(coords.x, coords.y);
            this.ui.deselectAll();
        }
    }
    
    handleMove(event, pointer) {
        const coords = this.getCoordinates(pointer);
        const dist = Utils.distance(coords.x, coords.y, this.startPos.x, this.startPos.y);
        
        if (dist > 10) {
            this.cancelLongPress();
        }
        
        if (this.isDragging && this.dragPoint) {
            event.preventDefault();
            if (dist > 5) {
                let finalX = coords.x;
                let finalY = coords.y;
                
                if (this.ui.animationManager.showGrid) {
                    const gridSpacing = this.ui.renderer.skipFactor * 10;
                    const snapped = Utils.snapToGrid(coords.x, coords.y, gridSpacing);
                    finalX = snapped.x;
                    finalY = snapped.y;
                }
                
                const deletionMargin = 50;
                const inDeletionZone = (
                    finalX < deletionMargin || 
                    finalX > this.canvas.width - deletionMargin ||
                    finalY < deletionMargin || 
                    finalY > this.canvas.height - deletionMargin
                );
                
                if (inDeletionZone !== this.inDeletionZone) {
                    this.inDeletionZone = inDeletionZone;
                    this.updateDeletionZoneVisuals(inDeletionZone);
                    
                    if (inDeletionZone && !this.deletionTimer) {
                        this.startDeletionTimer();
                    }
                    
                    if (!inDeletionZone && this.deletionTimer) {
                        this.cancelDeletionTimer();
                    }
                }
                
                this.dragPoint.inDeletionZone = inDeletionZone;
                
                this.dragPoint.x = finalX;
                this.dragPoint.y = finalY;
                this.ui.animationManager.forceRender();
            }
        }
    }
    
    handleEnd(event) {
        if (this.isDragging) {
            event.preventDefault();
            
            this.cancelDeletionTimer();
            
            if (this.dragPoint) {
                this.dragPoint.inDeletionZone = false;
            }
            
            this.isDragging = false;
            this.dragPoint = null;
            this.canvas.style.cursor = '';
            
            this.updateDeletionZoneVisuals(false);
            this.inDeletionZone = false;
        }
        this.cancelLongPress();
    }
    
    startLongPress(x, y) {
        this.isLongPressing = true;
        
        if (this.indicator) {
            this.indicator.style.left = `${x}px`;
            this.indicator.style.top = `${y}px`;
            this.indicator.classList.add('active');
        }
        
        this.longPressTimer = setTimeout(() => {
            if (this.isLongPressing) {
                this.completeLongPress(x, y);
            }
        }, CONFIG.longPressDuration);
    }
    
    completeLongPress(x, y) {
        Utils.haptic();
        
        if (this.indicator) {
            this.indicator.classList.remove('active');
            this.indicator.classList.add('complete');
            setTimeout(() => this.indicator.classList.remove('complete'), 300);
        }
        
        let finalX = x, finalY = y;
        if (this.ui.animationManager.showGrid) {
            const gridSpacing = this.ui.renderer.skipFactor * 10;
            const snapped = Utils.snapToGrid(x, y, gridSpacing);
            finalX = snapped.x;
            finalY = snapped.y;
        }
        
        this.ui.addPoint(finalX, finalY);
        this.cancelLongPress();
    }
    
    cancelLongPress() {
        if (this.longPressTimer) {
            clearTimeout(this.longPressTimer);
            this.longPressTimer = null;
        }
        this.isLongPressing = false;
        
        if (this.indicator) {
            this.indicator.classList.remove('active', 'complete');
        }
    }
    
    updateDeletionZoneVisuals(active) {
        Object.values(this.deletionZones).forEach(zone => {
            if (zone) {
                zone.classList.toggle('active', active);
            }
        });
    }
    
    startDeletionTimer() {
        if (this.deletionTimer) return;
        
        this.deletionTimer = setTimeout(() => {
            if (this.dragPoint && this.isDragging) {
                Utils.haptic();
                this.ui.removePoint(this.dragPoint.id);
                
                this.isDragging = false;
                this.dragPoint = null;
                this.canvas.style.cursor = '';
                this.updateDeletionZoneVisuals(false);
                this.inDeletionZone = false;
            }
            this.deletionTimer = null;
        }, this.deletionDuration);
        
        if (this.dragPoint) {
            this.dragPoint.deletionTimer = performance.now();
        }
    }
    
    cancelDeletionTimer() {
        if (this.deletionTimer) {
            clearTimeout(this.deletionTimer);
            this.deletionTimer = null;
        }
        
        if (this.dragPoint) {
            this.dragPoint.deletionTimer = null;
        }
    }
    
    isDoubleTap(coords, currentTime) {
        const timeDiff = currentTime - this.lastTapTime;
        const distance = Utils.distance(coords.x, coords.y, this.lastTapPos.x, this.lastTapPos.y);
        
        return timeDiff < this.doubleTapWindow && distance < this.doubleTapTolerance;
    }
    
    handleDoubleTap(point, coords) {
        Utils.haptic();
        
        this.ui.selectPoint(point.id);
        this.ui.clonePoint();
        
        Utils.showVisual(coords.x, coords.y, 'clone-flash');
        
        this.lastTapTime = 0;
        this.lastTapPos = { x: 0, y: 0 };
    }
}

// ====================================================================
// UI CONTROLLER
// ====================================================================
class UIController {
    constructor(engine, animationManager, renderer) {
        this.engine = engine;
        this.animationManager = animationManager;
        this.renderer = renderer;
        this.selectedPointId = null;
        this.singleEditMode = false;
        this.bottomSheet = new BottomSheetController();
        this.inputController = new InputController();
        
        this.setupEventListeners();
        this.setupInputControls();
        this.updatePerformanceInfo();
        this.updatePointsUI();
    }
    
    setupEventListeners() {
        // Modal management
        const welcomeStartBtn = document.getElementById('welcomeStartBtn');
        const healthBackBtn = document.getElementById('healthBackBtn');
        const healthContinueBtn = document.getElementById('healthContinueBtn');
        const helpBtn = document.getElementById('helpBtn');
        const helpCloseBtn = document.getElementById('helpCloseBtn');
        const addBtn = document.getElementById('addBtn');
        
        if (welcomeStartBtn) welcomeStartBtn.addEventListener('click', () => this.showHealthWarning());
        if (healthBackBtn) healthBackBtn.addEventListener('click', () => this.showWelcome());
        if (healthContinueBtn) healthContinueBtn.addEventListener('click', () => this.startApp());
        if (helpBtn) helpBtn.addEventListener('click', () => this.showHelp());
        if (helpCloseBtn) helpCloseBtn.addEventListener('click', () => this.hideHelp());
        if (addBtn) addBtn.addEventListener('click', () => this.createRandomPoint());
        
        // Control buttons
        const clearBtn = document.getElementById('clearBtn');
        const syncBtn = document.getElementById('syncBtn');
        const showPointsToggle = document.getElementById('showPointsToggle');
        const showGridToggle = document.getElementById('showGridToggle');
        const generatePatternBtn = document.getElementById('generatePatternBtn');
        const pointWaveTypeToggle = document.getElementById('pointWaveTypeToggle');
        const clonePointBtn = document.getElementById('clonePointBtn');
        const deletePointBtn = document.getElementById('deletePointBtn');
        const colorToggle = document.getElementById('colorToggle');
        const singleEditMode = document.getElementById('singleEditMode');
        
        if (clearBtn) clearBtn.addEventListener('click', () => this.clearAll());
        if (syncBtn) syncBtn.addEventListener('click', () => this.syncPoints());
        if (showPointsToggle) showPointsToggle.addEventListener('click', () => this.toggleShowPoints());
        if (showGridToggle) showGridToggle.addEventListener('click', () => this.toggleShowGrid());
        if (generatePatternBtn) generatePatternBtn.addEventListener('click', () => this.generatePattern());
        if (pointWaveTypeToggle) pointWaveTypeToggle.addEventListener('click', () => this.toggleWaveType());
        if (clonePointBtn) clonePointBtn.addEventListener('click', () => this.clonePoint());
        if (deletePointBtn) deletePointBtn.addEventListener('click', () => this.deletePoint());
        if (colorToggle) colorToggle.addEventListener('click', () => this.toggleColorMode());
        if (singleEditMode) singleEditMode.addEventListener('change', (e) => this.setSingleEditMode(e.target.checked));
        
        // Point list
        const pointList = document.getElementById('pointList');
        if (pointList) {
            pointList.addEventListener('click', (e) => {
                const item = e.target.closest('.point-item');
                if (item) {
                    this.selectPoint(item.dataset.id);
                }
            });
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => this.handleKeyboard(e));
        
        // Window events
        window.addEventListener('resize', () => {
            this.renderer.resize();
            this.updatePerformanceInfo();
        });
    }
    
    setupInputControls() {
        // Point property sliders
        this.inputController.registerSliderPair('pointAmplitude', 'pointAmplitudeValue', 
            (v) => this.updatePointProperty('amplitude', parseInt(v)));
        this.inputController.registerSliderPair('pointWavelength', 'pointWavelengthValue', 
            (v) => this.updatePointProperty('wavelength', parseInt(v)));
        this.inputController.registerSliderPair('pointSpeed', 'pointSpeedValue', 
            (v) => this.updatePointProperty('speed', parseFloat(v)));
        
        // Color sliders
        this.inputController.registerSliderPair('hue1Slider', 'hue1Value', (v) => {
            this.engine.hue1 = parseInt(v);
            this.updateColorPreview();
            this.animationManager.forceRender();
        });
        this.inputController.registerSliderPair('hue2Slider', 'hue2Value', (v) => {
            this.engine.hue2 = parseInt(v);
            this.updateColorPreview();
            this.animationManager.forceRender();
        });
        
        // Medium controls
        this.inputController.registerSliderPair('timeMultiplierSlider', 'timeMultiplierValue', (v) => {
            this.engine.setTimeMultiplier(parseFloat(v));
        });
        this.inputController.registerSliderPair('pointPhaseOffsetSlider', 'pointPhaseOffsetValue', (v) => {
            this.engine.setPointPhaseOffset(parseFloat(v) * Math.PI);
        });
        this.inputController.registerSliderPair('dampingSlider', 'dampingValue', (v) => {
            this.engine.setDamping(parseFloat(v));
        });
        this.inputController.registerSliderPair('performanceSlider', 'performanceValue', (v) => {
            this.setPerformanceLevel(parseInt(v));
        });
        
        // Pattern generator sliders
        this.inputController.registerSliderPair('patternCount', 'patternCountValue', () => {});
        this.inputController.registerSliderPair('patternScale', 'patternScaleValue', () => {});
        
        this.initializeInputDisplays();
    }
    
    // Modal methods
    showWelcome() {
        const welcomeOverlay = document.getElementById('welcomeOverlay');
        const healthWarningOverlay = document.getElementById('healthWarningOverlay');
        if (welcomeOverlay) welcomeOverlay.style.display = 'flex';
        if (healthWarningOverlay) healthWarningOverlay.style.display = 'none';
    }
    
    showHealthWarning() {
        const welcomeOverlay = document.getElementById('welcomeOverlay');
        const healthWarningOverlay = document.getElementById('healthWarningOverlay');
        if (welcomeOverlay) welcomeOverlay.style.display = 'none';
        if (healthWarningOverlay) healthWarningOverlay.style.display = 'flex';
    }
    
    startApp() {
        const healthWarningOverlay = document.getElementById('healthWarningOverlay');
        if (healthWarningOverlay) healthWarningOverlay.style.display = 'none';
        this.createStarterPoint();
    }
    
    showHelp() {
        const helpOverlay = document.getElementById('helpOverlay');
        if (helpOverlay) helpOverlay.style.display = 'flex';
    }
    
    hideHelp() {
        const helpOverlay = document.getElementById('helpOverlay');
        if (helpOverlay) helpOverlay.style.display = 'none';
    }
    
    // Point management
    selectPoint(id) {
        if (this.selectedPointId) {
            const prevPoint = this.engine.getPoint(this.selectedPointId);
            if (prevPoint) prevPoint.selected = false;
        }
        
        this.selectedPointId = id;
        const point = this.engine.getPoint(id);
        if (point) {
            point.selected = true;
        }
        
        this.updatePointPropertiesUI();
        this.updatePointsUI();
        this.animationManager.setSelectedPoint(point);
    }
    
    deselectAll() {
        if (this.selectedPointId) {
            const point = this.engine.getPoint(this.selectedPointId);
            if (point) point.selected = false;
        }
        this.selectedPointId = null;
        this.singleEditMode = false;
        const singleEditModeEl = document.getElementById('singleEditMode');
        if (singleEditModeEl) singleEditModeEl.checked = false;
        this.updatePointPropertiesUI();
        this.updatePointsUI();
        this.animationManager.setSelectedPoint(null);
    }
    
    getSelectedPoint() {
        return this.selectedPointId ? this.engine.getPoint(this.selectedPointId) : null;
    }
    
    // Action methods
    clearAll() {
        this.engine.clearAll();
        this.selectedPointId = null;
        this.singleEditMode = false;
        const singleEditModeEl = document.getElementById('singleEditMode');
        if (singleEditModeEl) singleEditModeEl.checked = false;
        this.animationManager.stop();
        this.animationManager.setShowPoints(false);
        this.animationManager.setShowGrid(false);
        this.updatePointsUI();
        this.updatePointPropertiesUI();
        this.updateButton('showPointsToggle', false);
        this.updateButton('showGridToggle', false);
        this.animationManager.forceRender();
    }
    
    createStarterPoint() {
        const cx = Math.floor(window.innerWidth / 2);
        const cy = Math.floor(window.innerHeight / 2);
        const point = this.engine.addPoint(cx, cy);
        if (point) {
            this.selectPoint(point.id);
            this.animationManager.start();
            this.updatePointsUI();
        }
    }
    
    createRandomPoint() {
        const bounds = { width: window.innerWidth, height: window.innerHeight };
        const pos = PatternGenerator.findRandomPosition(this.engine.getAllPoints(), bounds);
        const point = this.addPoint(pos.x, pos.y);
        if (point) {
            this.bottomSheet.expand();
        }
    }
    
    addPoint(x, y, properties = {}) {
        const point = this.engine.addPoint(x, y, properties);
        if (point) {
            this.selectPoint(point.id);
            if (!this.animationManager.isAnimating) {
                this.animationManager.start();
            }
        }
        
        this.updatePointsUI();
        Utils.haptic();
        return point;
    }
    
    clonePoint() {
        const selectedPoint = this.getSelectedPoint();
        if (!selectedPoint) return;
        
        const bounds = { width: window.innerWidth, height: window.innerHeight };
        const pos = PatternGenerator.findRandomPosition(this.engine.getAllPoints(), bounds);
        
        let finalX = pos.x, finalY = pos.y;
        if (this.animationManager.showGrid) {
            const gridSpacing = this.renderer.skipFactor * 10;
            const snapped = Utils.snapToGrid(pos.x, pos.y, gridSpacing);
            finalX = snapped.x;
            finalY = snapped.y;
        }
        
        const clone = this.engine.addPoint(finalX, finalY, {
            ...selectedPoint.getProperties(),
            creationIndex: this.engine.creationCounter++,
            phaseOffset: this.engine.pointPhaseOffset * (this.engine.creationCounter - 1)
        });
        
        if (clone) {
            clone.startTime = this.engine.time;
            this.selectPoint(clone.id);
            Utils.showVisual(finalX, finalY, 'clone-flash');
            
            if (!this.animationManager.isAnimating) {
                this.animationManager.start();
            }
        }
        
        this.updatePointsUI();
        Utils.haptic();
    }
    
    deletePoint() {
        const selectedPoint = this.getSelectedPoint();
        if (selectedPoint) {
            this.removePoint(selectedPoint.id);
        }
    }
    
    removePoint(id) {
        if (this.selectedPointId === id) {
            this.selectedPointId = null;
        }
        this.engine.removePoint(id);
        this.updatePointsUI();
        this.updatePointPropertiesUI();
        this.animationManager.setSelectedPoint(null);
        
        if (this.engine.points.size === 0) {
            this.animationManager.stop();
        }
    }
    
    toggleWaveType() {
        if (this.singleEditMode) {
            const selectedPoint = this.getSelectedPoint();
            if (selectedPoint) {
                selectedPoint.waveType = selectedPoint.waveType === 'sine' ? 'step' : 'sine';
                this.updatePointPropertiesUI();
                this.updatePointsUI();
            }
        } else {
            const waveTypeToggle = document.getElementById('pointWaveTypeToggle');
            const newWaveType = waveTypeToggle.classList.contains('active') ? 'step' : 'sine';
            for (const point of this.engine.getAllPoints()) {
                point.waveType = newWaveType;
            }
            this.updatePointsUI();
        }
    }
    
    updatePointProperty(property, value) {
        if (this.singleEditMode) {
            const selectedPoint = this.getSelectedPoint();
            if (selectedPoint) {
                selectedPoint[property] = value;
                this.updatePointsUI();
            }
        } else {
            for (const point of this.engine.getAllPoints()) {
                point[property] = value;
            }
            this.updatePointsUI();
        }
    }
    
    syncPoints() {
        if (this.engine.points.size === 0) return;
        
        this.engine.syncPoints();
        this.inputController.updatePair('pointPhaseOffsetSlider', 'pointPhaseOffsetValue', 0);
        
        if (!this.animationManager.isAnimating) {
            this.animationManager.start();
        }
        
        this.animationManager.forceRender();
    }
    
    toggleShowPoints() {
        const newState = !this.animationManager.showPoints;
        this.animationManager.setShowPoints(newState);
        this.updateButton('showPointsToggle', newState);
    }
    
    toggleShowGrid() {
        const newState = !this.animationManager.showGrid;
        this.animationManager.setShowGrid(newState);
        this.updateButton('showGridToggle', newState);
    }
    
    toggleColorMode() {
        const newState = !this.engine.useColor;
        this.engine.setColorMode(newState);
        this.updateButton('colorToggle', newState);
        this.updateColorControls();
        this.animationManager.forceRender();
    }
    
    updateColorPreview() {
        const preview = document.getElementById('gradientPreview');
        if (preview) {
            preview.style.background = `linear-gradient(to right, hsl(${this.engine.hue1}, 70%, 50%), hsl(${this.engine.hue2}, 70%, 50%))`;
        }
    }
    
    setPerformanceLevel(level) {
        this.renderer.setPerformanceLevel(level);
        this.updatePerformanceInfo();
    }
    
    handleKeyboard(e) {
        if (e.key === 'Escape' && this.bottomSheet.isExpanded) {
            this.bottomSheet.collapse();
        }
        
        const selectedPoint = this.getSelectedPoint();
        if (selectedPoint) {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                e.preventDefault();
                this.deletePoint();
            } else if (e.key === 'c' || e.key === 'C') {
                e.preventDefault();
                this.clonePoint();
            }
        }
    }
    
    // UI update methods
    updateButton(elementId, isActive, activeText = null, inactiveText = null) {
        const element = document.getElementById(elementId);
        if (!element) return;
        
        element.classList.toggle('active', isActive);
        if (activeText && inactiveText) {
            element.textContent = isActive ? activeText : inactiveText;
        }
    }
    
    updateColorControls() {
        const controls = ['colorControls', 'colorControls2', 'colorPreview'];
        controls.forEach(id => {
            const element = document.getElementById(id);
            if (element) element.style.display = this.engine.useColor ? 'block' : 'none';
        });
        
        if (this.engine.useColor) {
            this.updateColorPreview();
        }
    }
    
    updatePointsUI() {
        const count = this.engine.points.size;
        const stats = document.getElementById('stats');
        if (stats) {
            stats.textContent = `Points: ${count} / ${CONFIG.maxPoints}`;
        }
        
        const pointList = document.getElementById('pointList');
        if (pointList) {
            if (count === 0) {
                pointList.innerHTML = '<div class="empty-state">No points created<br>Use + button or long-press on canvas</div>';
            } else {
                pointList.innerHTML = this.engine.getAllPoints().map(point => `
                    <div class="point-item ${point.selected ? 'selected' : ''}" data-id="${point.id}">
                        ${point.getDisplayName()} - ${point.waveType} (${point.amplitude})
                    </div>
                `).join('');
            }
        }
        
        const performanceInfo = document.getElementById('performanceInfo');
        if (performanceInfo) {
            const info = this.renderer.getPerformanceInfo();
            if (count === 0) {
                performanceInfo.textContent = 'Ready to create waves';
            } else {
                performanceInfo.textContent = `${info.resolution} • ${this.animationManager.fps} FPS`;
            }
        }
    }
    
    updatePointPropertiesUI() {
        const selectedPoint = this.getSelectedPoint();
        const allPoints = this.engine.getAllPoints();
        
        const editModeContainer = document.getElementById('editModeContainer');
        const selectedPointInfo = document.getElementById('selectedPointInfo');
        const pointActions = document.getElementById('pointActions');
        const selectedPointId = document.getElementById('selectedPointId');
        
        if (selectedPoint) {
            if (editModeContainer) editModeContainer.style.display = 'block';
            if (selectedPointInfo) selectedPointInfo.style.display = 'block';
            if (pointActions) pointActions.style.display = 'block';
            if (selectedPointId) selectedPointId.textContent = selectedPoint.getDisplayName();
        } else {
            if (editModeContainer) editModeContainer.style.display = 'none';
            if (selectedPointInfo) selectedPointInfo.style.display = 'none';
            if (pointActions) pointActions.style.display = 'none';
        }
        
        if (allPoints.length === 0) {
            this.inputController.updatePair('pointAmplitude', 'pointAmplitudeValue', CONFIG.defaults.amplitude);
            this.inputController.updatePair('pointWavelength', 'pointWavelengthValue', CONFIG.defaults.wavelength);
            this.inputController.updatePair('pointSpeed', 'pointSpeedValue', CONFIG.defaults.speed);
            this.updateButton('pointWaveTypeToggle', CONFIG.defaults.waveType === 'sine');
        } else if (this.singleEditMode && selectedPoint) {
            this.inputController.updatePair('pointAmplitude', 'pointAmplitudeValue', selectedPoint.amplitude);
            this.inputController.updatePair('pointWavelength', 'pointWavelengthValue', selectedPoint.wavelength);
            this.inputController.updatePair('pointSpeed', 'pointSpeedValue', selectedPoint.speed);
            this.updateButton('pointWaveTypeToggle', selectedPoint.waveType === 'sine');
        } else {
            const avgAmplitude = Math.round(allPoints.reduce((sum, p) => sum + p.amplitude, 0) / allPoints.length);
            const avgWavelength = Math.round(allPoints.reduce((sum, p) => sum + p.wavelength, 0) / allPoints.length);
            const avgSpeed = allPoints.reduce((sum, p) => sum + p.speed, 0) / allPoints.length;
            
            this.inputController.updatePair('pointAmplitude', 'pointAmplitudeValue', avgAmplitude);
            this.inputController.updatePair('pointWavelength', 'pointWavelengthValue', avgWavelength);
            this.inputController.updatePair('pointSpeed', 'pointSpeedValue', avgSpeed);
            
            const sineCount = allPoints.filter(p => p.waveType === 'sine').length;
            this.updateButton('pointWaveTypeToggle', sineCount > allPoints.length / 2);
        }
    }
    
    updatePerformanceInfo() {
        const info = this.renderer.getPerformanceInfo();
        const performanceInfo = document.getElementById('performanceInfo');
        if (performanceInfo && this.engine.points.size > 0) {
            performanceInfo.textContent = `${info.resolution} • ${this.animationManager.fps} FPS`;
        }
    }
    
    setSingleEditMode(enabled) {
        this.singleEditMode = enabled;
        this.updatePointPropertiesUI();
    }
    
    initializeInputDisplays() {
        const sliderPairs = [
            ['pointAmplitude', 'pointAmplitudeValue'],
            ['pointWavelength', 'pointWavelengthValue'],
            ['pointSpeed', 'pointSpeedValue'],
            ['hue1Slider', 'hue1Value'],
            ['hue2Slider', 'hue2Value'],
            ['timeMultiplierSlider', 'timeMultiplierValue'],
            ['pointPhaseOffsetSlider', 'pointPhaseOffsetValue'],
            ['dampingSlider', 'dampingValue'],
            ['performanceSlider', 'performanceValue'],
            ['patternCount', 'patternCountValue'],
            ['patternScale', 'patternScaleValue']
        ];
        
        sliderPairs.forEach(([sliderId, inputId]) => {
            const slider = document.getElementById(sliderId);
            const input = document.getElementById(inputId);
            if (slider && input) {
                const fieldType = this.inputController.getFieldType(sliderId);
                const value = parseFloat(slider.value);
                input.value = Utils.formatInputValue(value, fieldType);
            }
        });
        
        this.updatePointPropertiesUI();
    }
    
    generatePattern() {
        const type = document.getElementById('patternType').value;
        const count = parseInt(document.getElementById('patternCount').value);
        const scale = parseFloat(document.getElementById('patternScale').value);
        
        const currentCount = this.engine.points.size;
        const availableSlots = CONFIG.maxPoints - currentCount;
        
        if (availableSlots <= 0) {
            Utils.haptic();
            return;
        }
        
        const actualCount = Math.min(count, availableSlots);
        const bounds = { width: window.innerWidth, height: window.innerHeight };
        const positions = PatternGenerator.generate(type, actualCount, bounds, scale);
        
        let firstNewPoint = null;
        positions.forEach((pos, index) => {
            let finalX = pos.x, finalY = pos.y;
            if (this.animationManager.showGrid) {
                const gridSpacing = this.renderer.skipFactor * 10;
                const snapped = Utils.snapToGrid(pos.x, pos.y, gridSpacing);
                finalX = snapped.x;
                finalY = snapped.y;
            }
            
            const point = this.engine.addPoint(finalX, finalY, {
                creationIndex: this.engine.creationCounter++,
                phaseOffset: this.engine.pointPhaseOffset * (this.engine.creationCounter - 1)
            });
            if (point) {
                point.startTime = this.engine.time - (index * 0.1);
                if (!firstNewPoint) firstNewPoint = point;
            }
        });
        
        if (firstNewPoint) {
            this.selectPoint(firstNewPoint.id);
            this.animationManager.setShowPoints(true);
            this.updateButton('showPointsToggle', true);
            if (!this.animationManager.isAnimating) {
                this.animationManager.start();
            }
        }
        
        this.updatePointsUI();
        Utils.haptic();
    }
}

// ====================================================================
// MAIN WAVE SIMULATION CLASS
// ====================================================================
class WaveSimulation {
    constructor() {
        this.canvas = document.getElementById('canvas');
        
        this.engine = new WaveEngine();
        this.renderer = new Renderer(this.canvas);
        this.animationManager = new AnimationManager(this.renderer, this.engine);
        this.uiController = new UIController(this.engine, this.animationManager, this.renderer);
        this.interactionManager = new InteractionManager(this.canvas, this.uiController);
        
        window.app = this;
        
        console.log('Wave simulation initialized - proper integration');
        console.log('- Real physics engine with bottom sheet UI');
        console.log('- 5-panel carousel navigation');
        console.log('- Mobile-first design with desktop compatibility');
    }
}

// ====================================================================
// INITIALIZATION
// ====================================================================
document.addEventListener('DOMContentLoaded', () => {
    try {
        new WaveSimulation();
    } catch (error) {
        console.error('Failed to initialize wave simulation:', error);
        document.body.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; height: 100vh; color: white; text-align: center; font-family: monospace;">
                <div>
                    <h2>Wave Simulation Error</h2>
                    <p>Failed to initialize bottom sheet interface</p>
                    <p style="font-size: 12px; opacity: 0.7;">Check console for details</p>
                </div>
            </div>
        `;
    }
});
</script>
</body>
</html>