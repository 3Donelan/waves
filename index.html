<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Wave Simulation - Point Editor</title>
<style>
:root {
    --bg-primary: rgba(20, 20, 20, 0.95);
    --bg-secondary: rgba(255, 255, 255, 0.05);
    --bg-button: rgba(255, 255, 255, 0.1);
    --bg-button-hover: rgba(255, 255, 255, 0.2);
    --bg-button-active: rgba(255, 255, 255, 0.3);
    --color-primary: #00ff88;
    --color-secondary: #0088ff;
    --color-danger: #ff4444;
    --text-primary: white;
    --border-primary: rgba(255, 255, 255, 0.1);
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    overflow: hidden;
    background: #000;
}

#canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: #000;
    cursor: crosshair;
    touch-action: none;
}

.visual-indicator {
    position: fixed;
    pointer-events: none;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    opacity: 0;
    z-index: 1000;
}

.long-press-indicator {
    width: 60px;
    height: 60px;
    border: 2px solid rgba(0, 255, 136, 0.6);
}

.long-press-indicator.active {
    animation: longPressGrow 0.5s ease-out forwards;
}

.long-press-indicator.complete {
    animation: fadeOut 0.3s ease-out forwards;
}

.clone-flash {
    width: 80px;
    height: 80px;
    border: 3px solid var(--color-secondary);
    animation: pulseOut 0.5s ease-out;
}

@keyframes longPressGrow {
    from { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
    to { opacity: 1; transform: translate(-50%, -50%) scale(1.2); border-color: var(--color-primary); box-shadow: 0 0 20px rgba(0, 255, 136, 0.6); }
}

@keyframes fadeOut {
    from { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
    to { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
}

@keyframes pulseOut {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    50% { opacity: 1; }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(2); }
}

.menu-toggle {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1000;
    width: 50px;
    height: 50px;
    background: var(--bg-button);
    backdrop-filter: blur(10px);
    border: 1px solid var(--border-primary);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: 0.3s ease;
}

.menu-toggle:hover { background: var(--bg-button-hover); }

.menu-icon {
    width: 24px;
    height: 18px;
    position: relative;
}

.menu-icon span {
    display: block;
    width: 100%;
    height: 2px;
    background: var(--text-primary);
    margin: 4px 0;
    transition: 0.3s ease;
}

.menu-toggle.active .menu-icon span:nth-child(1) { transform: rotate(45deg) translate(5px, 5px); }
.menu-toggle.active .menu-icon span:nth-child(2) { opacity: 0; }
.menu-toggle.active .menu-icon span:nth-child(3) { transform: rotate(-45deg) translate(7px, -6px); }

.control-panel {
    position: fixed;
    top: 0;
    right: -360px;
    width: 360px;
    height: 100vh;
    background: var(--bg-primary);
    backdrop-filter: blur(20px);
    border-left: 1px solid var(--border-primary);
    z-index: 999;
    transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    overflow-y: auto;
    color: var(--text-primary);
}

.control-panel.open { right: 0; }

.panel-header {
    padding: 20px;
    border-bottom: 1px solid var(--border-primary);
}

.panel-title {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 5px;
}

.panel-subtitle {
    font-size: 12px;
    opacity: 0.7;
}

.control-section {
    padding: 20px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.section-title {
    font-size: 14px;
    font-weight: 500;
    margin-bottom: 15px;
    opacity: 0.9;
}

.control-group {
    margin-bottom: 20px;
}

.control-label {
    display: block;
    font-size: 12px;
    margin-bottom: 8px;
    opacity: 0.8;
}

.select-input {
    width: 100%;
    padding: 8px;
    background: var(--bg-button);
    border: 1px solid var(--border-primary);
    border-radius: 6px;
    color: var(--text-primary);
    font-size: 13px;
    cursor: pointer;
    transition: 0.2s ease;
}

.select-input:hover { background: var(--bg-button-hover); }
.select-input:focus { outline: none; border-color: var(--color-primary); }

.slider-container {
    position: relative;
}

.slider {
    width: 100%;
    height: 6px;
    background: var(--bg-button);
    border-radius: 3px;
    outline: none;
    appearance: none;
    -webkit-appearance: none;
}

.slider::-webkit-slider-thumb {
    appearance: none;
    -webkit-appearance: none;
    width: 20px;
    height: 20px;
    background: var(--text-primary);
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: var(--text-primary);
    border-radius: 50%;
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.slider-value {
    position: absolute;
    right: 0;
    top: -25px;
    font-size: 11px;
    background: var(--bg-button);
    padding: 2px 6px;
    border-radius: 3px;
    min-width: 35px;
    text-align: center;
}

.button-group {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.control-button {
    flex: 1;
    min-width: 80px;
    padding: 12px 16px;
    background: var(--bg-button);
    border: 1px solid var(--border-primary);
    border-radius: 8px;
    color: var(--text-primary);
    font-size: 13px;
    cursor: pointer;
    transition: 0.2s ease;
}

.control-button:hover { background: var(--bg-button-hover); }
.control-button:active { transform: scale(0.98); }

.control-button.active {
    background: var(--bg-button-active);
    border-color: rgba(255, 255, 255, 0.5);
}

.control-button.primary {
    background: rgba(0, 255, 136, 0.2);
    border-color: rgba(0, 255, 136, 0.4);
}

.control-button.primary:hover { background: rgba(0, 255, 136, 0.3); }

.control-button.secondary {
    background: rgba(0, 136, 255, 0.2);
    border-color: rgba(0, 136, 255, 0.4);
}

.control-button.secondary:hover { background: rgba(0, 136, 255, 0.3); }

.control-button.danger {
    background: rgba(255, 68, 68, 0.2);
    border-color: rgba(255, 68, 68, 0.4);
}

.control-button.danger:hover { background: rgba(255, 68, 68, 0.3); }

.control-button.pattern {
    background: rgba(138, 43, 226, 0.2);
    border-color: rgba(138, 43, 226, 0.4);
}

.control-button.pattern:hover { background: rgba(138, 43, 226, 0.3); }

.toggle-button.active {
    background: rgba(0, 255, 136, 0.3);
    border-color: rgba(0, 255, 136, 0.6);
    box-shadow: 0 0 10px rgba(0, 255, 136, 0.2);
}

.toggle-switch {
    position: relative;
    width: 50px;
    height: 24px;
    background: var(--bg-button);
    border-radius: 12px;
    cursor: pointer;
    transition: background 0.3s ease;
    border: 1px solid var(--border-primary);
}

.toggle-switch.active {
    background: rgba(0, 255, 136, 0.3);
    border-color: rgba(0, 255, 136, 0.6);
}

.toggle-circle {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 18px;
    height: 18px;
    background: white;
    border-radius: 50%;
    transition: transform 0.3s ease;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.toggle-switch.active .toggle-circle {
    transform: translateX(26px);
}

.info-text {
    font-size: 11px;
    opacity: 0.6;
    margin-top: 10px;
}

.stats-text {
    font-size: 10px;
    opacity: 0.5;
    margin-top: 5px;
    font-family: monospace;
}

.point-section {
    background: var(--bg-secondary);
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
}

.point-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.point-id {
    font-size: 12px;
    opacity: 0.7;
    font-family: monospace;
}

.point-list {
    max-height: 200px;
    overflow-y: auto;
    border: 1px solid var(--border-primary);
    border-radius: 5px;
}

.point-item {
    padding: 8px 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    cursor: pointer;
    transition: background 0.2s ease;
    font-size: 12px;
}

.point-item:hover { background: var(--bg-button); }
.point-item.selected { background: var(--bg-button-hover); }

.empty-state {
    text-align: center;
    opacity: 0.5;
    font-size: 12px;
    padding: 20px;
}

.panel-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.3);
    z-index: 998;
    opacity: 0;
    visibility: hidden;
    transition: 0.3s ease;
}

.panel-overlay.active {
    opacity: 1;
    visibility: visible;
}

.welcome-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(10px);
    z-index: 2000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
}

.welcome-modal {
    background: var(--bg-primary);
    backdrop-filter: blur(20px);
    border: 1px solid var(--border-primary);
    border-radius: 16px;
    max-width: 500px;
    width: 100%;
    color: var(--text-primary);
    overflow: hidden;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
}

.welcome-header {
    padding: 30px 30px 20px;
    text-align: center;
    border-bottom: 1px solid var(--border-primary);
}

.welcome-header h2 {
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 8px;
}

.welcome-header p {
    font-size: 14px;
    opacity: 0.7;
    margin: 0;
}

.welcome-content {
    padding: 25px 30px;
}

.instruction-list {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.instruction-item {
    font-size: 14px;
    line-height: 1.5;
    padding: 12px 16px;
    background: var(--bg-secondary);
    border-radius: 8px;
    border-left: 3px solid rgba(255, 255, 255, 0.3);
}

.instruction-item strong {
    color: var(--color-primary);
    font-weight: 600;
}

.welcome-footer {
    padding: 20px 30px 30px;
    text-align: center;
}

.welcome-button {
    background: linear-gradient(135deg, var(--color-primary), #00cc6a);
    border: none;
    border-radius: 12px;
    color: white;
    font-size: 16px;
    font-weight: 600;
    padding: 16px 32px;
    cursor: pointer;
    transition: 0.3s ease;
    box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
}

.welcome-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4);
}

.welcome-button:active { transform: translateY(0); }

@media (min-width: 768px) {
    .menu-toggle {
        top: 30px;
        right: 30px;
        width: 60px;
        height: 60px;
    }
    
    .control-panel {
        width: 400px;
        right: -400px;
    }
    
    .control-section {
        padding: 25px;
    }
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div class="visual-indicator long-press-indicator" id="longPressIndicator"></div>

<div class="welcome-overlay" id="welcomeOverlay">
    <div class="welcome-modal">
        <div class="welcome-header">
            <h2>Wave Physics Simulation</h2>
            <p>Interactive wave interference patterns</p>
        </div>
        <div class="welcome-content">
            <div class="instruction-list">
                <div class="instruction-item">
                    <strong>Create waves:</strong> Press and hold on empty space to add wave sources
                </div>
                <div class="instruction-item">
                    <strong>Generate patterns:</strong> Use Pattern Generator for mathematical layouts
                </div>
                <div class="instruction-item">
                    <strong>Manipulate:</strong> Select, move, clone, and customize wave points
                </div>
                <div class="instruction-item">
                    <strong>Visualize:</strong> Watch interference patterns form in real-time
                </div>
            </div>
        </div>
        <div class="welcome-footer">
            <button class="welcome-button" id="welcomeStartBtn">Get Started</button>
        </div>
    </div>
</div>

<button class="menu-toggle" id="menuToggle">
    <div class="menu-icon">
        <span></span>
        <span></span>
        <span></span>
    </div>
</button>

<div class="panel-overlay" id="panelOverlay"></div>
<div class="control-panel" id="controlPanel">
    <div class="panel-header">
        <div class="panel-title">Wave Point Editor</div>
        <div class="panel-subtitle">Press and hold on canvas to add points</div>
    </div>
    
    <div class="control-section">
        <div class="section-title">Animation</div>
        <div class="button-group">
            <button class="control-button" id="syncBtn">Sync</button>
            <button class="control-button toggle-button" id="showPointsBtn">Hide Points</button>
        </div>
        <div class="button-group" style="margin-top: 10px;">
            <button class="control-button toggle-button" id="playPauseBtn">Pause</button>
            <button class="control-button" id="clearBtn">Clear All</button>
        </div>
        <div class="info-text" id="stats">Points: 0</div>
    </div>
    
    <div class="control-section">
        <div class="section-title">Pattern Generator</div>
        <div class="control-group">
            <label class="control-label">Pattern Type</label>
            <select id="patternType" class="select-input">
                <option value="grid">Grid</option>
                <option value="radial">Radial</option>
                <option value="spiral">Spiral</option>
                <option value="sunflower">Sunflower</option>
            </select>
        </div>
        <div class="control-group">
            <label class="control-label">Number of Points</label>
            <div class="slider-container">
                <input type="range" class="slider" id="patternCount" min="4" max="36" step="1" value="16">
                <div class="slider-value" id="patternCountValue">16</div>
            </div>
        </div>
        <div class="control-group">
            <label class="control-label">Pattern Scale</label>
            <div class="slider-container">
                <input type="range" class="slider" id="patternScale" min="0.3" max="2.0" step="0.1" value="1.0">
                <div class="slider-value" id="patternScaleValue">1.0×</div>
            </div>
        </div>
        <div class="button-group">
            <button class="control-button pattern" id="generatePatternBtn">Add Pattern</button>
        </div>
        <div class="info-text">Adds to existing points (max 36 total)</div>
    </div>
    
    <div class="control-section">
        <div class="section-title">Point List</div>
        <div class="point-list" id="pointList">
            <div class="empty-state">No points created</div>
        </div>
    </div>
    
    <div class="control-section" id="selectedPointSection" style="display: none;">
        <div class="section-title">Selected Point</div>
        <div class="point-section">
            <div class="point-header">
                <span class="point-id" id="selectedPointId">Point #1</span>
            </div>
            
            <div class="control-group">
                <label class="control-label">Wave Type</label>
                <div class="button-group">
                    <button class="control-button toggle-button active" id="pointWaveTypeBtn">Sine</button>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label">Amplitude</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="pointAmplitude" min="10" max="100" step="5" value="60">
                    <div class="slider-value" id="pointAmplitudeValue">60</div>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label">Wavelength</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="pointWavelength" min="20" max="400" step="10" value="100">
                    <div class="slider-value" id="pointWavelengthValue">100px</div>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label">Propagation Speed</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="pointSpeed" min="0.1" max="1.0" step="0.1" value="1.0">
                    <div class="slider-value" id="pointSpeedValue">1.0</div>
                </div>
            </div>
            
            <div class="button-group">
                <button class="control-button secondary" id="clonePointBtn">Clone Point</button>
                <button class="control-button danger" id="deletePointBtn">Delete Point</button>
            </div>
            
            <div class="button-group" style="margin-top: 10px;">
                <button class="control-button primary" id="applyToAllBtn">Apply to All Points</button>
            </div>
        </div>
    </div>
    
    <div class="control-section">
        <div class="section-title">Medium</div>
        
        <div class="control-group">
            <label class="control-label">Color On</label>
            <div class="toggle-switch" id="colorToggle">
                <div class="toggle-circle"></div>
            </div>
        </div>
        
        <div class="control-group" id="colorControls" style="display: none;">
            <label class="control-label">Minima Color (Hue)</label>
            <div class="slider-container">
                <input type="range" class="slider" id="hue1Slider" min="0" max="360" step="1" value="240">
                <div class="slider-value" id="hue1Value">240°</div>
            </div>
        </div>
        
        <div class="control-group" id="colorControls2" style="display: none;">
            <label class="control-label">Maxima Color (Hue)</label>
            <div class="slider-container">
                <input type="range" class="slider" id="hue2Slider" min="0" max="360" step="1" value="0">
                <div class="slider-value" id="hue2Value">0°</div>
            </div>
        </div>
        
        <div class="button-group" id="colorButtons" style="display: none;">
            <button class="control-button" id="complementaryBtn">Complementary</button>
        </div>
        
        <div class="control-group" id="colorPreview" style="display: none;">
            <label class="control-label">Color Preview</label>
            <div id="gradientPreview" style="width: 100%; height: 20px; border-radius: 4px; background: linear-gradient(to right, hsl(240, 70%, 50%), hsl(0, 70%, 50%)); border: 1px solid rgba(255, 255, 255, 0.2);"></div>
        </div>
        
        <div class="control-group">
            <label class="control-label">Point Phase Offset</label>
            <div class="slider-container">
                <input type="range" class="slider" id="pointPhaseOffsetSlider" min="-2" max="2" step="0.1" value="0">
                <div class="slider-value" id="pointPhaseOffsetValue">0</div>
            </div>
        </div>
        
        <div class="control-group">
            <label class="control-label">Damping</label>
            <div class="slider-container">
                <input type="range" class="slider" id="dampingSlider" min="0.0" max="0.03" step="0.002" value="0.008">
                <div class="slider-value" id="dampingValue">0.008</div>
            </div>
        </div>
        
        <div class="control-group">
            <label class="control-label">Resolution</label>
            <div class="slider-container">
                <input type="range" class="slider" id="performanceSlider" min="0" max="5" step="1" value="1">
                <div class="slider-value" id="performanceValue">Balanced</div>
            </div>
            <div class="stats-text" id="performanceInfo">Resolution: calculating...</div>
        </div>
    </div>
</div>

<script>
'use strict';

// Configuration
const MAX_POINTS = 36;
const PERFORMANCE_LEVELS = [
    { skip: 1, label: 'Quality' },
    { skip: 2, label: 'Balanced' },
    { skip: 4, label: 'Fast' },
    { skip: 8, label: 'Faster' },
    { skip: 16, label: 'Very Fast' },
    { skip: 32, label: 'Ultra Fast' }
];

// Utility functions
const clamp = (val, min, max) => Math.max(min, Math.min(max, val));
const distance = (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
const formatValue = (val, decimals = 3) => Number(val).toFixed(decimals);
const generateId = () => `point_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

const haptic = () => {
    if ('vibrate' in navigator) navigator.vibrate(10);
};

const showVisual = (x, y, className, duration = 500) => {
    const element = document.createElement('div');
    element.className = `visual-indicator ${className}`;
    element.style.left = `${x}px`;
    element.style.top = `${y}px`;
    document.body.appendChild(element);
    setTimeout(() => element.remove(), duration);
};

const lerpHue = (hue1, hue2, t) => {
    let diff = Math.abs(hue1 - hue2);
    if (diff > 180) {
        if (hue2 > hue1) hue1 += 360;
        else hue2 += 360;
    }
    return Math.round((hue1 + (hue2 - hue1) * t) % 360);
};

const hslToRgb = (h, s, l) => {
    h /= 360;
    s /= 100;
    l /= 100;
    const c = (1 - Math.abs(2 * l - 1)) * s;
    const x = c * (1 - Math.abs((h * 6) % 2 - 1));
    const m = l - c / 2;
    
    let r, g, b;
    if (h < 1/6) [r, g, b] = [c, x, 0];
    else if (h < 2/6) [r, g, b] = [x, c, 0];
    else if (h < 3/6) [r, g, b] = [0, c, x];
    else if (h < 4/6) [r, g, b] = [0, x, c];
    else if (h < 5/6) [r, g, b] = [x, 0, c];
    else [r, g, b] = [c, 0, x];
    
    return {
        r: Math.round((r + m) * 255),
        g: Math.round((g + m) * 255),
        b: Math.round((b + m) * 255)
    };
};

// Wave Point class
class WavePoint {
    constructor(x, y, properties = {}) {
        this.id = generateId();
        this.x = x;
        this.y = y;
        this.startTime = 0;
        this.selected = false;
        this.amplitude = properties.amplitude || 60;
        this.wavelength = properties.wavelength || 100;
        this.speed = properties.speed || 1.0;
        this.waveType = properties.waveType || 'sine';
        this.phaseOffset = properties.phaseOffset || 0;
        this.creationIndex = properties.creationIndex || 0;
    }
    
    getProperties() {
        return {
            amplitude: this.amplitude,
            wavelength: this.wavelength,
            speed: this.speed,
            waveType: this.waveType,
            phaseOffset: this.phaseOffset
        };
    }
    
    distanceTo(x, y) {
        return distance(this.x, this.y, x, y);
    }
    
    isHit(x, y) {
        return this.distanceTo(x, y) <= 25;
    }
    
    getDisplayName() {
        return `Point ${this.id.split('_')[1].slice(-3)}`;
    }
    
    get frequency() {
        return (2 * Math.PI) / this.wavelength;
    }
}

// Pattern generators
const generatePattern = (type, count, bounds, scale = 1.0) => {
    const cx = bounds.width / 2;
    const cy = bounds.height / 2;
    const maxRadius = (Math.min(bounds.width, bounds.height) / 2 - 50) * scale;
    
    switch (type) {
        case 'grid': {
            const points = [];
            const gridSize = Math.ceil(Math.sqrt(count));
            const spacing = (maxRadius * 2) / (gridSize + 1);
            const startX = cx - (gridSize - 1) * spacing / 2;
            const startY = cy - (gridSize - 1) * spacing / 2;
            
            for (let i = 0; i < gridSize * gridSize && points.length < count; i++) {
                const row = Math.floor(i / gridSize);
                const col = i % gridSize;
                points.push({
                    x: startX + col * spacing,
                    y: startY + row * spacing
                });
            }
            return points;
        }
        
        case 'radial': {
            const points = [];
            const rings = Math.min(4, Math.ceil(count / 8));
            const pointsPerRing = Math.ceil(count / rings);
            
            for (let ring = 0; ring < rings; ring++) {
                const radius = ((ring + 1) / rings) * maxRadius;
                const ringCount = Math.min(pointsPerRing, count - points.length);
                
                for (let i = 0; i < ringCount; i++) {
                    const angle = (i / ringCount) * 2 * Math.PI - Math.PI / 2;
                    points.push({
                        x: cx + radius * Math.cos(angle),
                        y: cy + radius * Math.sin(angle)
                    });
                }
            }
            return points;
        }
        
        case 'spiral': {
            const points = [];
            const maxAngle = 4 * Math.PI;
            
            for (let i = 0; i < count; i++) {
                const t = (i / count) * maxAngle;
                const radius = (t / maxAngle) * maxRadius;
                points.push({
                    x: cx + radius * Math.cos(t),
                    y: cy + radius * Math.sin(t)
                });
            }
            return points;
        }
        
        case 'sunflower': {
            const points = [];
            const golden = Math.PI * (3 - Math.sqrt(5));
            
            for (let i = 0; i < count; i++) {
                const theta = i * golden;
                const radius = Math.sqrt(i / count) * maxRadius;
                points.push({
                    x: cx + radius * Math.cos(theta),
                    y: cy + radius * Math.sin(theta)
                });
            }
            return points;
        }
        
        default:
            return [];
    }
};

const findRandomPosition = (existingPoints, bounds) => {
    const margin = 30;
    const minDist = 40;
    const maxAttempts = 50;
    
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
        const x = margin + Math.random() * (bounds.width - 2 * margin);
        const y = margin + Math.random() * (bounds.height - 2 * margin);
        
        const tooClose = existingPoints.some(point => 
            distance(x, y, point.x, point.y) < minDist
        );
        
        if (!tooClose) return { x, y };
    }
    
    return {
        x: margin + Math.random() * (bounds.width - 2 * margin),
        y: margin + Math.random() * (bounds.height - 2 * margin)
    };
};

// Main Simulation class
class WaveSimulation {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        
        // State
        this.points = new Map();
        this.selectedIds = new Set();
        this.time = 0;
        this.isAnimating = false;
        this.showPoints = false;
        this.pointPhaseOffset = 0;
        this.mediumDamping = 0.008;
        this.performanceLevel = 1;
        this.useColor = false;
        this.hue1 = 240;
        this.hue2 = 0;
        this.creationCounter = 0;
        
        // Animation
        this.animationId = null;
        this.lastFrameTime = 0;
        this.frameInterval = 20; // 50fps
        
        // Rendering
        this.skipFactor = 2; // Balanced
        this.imageData = null;
        
        // UI state
        this.panelOpen = false;
        
        // Interaction state
        this.isDragging = false;
        this.dragPoint = null;
        this.startPos = { x: 0, y: 0 };
        this.longPressTimer = null;
        this.isLongPressing = false;
        this.indicator = document.getElementById('longPressIndicator');
        
        this.init();
    }
    
    init() {
        this.resize();
        this.setupEvents();
        
        // Welcome callback
        document.getElementById('welcomeStartBtn').addEventListener('click', () => {
            document.getElementById('welcomeOverlay').style.display = 'none';
            this.createStarterPoint();
        });
        
        console.log('Wave simulation initialized');
    }
    
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
    }
    
    setupEvents() {
        // Menu toggle
        document.getElementById('menuToggle').addEventListener('click', () => this.togglePanel());
        document.getElementById('panelOverlay').addEventListener('click', () => this.closePanel());
        
        // Canvas interaction
        const options = { passive: false };
        this.canvas.addEventListener('touchstart', e => this.handleStart(e, e.touches[0]), options);
        this.canvas.addEventListener('touchmove', e => this.handleMove(e, e.touches[0]), options);
        this.canvas.addEventListener('touchend', e => this.handleEnd(e), options);
        this.canvas.addEventListener('mousedown', e => this.handleStart(e, e), options);
        this.canvas.addEventListener('mousemove', e => this.handleMove(e, e), options);
        this.canvas.addEventListener('mouseup', e => this.handleEnd(e), options);
        this.canvas.addEventListener('contextmenu', e => e.preventDefault());
        
        // Control buttons
        document.getElementById('clearBtn').addEventListener('click', () => this.clearAll());
        document.getElementById('playPauseBtn').addEventListener('click', () => this.toggleAnimation());
        document.getElementById('syncBtn').addEventListener('click', () => this.syncPoints());
        document.getElementById('showPointsBtn').addEventListener('click', () => this.toggleShowPoints());
        document.getElementById('generatePatternBtn').addEventListener('click', () => this.generatePattern());
        document.getElementById('pointWaveTypeBtn').addEventListener('click', () => this.toggleWaveType());
        document.getElementById('clonePointBtn').addEventListener('click', () => this.clonePoint());
        document.getElementById('deletePointBtn').addEventListener('click', () => this.deletePoint());
        document.getElementById('applyToAllBtn').addEventListener('click', () => this.applyToAllPoints());
        document.getElementById('colorToggle').addEventListener('click', () => this.toggleColorMode());
        document.getElementById('complementaryBtn').addEventListener('click', () => this.setComplementaryColors());
        
        // Sliders
        this.setupSlider('pointAmplitude', (v) => this.updatePointProperty('amplitude', parseInt(v)), 0);
        this.setupSlider('pointWavelength', (v) => this.updatePointProperty('wavelength', parseInt(v)), 0, 'px');
        this.setupSlider('pointSpeed', (v) => this.updatePointProperty('speed', parseFloat(v)), 1);
        this.setupSlider('dampingSlider', (v) => { this.mediumDamping = parseFloat(v); this.updateSliderValue('dampingValue', v); });
        this.setupSlider('hue1Slider', (v) => { this.hue1 = parseInt(v); this.updateColorPreview(); this.render(); }, 0, '°');
        this.setupSlider('hue2Slider', (v) => { this.hue2 = parseInt(v); this.updateColorPreview(); this.render(); }, 0, '°');
        this.setupSlider('performanceSlider', (v) => this.setPerformanceLevel(parseInt(v)));
        this.setupSlider('patternCount', (v) => this.updateSliderValue('patternCountValue', v));
        this.setupSlider('patternScale', (v) => this.updateSliderValue('patternScaleValue', v + '×'));
        this.setupSlider('pointPhaseOffsetSlider', (v) => { 
            this.pointPhaseOffset = parseFloat(v) * Math.PI; 
            this.updateSliderValue('pointPhaseOffsetValue', this.formatPiMultiplier(parseFloat(v)));
            this.applyPointPhaseOffsets();
        });
        
        // Point list
        document.getElementById('pointList').addEventListener('click', (e) => {
            const item = e.target.closest('.point-item');
            if (item) {
                const isMultiSelect = e.ctrlKey || e.shiftKey;
                this.selectPoint(item.dataset.id, isMultiSelect);
            }
        });
        
        // Window events
        window.addEventListener('resize', () => {
            this.resize();
            this.updatePerformanceInfo();
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.panelOpen) {
                this.closePanel();
            }
            
            const selected = this.getSelectedPoints();
            if (selected.length > 0) {
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    e.preventDefault();
                    this.deletePoint();
                } else if (e.key === 'c' || e.key === 'C') {
                    e.preventDefault();
                    this.clonePoint();
                }
            }
        });
        
        this.updatePerformanceInfo();
    }
    
    setupSlider(id, handler, decimals = 3, suffix = '') {
        const slider = document.getElementById(id);
        const valueEl = document.getElementById(id.replace('Slider', 'Value'));
        
        if (slider) {
            slider.addEventListener('input', (e) => {
                const value = e.target.value;
                handler(value);
                if (valueEl) {
                    const formatted = decimals > 0 ? formatValue(value, decimals) : value;
                    valueEl.textContent = formatted + suffix;
                }
            });
        }
    }
    
    updateSliderValue(id, value) {
        const el = document.getElementById(id);
        if (el) el.textContent = value;
    }
    
    formatPiMultiplier(value) {
        if (value === 0) return '0';
        if (value === 1) return 'π';
        if (value === -1) return '-π';
        if (value % 1 === 0) return `${value}π`;
        return `${formatValue(value, 1)}π`;
    }
    
    // Panel management
    togglePanel() {
        this.panelOpen ? this.closePanel() : this.openPanel();
    }
    
    openPanel() {
        this.panelOpen = true;
        document.getElementById('controlPanel').classList.add('open');
        document.getElementById('panelOverlay').classList.add('active');
        document.getElementById('menuToggle').classList.add('active');
    }
    
    closePanel() {
        this.panelOpen = false;
        document.getElementById('controlPanel').classList.remove('open');
        document.getElementById('panelOverlay').classList.remove('active');
        document.getElementById('menuToggle').classList.remove('active');
    }
    
    // Interaction handling
    getCoordinates(pointer) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        
        return {
            x: Math.floor((pointer.clientX - rect.left) * scaleX),
            y: Math.floor((pointer.clientY - rect.top) * scaleY)
        };
    }
    
    startLongPress(x, y) {
        this.isLongPressing = true;
        
        if (this.indicator) {
            this.indicator.style.left = `${x}px`;
            this.indicator.style.top = `${y}px`;
            this.indicator.classList.add('active');
        }
        
        this.longPressTimer = setTimeout(() => {
            if (this.isLongPressing) {
                this.completeLongPress(x, y);
            }
        }, 500);
    }
    
    completeLongPress(x, y) {
        haptic();
        
        if (this.indicator) {
            this.indicator.classList.remove('active');
            this.indicator.classList.add('complete');
            setTimeout(() => this.indicator.classList.remove('complete'), 300);
        }
        
        this.addPoint(x, y);
        this.cancelLongPress();
    }
    
    cancelLongPress() {
        if (this.longPressTimer) {
            clearTimeout(this.longPressTimer);
            this.longPressTimer = null;
        }
        this.isLongPressing = false;
        
        if (this.indicator) {
            this.indicator.classList.remove('active', 'complete');
        }
    }
    
    handleStart(event, pointer) {
        event.preventDefault();
        const coords = this.getCoordinates(pointer);
        this.startPos = coords;
        
        const hitPoint = this.findPointAt(coords.x, coords.y);
        const isMultiSelect = event.ctrlKey || event.shiftKey;
        
        if (hitPoint) {
            this.selectPoint(hitPoint.id, isMultiSelect);
            this.isDragging = true;
            this.dragPoint = hitPoint;
            this.canvas.style.cursor = 'grabbing';
        } else {
            if (!isMultiSelect) {
                this.startLongPress(coords.x, coords.y);
                this.deselectAll();
            }
        }
    }
    
    handleMove(event, pointer) {
        const coords = this.getCoordinates(pointer);
        const dist = distance(coords.x, coords.y, this.startPos.x, this.startPos.y);
        
        if (dist > 10) {
            this.cancelLongPress();
        }
        
        if (this.isDragging && this.dragPoint) {
            event.preventDefault();
            if (dist > 5) {
                this.dragPoint.x = coords.x;
                this.dragPoint.y = coords.y;
                this.render();
            }
        }
    }
    
    handleEnd(event) {
        if (this.isDragging) {
            event.preventDefault();
            this.isDragging = false;
            this.dragPoint = null;
            this.canvas.style.cursor = 'crosshair';
        }
        this.cancelLongPress();
    }
    
    // Point management
    addPoint(x, y, properties = {}) {
        if (this.points.size >= MAX_POINTS) {
            haptic();
            return;
        }
        
        const point = new WavePoint(x, y, { 
            ...properties, 
            creationIndex: this.creationCounter++,
            phaseOffset: this.pointPhaseOffset * (this.creationCounter - 1)
        });
        point.startTime = this.time;
        this.points.set(point.id, point);
        this.selectPoint(point.id);
        
        if (!this.isAnimating && this.points.size > 0) {
            this.startAnimation();
        }
        
        this.updatePointsUI();
    }
    
    removePoint(id) {
        this.selectedIds.delete(id);
        this.points.delete(id);
        this.updatePointsUI();
        this.updateSelectedPointUI();
        
        if (this.points.size === 0) {
            this.stopAnimation();
        }
    }
    
    findPointAt(x, y) {
        for (const point of this.points.values()) {
            if (point.isHit(x, y)) return point;
        }
        return null;
    }
    
    selectPoint(id, multiSelect = false) {
        if (!multiSelect) {
            for (const prevId of this.selectedIds) {
                const prev = this.points.get(prevId);
                if (prev) prev.selected = false;
            }
            this.selectedIds.clear();
        }
        
        const point = this.points.get(id);
        if (point) {
            if (this.selectedIds.has(id) && multiSelect) {
                this.selectedIds.delete(id);
                point.selected = false;
            } else {
                this.selectedIds.add(id);
                point.selected = true;
            }
        }
        
        this.updateSelectedPointUI();
        this.updatePointsUI();
    }
    
    deselectAll() {
        for (const id of this.selectedIds) {
            const point = this.points.get(id);
            if (point) point.selected = false;
        }
        this.selectedIds.clear();
        this.updateSelectedPointUI();
        this.updatePointsUI();
    }
    
    getSelectedPoints() {
        return Array.from(this.selectedIds).map(id => this.points.get(id)).filter(p => p);
    }
    
    // Actions
    clearAll() {
        this.points.clear();
        this.selectedIds.clear();
        this.time = 0;
        this.showPoints = false;
        this.stopAnimation();
        this.cleanup();
        this.updatePointsUI();
        this.updateSelectedPointUI();
        this.updateButton('showPointsBtn', false, 'Show Points', 'Hide Points');
        this.render();
    }
    
    applyPointPhaseOffsets() {
        const points = Array.from(this.points.values()).sort((a, b) => a.creationIndex - b.creationIndex);
        points.forEach((point, index) => {
            point.phaseOffset = this.pointPhaseOffset * index;
        });
        this.render();
    }
    
    generatePattern() {
        const type = document.getElementById('patternType').value;
        const count = parseInt(document.getElementById('patternCount').value);
        const scale = parseFloat(document.getElementById('patternScale').value);
        
        const currentCount = this.points.size;
        const availableSlots = MAX_POINTS - currentCount;
        
        if (availableSlots <= 0) {
            haptic();
            return;
        }
        
        const actualCount = Math.min(count, availableSlots);
        const bounds = { width: window.innerWidth, height: window.innerHeight };
        const positions = generatePattern(type, actualCount, bounds, scale);
        
        positions.forEach((pos, index) => {
            const point = new WavePoint(pos.x, pos.y, {
                creationIndex: this.creationCounter++,
                phaseOffset: this.pointPhaseOffset * (this.creationCounter - 1)
            });
            point.startTime = this.time - (index * 0.1);
            this.points.set(point.id, point);
        });
        
        if (positions.length > 0) {
            const allPoints = Array.from(this.points.values());
            const firstNew = allPoints[allPoints.length - positions.length];
            if (firstNew) this.selectPoint(firstNew.id);
            
            this.showPoints = true;
            this.updateButton('showPointsBtn', true, 'Hide Points', 'Show Points');
            if (!this.isAnimating) {
                this.startAnimation();
            }
        }
        
        this.updatePointsUI();
        haptic();
    }
    
    clonePoint() {
        const selectedPoints = this.getSelectedPoints();
        if (selectedPoints.length === 0) return;
        
        const bounds = { width: window.innerWidth, height: window.innerHeight };
        const newPoints = [];
        
        selectedPoints.forEach(selected => {
            const availableSlots = MAX_POINTS - this.points.size;
            if (availableSlots <= 0) return;
            
            const pos = findRandomPosition(Array.from(this.points.values()), bounds);
            const clone = new WavePoint(pos.x, pos.y, {
                ...selected.getProperties(),
                creationIndex: this.creationCounter++,
                phaseOffset: this.pointPhaseOffset * (this.creationCounter - 1)
            });
            clone.startTime = this.time;
            this.points.set(clone.id, clone);
            newPoints.push(clone);
            
            showVisual(pos.x, pos.y, 'clone-flash');
        });
        
        if (newPoints.length > 0) {
            this.deselectAll();
            newPoints.forEach((point, index) => {
                this.selectPoint(point.id, index > 0);
            });
            
            if (!this.isAnimating) {
                this.startAnimation();
            }
        }
        
        this.updatePointsUI();
        haptic();
    }
    
    deletePoint() {
        const selectedPoints = this.getSelectedPoints();
        selectedPoints.forEach(point => {
            this.removePoint(point.id);
        });
    }
    
    applyToAllPoints() {
        if (this.points.size === 0) return;
        
        const amplitude = parseInt(document.getElementById('pointAmplitude').value);
        const wavelength = parseInt(document.getElementById('pointWavelength').value);
        const speed = parseFloat(document.getElementById('pointSpeed').value);
        const waveTypeBtn = document.getElementById('pointWaveTypeBtn');
        const waveType = waveTypeBtn.classList.contains('active') ? 'sine' : 'step';
        
        for (const point of this.points.values()) {
            point.amplitude = amplitude;
            point.wavelength = wavelength;
            point.speed = speed;
            point.waveType = waveType;
        }
        
        this.updatePointsUI();
        haptic();
        this.render();
    }
    
    toggleWaveType() {
        const selectedPoints = this.getSelectedPoints();
        if (selectedPoints.length > 0) {
            selectedPoints.forEach(point => {
                point.waveType = point.waveType === 'sine' ? 'step' : 'sine';
            });
            this.updateSelectedPointUI();
            this.updatePointsUI();
        }
    }
    
    updatePointProperty(property, value) {
        const selectedPoints = this.getSelectedPoints();
        if (selectedPoints.length > 0) {
            selectedPoints.forEach(point => {
                point[property] = value;
            });
            this.updateSelectedPointUI();
            this.updatePointsUI();
        }
    }
    
    syncPoints() {
        if (this.points.size === 0) return;
        
        this.time = 0;
        this.pointPhaseOffset = 0;
        
        for (const point of this.points.values()) {
            point.startTime = 0;
            point.phaseOffset = 0;
        }
        
        // Reset UI controls
        document.getElementById('pointPhaseOffsetSlider').value = 0;
        this.updateSliderValue('pointPhaseOffsetValue', '0');
        
        if (!this.isAnimating) {
            this.startAnimation();
        }
        
        this.render();
    }
    
    toggleShowPoints() {
        this.showPoints = !this.showPoints;
        this.updateButton('showPointsBtn', this.showPoints, 'Hide Points', 'Show Points');
        this.render();
    }
    
    toggleColorMode() {
        this.useColor = !this.useColor;
        const toggle = document.getElementById('colorToggle');
        if (toggle) {
            toggle.classList.toggle('active', this.useColor);
        }
        this.updateColorControls();
        this.render();
    }
    
    setComplementaryColors() {
        const complementary = (this.hue1 + 180) % 360;
        this.hue2 = complementary;
        document.getElementById('hue2Slider').value = complementary;
        this.updateColorPreview();
    }
    
    setPerformanceLevel(level) {
        this.performanceLevel = level;
        this.skipFactor = PERFORMANCE_LEVELS[level].skip;
        this.updatePerformanceInfo();
    }
    
    createStarterPoint() {
        const cx = Math.floor(window.innerWidth / 2);
        const cy = Math.floor(window.innerHeight / 2);
        const point = new WavePoint(cx, cy, {
            creationIndex: this.creationCounter++,
            phaseOffset: 0
        });
        point.startTime = 0;
        this.points.set(point.id, point);
        this.selectPoint(point.id);
        this.startAnimation();
        this.updatePointsUI();
    }
    
    cleanup() {
        this.isDragging = false;
        this.dragPoint = null;
        this.canvas.style.cursor = 'crosshair';
        this.cancelLongPress();
    }
    
    // Animation
    startAnimation() {
        this.isAnimating = true;
        this.lastFrameTime = performance.now();
        this.updateButton('playPauseBtn', false, 'Play', 'Pause');
        this.animate();
    }
    
    stopAnimation() {
        this.isAnimating = false;
        this.updateButton('playPauseBtn', true, 'Play', 'Pause');
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
    }
    
    toggleAnimation() {
        this.isAnimating ? this.stopAnimation() : this.startAnimation();
    }
    
    animate() {
        const currentTime = performance.now();
        
        if (this.isAnimating && (currentTime - this.lastFrameTime) >= this.frameInterval) {
            this.time += 0.2;
            this.render();
            this.lastFrameTime = currentTime;
        }
        
        if (this.isAnimating) {
            this.animationId = requestAnimationFrame(() => this.animate());
        }
    }
    
    // Rendering
    render() {
        this.clearCanvas();
        if (this.points.size > 0) {
            this.renderWaveField();
        }
        this.ctx.putImageData(this.imageData, 0, 0);
        this.renderPoints();
    }
    
    clearCanvas() {
        const data = this.imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            data[i] = data[i + 1] = data[i + 2] = 0;
            data[i + 3] = 255;
        }
    }
    
    renderWaveField() {
        const { width, height } = this.canvas;
        const skip = this.skipFactor;
        
        for (let y = 0; y < height; y += skip) {
            for (let x = 0; x < width; x += skip) {
                const color = this.calculatePixel(x, y);
                this.fillBlock(x, y, color, skip);
            }
        }
    }
    
    calculatePixel(x, y) {
        let totalWave = 0;
        
        for (const point of this.points.values()) {
            const age = this.time - point.startTime;
            if (age < 0) continue;
            
            const dist = point.distanceTo(x, y);
            const phase = point.frequency * dist - point.speed * age + point.phaseOffset;
            
            let waveValue;
            if (point.waveType === 'sine') {
                waveValue = point.amplitude * Math.sin(phase);
            } else {
                const normalized = ((phase % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
                waveValue = point.amplitude * (normalized < Math.PI ? 1 : -1);
            }
            
            waveValue *= Math.exp(-dist * this.mediumDamping);
            totalWave += waveValue;
        }
        
        return this.waveToColor(totalWave);
    }
    
    waveToColor(waveValue) {
        if (!this.useColor) {
            const normalized = waveValue / 100;
            return clamp(128 + normalized * 127, 0, 255);
        }
        
        const normalizedValue = clamp((waveValue / 100 + 1) / 2, 0, 1);
        const interpolatedHue = lerpHue(this.hue1, this.hue2, normalizedValue);
        return hslToRgb(interpolatedHue, 70, 50);
    }
    
    fillBlock(startX, startY, color, size) {
        const data = this.imageData.data;
        const { width, height } = this.canvas;
        
        for (let dy = 0; dy < size && startY + dy < height; dy++) {
            for (let dx = 0; dx < size && startX + dx < width; dx++) {
                const index = ((startY + dy) * width + (startX + dx)) * 4;
                
                if (typeof color === 'object') {
                    data[index] = color.r;
                    data[index + 1] = color.g;
                    data[index + 2] = color.b;
                } else {
                    data[index] = data[index + 1] = data[index + 2] = color;
                }
            }
        }
    }
    
    renderPoints() {
        const selected = this.getSelectedPoints();
        
        if (this.showPoints) {
            for (const point of this.points.values()) {
                this.drawPoint(point);
            }
        } else if (selected.length > 0) {
            selected.forEach(point => this.drawPoint(point));
        }
    }
    
    drawPoint(point) {
        const visualRadius = 10;
        const hitRadius = 25;
        const borderWidth = 2;
        
        if (point.selected) {
            this.ctx.strokeStyle = '#00ff88';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(point.x, point.y, hitRadius, 0, 2 * Math.PI);
            this.ctx.stroke();
        }
        
        // Draw border (dark outline)
        this.ctx.fillStyle = '#333333';
        this.ctx.beginPath();
        this.ctx.arc(point.x, point.y, visualRadius + borderWidth, 0, 2 * Math.PI);
        this.ctx.fill();
        
        // Draw main dot (white)
        this.ctx.fillStyle = 'white';
        this.ctx.beginPath();
        this.ctx.arc(point.x, point.y, visualRadius, 0, 2 * Math.PI);
        this.ctx.fill();
    }
    
    // UI Updates
    updateButton(id, isActive, activeText, inactiveText) {
        const btn = document.getElementById(id);
        if (btn) {
            btn.classList.toggle('active', isActive);
            btn.textContent = isActive ? activeText : inactiveText;
        }
    }
    
    updateColorControls() {
        const controls = ['colorControls', 'colorControls2', 'colorButtons', 'colorPreview'];
        controls.forEach(id => {
            const element = document.getElementById(id);
            if (element) element.style.display = this.useColor ? 'block' : 'none';
        });
        
        const toggle = document.getElementById('colorToggle');
        if (toggle) {
            toggle.classList.toggle('active', this.useColor);
        }
    }
    
    updateColorPreview() {
        const preview = document.getElementById('gradientPreview');
        if (preview) {
            preview.style.background = `linear-gradient(to right, hsl(${this.hue1}, 70%, 50%), hsl(${this.hue2}, 70%, 50%))`;
        }
        this.updateSliderValue('hue1Value', `${this.hue1}°`);
        this.updateSliderValue('hue2Value', `${this.hue2}°`);
    }
    
    updatePointsUI() {
        const count = this.points.size;
        document.getElementById('stats').textContent = `Points: ${count}/${MAX_POINTS}`;
        
        const list = document.getElementById('pointList');
        if (count === 0) {
            list.innerHTML = '<div class="empty-state">No points created</div>';
        } else {
            list.innerHTML = Array.from(this.points.values()).map(point => `
                <div class="point-item ${point.selected ? 'selected' : ''}" data-id="${point.id}">
                    ${point.getDisplayName()} - ${point.waveType} (${point.amplitude})
                </div>
            `).join('');
        }
    }
    
    updateSelectedPointUI() {
        const selectedPoints = this.getSelectedPoints();
        const section = document.getElementById('selectedPointSection');
        
        section.style.display = selectedPoints.length > 0 ? 'block' : 'none';
        if (selectedPoints.length === 0) return;
        
        if (selectedPoints.length > 1) {
            document.getElementById('selectedPointId').textContent = `${selectedPoints.length} Points Selected`;
            
            // Show average values
            const avgAmplitude = Math.round(selectedPoints.reduce((sum, p) => sum + p.amplitude, 0) / selectedPoints.length);
            const avgWavelength = Math.round(selectedPoints.reduce((sum, p) => sum + p.wavelength, 0) / selectedPoints.length);
            const avgSpeed = selectedPoints.reduce((sum, p) => sum + p.speed, 0) / selectedPoints.length;
            
            document.getElementById('pointAmplitude').value = avgAmplitude;
            document.getElementById('pointAmplitudeValue').textContent = avgAmplitude;
            document.getElementById('pointWavelength').value = avgWavelength;
            document.getElementById('pointWavelengthValue').textContent = avgWavelength + 'px';
            document.getElementById('pointSpeed').value = avgSpeed;
            document.getElementById('pointSpeedValue').textContent = formatValue(avgSpeed, 1);
            
            const firstType = selectedPoints[0].waveType;
            const allSameType = selectedPoints.every(p => p.waveType === firstType);
            
            if (allSameType) {
                this.updateButton('pointWaveTypeBtn', firstType === 'sine', 'Sine', 'Digital');
            } else {
                document.getElementById('pointWaveTypeBtn').textContent = 'Mixed';
                document.getElementById('pointWaveTypeBtn').classList.remove('active');
            }
        } else {
            const point = selectedPoints[0];
            document.getElementById('selectedPointId').textContent = point.getDisplayName();
            
            document.getElementById('pointAmplitude').value = point.amplitude;
            document.getElementById('pointAmplitudeValue').textContent = point.amplitude;
            document.getElementById('pointWavelength').value = point.wavelength;
            document.getElementById('pointWavelengthValue').textContent = point.wavelength + 'px';
            document.getElementById('pointSpeed').value = point.speed;
            document.getElementById('pointSpeedValue').textContent = formatValue(point.speed, 1);
            
            this.updateButton('pointWaveTypeBtn', point.waveType === 'sine', 'Sine', 'Digital');
        }
    }
    
    updatePerformanceInfo() {
        const config = PERFORMANCE_LEVELS[this.performanceLevel];
        const width = Math.floor(window.innerWidth / config.skip);
        const height = Math.floor(window.innerHeight / config.skip);
        const speedup = config.skip === 1 ? '' : ` (${config.skip ** 2}x faster)`;
        
        this.updateSliderValue('performanceValue', config.label);
        document.getElementById('performanceInfo').textContent = `Resolution: ${width}×${height}${speedup}`;
    }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    try {
        new WaveSimulation();
    } catch (error) {
        console.error('Failed to initialize wave simulation:', error);
        document.body.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; height: 100vh; color: white; text-align: center; font-family: monospace;">
                <div>
                    <h2>Wave Simulation Error</h2>
                    <p>Failed to initialize application</p>
                    <p style="font-size: 12px; opacity: 0.7;">Check console for details</p>
                </div>
            </div>
        `;
    }
});
</script>
</body>
</html>